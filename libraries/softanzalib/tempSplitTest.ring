load "stzlib.ring"

StartProfiler()

# You can find the positions of any substring occurring between
# two bounds by saying:

o1 = new stzString("txt <<ring>> txt <<php>>")
? @@( o1.FindAnyBetween("<<",">>") )
#--> [7, 20]

# In fact, the substring "ring" occures in position 7 and "php" in position 20.

# Now, if you have the following case where the two bounds are
# the same (equal to "*" here):

o1 = new stzString("*2*45*78*0*")
? @@( o1.FindAnyBetween("*","*") )
#--> [2, 7]

# then you get "2" that starts at position 2 and "78" at position 7.
# Let's understand what happened to get this result:

	# the positions	:  12345678901
	# the string	: "*2*45*78*0*"
	# the occurences:   ^    ^

# Softanza starts scanning the string. First, it finds that "*2*"
# corresonds to a substring ("2") between "*" and "*". Then it
# takes its position 2.

# Then, Softanza restarts from position 3 and scans the remaining
# substring "45*78*0*" for any other substring between "*" and "*".
# It finds it at position 7 (substring "78").

# Until now, we have positions 2 and 7.

# Again, Softanza retrives "*78*" from "45*78*0*". Now the substring
# to be scanned is "45*". There is no substrings between "*" and "*".
# So the result [2, 7] is returned.

# Now, you would ask me: What if I want to get all the positions of
# substrings separated by the char "*", like this:

	# the positions	:  12345678901
	# the string	: "*2*45*78*0*"
	# the occurences:   ^ ^  ^  ^
	# --> [2, 4, 7, 10]

# Then you can use FindAnySplittedBy() function and
# pass the "*" char as a parameter like this:

? @@( o1.AnySplittedBy("*"))
? @@( o1.FindAnySplittedBy("*") )
#--> [ 2, 4, 7, 10 ]

? @@( o1.SeparatedBy("*") )
? @@( o1.FindSeparatedBy("*") )

StopProfiler()


#----- MISC. -----
/*
o1 = new stzListOfStrings([ "ring", "programming", "languag" ])
? o1.ConcatenatedUsing(" ") #--> ring programming languag

o1 = new stzListOfStrings([ ])
? @@( o1.ConcatenatedUsing(" ") ) #--> ""

#--------

o1 = new stzListOfStrings([ "aa", "  ", "b", "     ", "ccc" ])
o1.RemoveBlankSpacesStrings()
? o1.Content()

#--------

? SectionToRange([3, 7]) #--> [ 3, 4 ]
? RangeToSection([3, 4]) #--> [ 3, 7 ]

/*-----------------
*/

o1 = new stzString("AAA;;bbB;  ;Ccc;;Ddd;EEe")
? o1.SplitXT(";", [
	:CS = FALSE, :StartAt = 1, :EndAt = :LastChar, :MaxNumberOfParts = :All,

	:IgnoreFirstSep = False, :IgnoreLastSep = FALSE,

	//:PerformOnEachCharW = NULL
	:PerformOnEachCharW = [ '@char = Q(@char).Uppercased()', :If = 'Q(@char).IsLowercase()' ],

	:removeemptyparts = true, :removeblankspaceparts = true,

	#--

	:removefirstsplittedpart = true, :removelastsplittedpart = true//,
/*	:removethesesplittedparts = [1, 3],

	:RemoveTheseLeadingSubstringsInEachPart = [""],
	:RemoveTheseTrailingSubstringsInEachPart = [""],

	:RemoveLeadingCharsInEachPart = true,
	:RemoveTrailingCharsInEachPart = false,

	:RemoveThisLeadingCharInEachPart = "",
	:RemoveThisTrailingCharInEachPart = "",

	:RemoveNLeadingCharsInEachPart = 0 ,
	:RemoveNTrailingCharsInEachPart = 0,
			
	:PerformOnEachPartW = ["",""]
*/
])

/*
---- Before splitting

--#1	:CaseSensitive, :CS,
			
#2	:StartAt,
#3	:EndAt,

#4	:MaxNumberOfParts,
			
#5	:IgnoreFirstSep,
#6	:IgnoreLastSep,

#7	:PerformOnEachCharW,
			
---- After splitting
			
#8	:RemoveEmptyParts,
#9	:RemoveBlankSpaceParts,
			
#10	:RemoveFirstSplittedPart,
		# Splitted --> cFirstPart generated by :IgnoreFirstSep
		# is not concerned

#11	:RemoveLastSplittedPart,
		# Splitted --> cLastPart generated by :IgnoreLastSep is
		# not concerned

#12	:RemoveTheseSplittedParts,
		# Spliited --> cFirstPart and cLastPart generated by
		# :IgnoreFirstSep and :IgnoreLastSep are not concerned

#13	:RemoveTheseLeadingSubstringsInEachPart,
#14	:RemoveTheseTrailingSubstringsInEachPart,
#15	:RemoveLeadingCharsInEachPart,
#16	:RemoveTrailingCharsInEachPart,
		
#17	:RemoveThisLeadingCharInEachPart,
#18	:RemoveThisTrailingCharInEachPart,
			
#19	:RemoveNLeadingCharsInEachPart,
#20	:RemoveNTrailingCharsInEachPart,
			
#21	:PerformOnEachPartW
