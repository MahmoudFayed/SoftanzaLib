#-------------------------------------------------------------------------#
# 		   SOFTANZA LIBRARY (V1.0) - STZSTRING			  #
#	An accelerative library for Ring applications, and more!	  #
#-------------------------------------------------------------------------#
#									  #
# 	Description	: The core class for managing Unicode strings     #
#	Version		: V1.0 (2020-2023)				  #
#	Author		: Mansour Ayouni (kalidianow@gmail.com)		  #
#								          #
#-------------------------------------------------------------------------#

/*
	TODO Add:
	QStringRef methods

	TODO: use QStringView for read-only operations, and QByteArray for
	UT8-only string
	#--> Better performance.

	Todo:
	Get inspiration from the pyhthon ftfy library to add Unicode text
	cleansing in Softanza
	link: https://ftfy.readthedocs.io/en/latest/fixes.html
*/

  /////////////////////
 ///   FUNCTIONS   ///
/////////////////////

func StzStringQ(str)
	return new stzString(str)

func StzStringMethods()
	return Stz(:String, :Methods)

func StzStringAttributes()
	return Stz(:String, :Attributes)

func StzStringClassName()
	return Stz(:String, :ClassName)

	func StzStringClass()
		return StzStringClassName()

func S(p)
	if isString(p)
		return p

	but isNumber(p)
		return ""+ p

	but isList(p)
		return Q(p).ToCode()

	but isObject(p)
		return LQ(p).ToCode()
	ok

	func SQ(p)
		return Q( S(p) )

		func QS(p)
			return SQ(p)

func IsNotString(pcStr)
	return NOT isString(pcStr)
	
func IsNullString(cStr)
	if isString(cStr) and cStr != NULL
		return TRUE
	else
		return FALSE
	ok

	func IsEmptyString(cStr)
		return IsNullString(cStr)

func IsNonNullString(cStr)
	return NOT IsNullString(cStr)

	func IsNonEmptyString(cStr)
		return This.IsNonNullString(cStr)

	func IsFullString(cStr)
		return This.IsNonNullString(cStr)

func StringToQString(cStr)
	oStr = new stzString(cStr)
	return oStr.QStringObject()
	
func IsQString(p)

	if isObject(p) and ( classname(p) = "qstring" or classname(p) = "qstring2" )
		return TRUE
	else
		return FALSE
	ok

	#--

	def IsQStringObject(p)
		return IsQString(p)
	
func QStringContent(oQStr)

	try
		return oQStr.left(oQStr.count())
	catch
		stzRaise(stzStringError(:CanNotTransformQStringToString))
	done

	#--

	func QStringObjectContent(oQStr)
		return QStringContent(oQStr)

	func QStringToString(oQStr)
		return QStringContent(oQStr)

	func QStringObjectToString(oQStr)
		return QStringContent(oQStr)
	
func QStringToStzString(oQString)
	return new stzString(QStringToString(oQString))

	func QStringObjectToStzString(oQString)
		return QStringToStzString(oQString)
	
func StringIsEmpty(pcStr)
	return pcStr = ""

func StringIsNull(pcStr)
	return pcStr = ""

func StzStringToQString(oStr)
	return oStr.QStringObject()
	
func StringIsLocaleAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLocaleAbbreviation()
	
func StringIsLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageAbbreviation()
	
func StringIsShortLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortLanguageAbbreviation()
	
func StringIsLongLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongLanguageAbbreviation()
	
func StringIsLanguageName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageName()
	
func StringIsLanguageNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageNumber()
	
func StringIsCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryAbbreviation()
	
func StringIsCountryName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryName()
	
func StringIsCountryNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryNumber()
	
func StringIsShortCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortCountryAbbreviation()
	
func StringIsLongCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongCountryAbbreviation()
	
func StringIsScriptAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptAbbreviation()
	
func StringIsScriptName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptName()
	
func StringIsScriptNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptNumber()
	
func StringIsLowercase(cStr)
	return StzStringQ(cStr).IsLowercase()

func StringIsUppercase(cStr)
	return StzStringQ(cStr).IsUppercase()

func StringLowercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Lowercased()
	
	func StringLowercase(cStr)
		return StringLowercased(cStr)

func StringUppercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Uppercased()
	
	func StringUppercase(cStr)
		return StringUppercased(cStr)
	
func StringTitlecased(cStr)
	oStr = new stzString(cStr)
	return oStr.Titlecased()
	
	func StringTitlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecased(cStr)
		return StringTitlecased(cStr)

	
func StringAlign(cString, nWidth, cChar, cDirection)
	oString = new stzString(cString)
	return oString.AlignXTQ(nWidth, cChar, cDirection).Content()
	
func StringLeftAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Left)
	
func StringRightAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Right)
	
func StringCenterAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Center)
	
func StringRepeat(cString, n)
	oString = new stzString(cString)
	return oString.RepeatedNTimes(n)
	
func StringNumberOfChars(cStr)
	oString = new stzString(cStr)
	return oString.NumberOfChars()
	
func StringReverseChars(cStr)
	oString = new stzString(cStr)
	return oString.CharsReversed()
	
func StringIsWord(cStr)
	oString = new stzString(cStr)
	return oString.IsWord()
	
func StringContains(pcStr, pcSubStr)
	return StzStringQ(pcStr).Contains(pcSubStr)
	
func StringNumberOfOccurrence(pcStr, pcSubStr)
	return StzStringQ(pcStr).NumberOfOccurrence(pcSubStr)
	
func StringToUnicodes(pcStr)
	return StzStringQ(pcStr).Unicodes()
	
	func StringUnicodes(pcStr)
		return StringToUnicodes(pcStr)
	
func StringInvert(cStr)
	return StzStringQ(cStr).Inverted()
	
func StringScript(cStr)
	return StzStringQ(cStr).Script()

# Some functions used mainly in natural-code

func UppercaseOf(cStr)
	return StzStringQ(cStr).Uppercased()

	func UppercaseIn(cStr)
		return UppercaseOf(cStr)

func LowercaseOf(cStr)
	return StzStringQ(cStr).Lowercased()

	func LowercaseIn(cStr)
		return LowercaseOf(cStr)

func FoldcaseOf(cStr)
	return StzStringQ(cStr).Foldcase()

	func FoldcaseIn(cStr)
		return FoldcaseOf(cStr)

func NthCharOf(n, cStr)
	return StzStringQ(cStr)[n]

	func NthCharIn(n, cStr)
		return NthCharOf(n, cStr)

func NthLetterOf(n, cStr)
		aOnlyLetters = StzStringQ(cStr).OnlyLetters()
		return aOnlyLetters[n]

	func NthLetterIn(n, cStr)
		return NthLetterOf(n, cStr)

func StringIsArabicWord(pcStr)
	return StzStringQ(pcStr).IsArabicWord()

func StringIsCharName(pcStr)
	return StzStringQ(pcStr).IsCharName()

# Used for natural-coding

func String(pcStr)
	if isString(pcStr)
		return pcStr
	ok

func Text(pcStr)
	# NOTE: In the future, there will be a difference
	# between String and Text
	if isString(pcStr)
		return pcStr
	ok

func Word(pcStr)
	if StringIsWord(pcStr)
		return pcStr
	ok

func String@(pcStr)
	if isString(pcStr)
		return ComputableForm(pcStr)
	ok

func NumberOfCharsOf(pcStr)
	return StzStringQ(pcStr).NumberOfChars()

	func NumberOfCharsIn(pcStr)
		return NumberOfCharsOf(pcStr)

func BothStringsAreEqualCS(pcStr1, pcStr2, pCaseSensitive)
	return StringsAreEqualCS( [ pcStr1, pcStr2 ], pCaseSensitive )

func BothStringsAreEqual(pcStr1, pcStr2)
	return BothStringsAreEqualCS(pcStr1, pcStr2, :CaseSensitive = TRUE)

func StringsAreEqualCS(pacStr, pCaseSensitive)
	if NOT ListIsListOfStrings(paStr)
		stzRaise("Incorrect param type! pacStr must b a list of strings!")
	ok

	if NOT len(paStr) > 1
		stzRaise("You must provide at least two strings pacStr!")
	ok

	# Resolving pCaseSensitive

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if isString(pCaseSensitive)
		if Q(pCaseSensitive).IsOneOfThese([
			:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

			pCaseSensitive = TRUE
			
		but Q(pCaseSensitive).IsOneOfThese([
			:CaseInSensitive, :NotCaseSensitive, :NotCS,
			:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

			pCaseSensitive = FALSE
		ok

	ok

	if NOT IsBoolean(pCaseSensitive)
		stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
	ok

	# Doing the job

	bResult = TRUE
	nLen = len(pacStr)

	if pCaseSensitive = TRUE
		
		cFirstStr = StzStringQ(pacStr[1]).Lowercased()
		
		for i = 2 to nLen
			if StzStringQ(paStrings[i]).Lowercased() != cFirstStr
				bResult = FALSE
				exit
			ok 
		next

		return bResult
	else

		cFirstStr = paStrings[1]
		
		for i = 1 to nLen
			if paStrings[i] != cFirstStr
				bResult = FALSE
				exit
			ok
		next

	ok

	return bResult

func StringsAreEqual(paStrings)
	return StringsAreEqualCS(paStrings, :CaseSensitive = TRUE)

func RemoveDiacritics(pcStr)
	return StzStringQ(pcStr).DiacriticsRemoved()

func StringCases()
	return [ :Lowercase, :Uppercase, :Capitalcase, :Titlecase, :Foldercase ]

func StringCase(pcStr)

	return StzStringQ(pcStr).StringCase()

func Interpolate(pcStr)
	return Q(pcStr).Interpolated()

	#< @FunctionMisspelledForm

	func Interpoltate(pcStr)
		return Intrepolate(pcStr)

	func Intrepolate(pcStr)
		return Interpolate(pcStr)

	#>

  /////////////////
 ///   CLASS   ///
/////////////////

class stzString from stzObject

	@oQString
	@aConstraints = []

	@cLanguage = :English	# Set explicitly using SetLanguage()
				# TODO (future): Infere the language from the string

	// Initializes the content of the softanza string object
	def init(pcStr)

		if isString(pcStr)
			@oQString = new QString2()
			@oQString.append(pcStr)

		but IsQString(pcStr)
			@oQString = pcStr

		else
			stzRaise("Can't create the stzString object! You must provide a string, a QString.")
		ok

	  #==========================#
	 #   CHECKING CONSTRAINTS   #
	#==========================#
	# TODO: Generalize this feature to other classes

	def EnforcedConstraints()
		return @@aConstraints

		def Constraints()
			return This.EnforcedConstraints()

	def VerifyConstraint(pcConstraintName)

		@str = This.Content()

		cCondition = Constraints()[ :OnStzString ][ pcConstraintName ]

		if cCondition = NULL
			stzRaise("Inexsitant contraint!")
		ok

		CompileConstraint(cCondition)

		StzStringQ(cCondition) {

			ReplaceCS("@string", @str, :CS = FALSE)
			Simplify()
			RemoveTheseBounds("{", "}")

			cCondition = Content()
		}

		cCode  = 'bResult = ""+ (' + cCondition + ')'
		eval(cCode)

		if bResult = FALSE
			stzRaise([
				:Where = "stzString.ring > VerifyCondition()",
				:What  = "Execution is cancelled by Softanza",
				:Why   = "A constraint on the string object is not verified!",
				:Todo  = "Check that constraint (" + pcName + ") and adjust your logic accordingly ;)"

			])
		ok

	def VerifyConstraints()
		bResult = TRUE

		for aPair in This.Constraints()
			cConstraintName = aPair[1]
			This.VerifyConstraint(cConstraintName) = FALSE
			
		next

	  #=======================================#
	 #     GETTING CONTENT OF THE STRING     #
	#=======================================#

	// Returns the string's content
	def Content()

		return QStringToString( @oQString )

		#< @FunctionFluentForm

		def ContentQ()
			return This

		#>
	
	def QStringObject()
		return @oQString

		def ToQStringObject()
			return This.QStringObject()

		def ToQString()
			return This.QStringObject()

	def String()
		return This.Content()

		#< @FunctionFluentForm

		def StringQ() # Same as Copy()
			return new stzString( This.String() )
	
		#>

	  #=======================================#
	 #  GETTING A COPY OF THE STRING OBJECT  #
	#=======================================#

	def Copy()
		return new stzString( This.String() )

	def ReversedCopy()
		return This.ReverseQ()

	  #==================================#
	 #  GETTING THE CASE OF THE STRING  #
	#==================================#

	def StringCase()

		if This.IsLowercase()

			return :Lowercase

		but This.IsUppercase()

			return :Uppercase

		but This.IsCapitalcase()

			return :Capitalcase

		but This.IsTitlecase()

			return :Titlecase

		but This.IsCaseFold()

			return :Casefold

		else

			return :Hybridcase
		ok

	  #---------------------------------------------#
	 #  IF THE STRING IS A CHAR, GETTING ITS CASE  #
	#---------------------------------------------#

	def CharCase()
		if This.NumberOfChars() = 1
			return This.StringCase()
		ok

	  #---------------------------------------------------------------------#
	 #  CHECKING IF THE STRING HAS THE SAME CASE AS AN OTHER GIVEN STRING  #
	#---------------------------------------------------------------------#

	def HasSameCaseAs(pcOtherStr)
		return This.CharCase() = StzStringQ(pcOtherStr).CharCase()

		def HasSameCharCaseAs(pcOtherStr)
			return This.HasSameCaseAs(pcOtherStr)

		#< @FunctionNegativeForm

		def HasDifferentCaseAs(pcOtherStr)
			return NOT This.HasSameCaseAs(pcOtherStr)

		def HasDifferentCharCase(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

		def HasNoSameCaseAs(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

			def HasNoSameCharCaseAs(pcOtherStr)
				return This.HasNoSameCaseAs(pcOtherStr)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING IS IN HYBRID CASE  #
	#--------------------------------------------#

	def IsHybridcase()
		return Q( This.StringCase() ).IsNotOneOfThese([ StringCases() ])

		def IsHybridCased()
			return This.IsHybridcase()

	  #===========================================#
	 #   APPENDING THE STRING WITH A SUBSTRING   #
	#===========================================#

	def AppendWith(pcStr)

		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		cResult = This.String() + pcStr
		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def AppendWithQ(pcStr)
			This.AppendWith(pcStr)
			return This
	
		#>

		#< @FunctionAlternative

		def Append(pcStr)
			if isList(pcStr) and Q(pcStr).IsWithOrByNamedParam()
				pcStr = pcStr[2]
			ok

			This.AppendWith(pcStr)

			def AppendQ(pcStr)
				This.Append(pcStr)
				return This
	
		#>

	def AppendedWith(pcStr)
		cResult = This.Copy().AppendWithQ(pcStr).Content()
		return cResult

		def Appended(pcStr)
			cResult = This.Copy().AppendQ(pcStr).Content()
			return cResult

	  #-------------------------------------#
	 #   APPENDING THE STRING FROM START   #
	#-------------------------------------#

	def Prepend(pcOtherStr)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithOrByNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		cResult = pcOtherStr + This.String()
		This.Update( cResult )

		#< @FunctionFluentForm

		def PrpendQ(pcOtherStr)
			This.Prepend(pcOtherStr)
			return This
	
		#>

	def Prepended(pcOtherStr)
		return This.Copy().PrependQ(pcOtherStr).Content()

	  #=================================#
	 #  ADDING A SUBSTRING --EXTENDED  #
	#=================================#

	def AddXTCS(pcNewSubStr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("Ring programin language")
		o1.Add("g", :To = "programmin")

		? o1.Content()
		#--> Ring programming language
		*/

		if isList(pcSubStr)
			oSubStr = new stzList(pcSubStr)

			# Adding after

			if oSubStr.IsOneOfTheseNamedParams([ :After, :AfterEach, :To, :ToEach  ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after nth

			but oSubStr.IsOneOfTheseNamedParams([ :AfterNth, :ToNth ])
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]
				This.ReplaceNthCS(n, pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after first

			but oSubStr.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				pcSubStr = pcSubStr[2]
				This.ReplaceFirstCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding atfer last

			but oSubStr.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				pcSubStr = pcSubStr[2]
				This.ReplaceLastCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			#==

			# Adding before

			but oSubStr.IsOneOfTheseNamedParams([ :Before, :BeforeEach ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before nth

			but oSubStr.IsBeforeNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)
		
			# Adding before first

			but oSubStr.IsBeforeFirstNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before last

			but oSubStr.IsBeforeLastNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			#==

			# Adding around

			but oSubStr.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)

				else	
					This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around nth

			but oSubStr.IsAroundNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok
		
			# Adding around first

			but oSubStr.IsAroundFirstNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around last

			but oSubStr.IsAroundLastNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			ok

		ok

		def AddXTCSQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.AddXTCS(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def AddedXTCS(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().AddXTCSQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def AddXT(pcNewSubStr, pcSubStr)
		This.AddXTCSQ(pcNewSubStr, pcSubStr, :CaseSensitive = TRUE)

		def AddXTQ(pcNewSubStr, pcSubStr)
			This.AddXT(pcNewSubStr, pcSubStr)
			return This

	def AddedXT(pcNewSubStr, pcSubStr)
		return This.Copy().AddXTQ(pcNewSubStr, pcSubStr).Content()

	  #=================================================#
	 #  EXTENDING THE STRING WITH THE GIVEN SUBSTRING  #
	#=================================================#

	def ExtendWith(pSubStr)
		if isList(pSubStr)
			This.ExtendWithMany(pSubStr)
			return
		ok

		if NOT isString(pSubStr)
			StzRaise("Incorrect param type! pSubStr must be a string.")
		ok

		This.AppendWith(pSubStr)

		#< @FunctionFluentForm

		def ExtendWithQ(pSubStr)
			This.ExtendWith(pSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithSubString(pSubStr)
			This.ExtendWith(pSubStr)

			def ExtendWithSubStringQ(pSubStr)
				This.ExtendWithSubString(pSubStr)
				return This

		#>

	def ExtendedWith(pSubStr)
		aResult = This.Copy().ExtendWithQ(pSubStr).Content()
		return aResult

		def ExtendedWithSubString(pSubStr)
			return This.ExtendedWith(pSubStr)

	  #---------------------------------------------#
	 #  EXTENDING THE STRING WITH MANY SUBSTRINGS  #
	#---------------------------------------------#

	def ExtendWithMany(pacSubStr)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		This.AppendWith( QR(pacSubStr, :stzListOfStrings).Concatenated() )

		#< @FunctionFluentForm

		def ExtendWithManyQ(pacSubStr)
			This.ExtendWithMany(pacSubStr)

		#>

		#< @FunctionAlternativeForms

		def ExtendWithTheseSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithThese(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		#>

	def ExtendedWithMany(pacSubStr)
		cResult = This.Copy().ExtendWithManyQ(pacSubStr).Content()
		return cResult

		def ExtendedWithTheseSubStrings(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

		def ExtendedWithThese(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

	  #-----------------------------------#
	 #  EXTENDING THE STRING TO N CHARS  #
	#-----------------------------------#

	def ExtendToPosition(n)

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()

		This.AppendWith( Q(" ").RepeatedNTimes( n - nLen ) )
		
		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNChars(n)
			This.ExtendToPosition(n)
			
			def ExtendToNCharsQ(n)
				This.ExtendToNChars(n)
				return This

		def Extend(n)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNChars ])
				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		cResult = This.Copy().ExtendToPositionQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNChars(n)
			return This.ExtendedToPosition(n)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToPositionWith(n, pcChar)

		if isString(pcChar) and pcChar = :CharsRepeated
			This.ExtendToPositionWithCharsRepeadted(n)
			return
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( isString(pcChar) and Q(pcChar).IsChar() )
			StzRaise("Incorrect param type! pcChar must be a char.")
		ok

		nLen = This.NumberOfChars()

		if n > nLen
			This.AppendWith( Q(pcChar).RepeatedNTimes(n - nLen) )
		ok

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToWithQ(n, pcChar)
				This.ExtendToWith(n, pcChar)
				return This

		#>


	def ExtendedToPositionWith(n, pcChar)
		cResult = This.Copy().ExtendToPositionWithQ(n, pcChar)
		return This

		def ExtendedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#< @FunctionMisspelledForm

		def ExtendtedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE STRING CHARS  #
	#--------------------------------------------------------------------------#

	def ExtendToPositionWithCharsRepeadted(n)
		This.ExtendToPositionWithCharsIn(n, This.Chars())

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsRepeadtedQ(n)
			This.ExtendToPositionWithCharsRepeadted(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToWithCharsRepeatedQ(n)
				This.ExtendToWithCharsRepeated(n)
				return This

		def ExtendToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToPositionByRepeadingCharsQ(n)
				This.ExtendToPositionByRepeadingChars(n)
				return This

		def ExtendToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToByRepeatingCharsQ(n)
				This.ExtendToByRepeatingChars(n)
				return This

		#>

		#< @FunctionMisspelledForm

		def ExtendToWithCharsRepeadted(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToWithCharsRepeadtedQ(n)
				This.ExtendToWithCharsRepeadted(n)
				return This
		#>

	def ExtendedToPositionWithCharsRepeated(n)
		cResult = This.Copy().ExtendToPositionWithCharsRepeatedQ(n).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

		def ExtendedToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

		def ExtendedToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

		#>

		#< @FunctionMisspelledForm

		def ExtendedToWithCharsRepeadted(n)
			This.ExtendToPositionWithCharsRepeated(n)

		#>

	  #-------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE GIVEN CHARS  #
	#-------------------------------------------------------------------------#

	def ExtendToPositionWithCharsIn(n, pacChars)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( isList(pacChars) and Q(pacChars).IsListOfChars() )
			StzRaise("Incorrect param type! pacChars must be a list or chars.")
		ok

		nLen = len(pacChars)
		nTemp = n - nLen

		cTemp = ""

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				cTemp += pacChars[j]
			next
		ok

		This.ExtendWith(cTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsInQ(n, pacChars)
			This.ExtendToPositionWithCharsIn(n, pacChars)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToWithCharsInQ(n, pacChars)
				This.ExtendToWithCharsIn(n, pacChars)
				return This

		#>

	def ExtendedToPositionWithCharsIn(n, pacChars)
		cResult = This.Copy().ExtendToPositionWithCharsInQ(n, pacChars).Content()
		return cResult

		def ExtendedToWithCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

	  #-----------------------------------------#
	 #  EXTENDING THE STRING - A GENERAL FORM  #
	#-----------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :With = "DE")
		o1.Show()
		#--> "ABCDE"

		EXAMPLE 2

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :ToPosition = 5 )
		o1.Show()
		#--> "ABCDE  "

		EXAMPLE 3

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeadted )
		o1.Show()
		#--> "ABCDEAB"

		EXAMPLE 4

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> "ABCDE**"

		EXAMPLE 5

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPostion = 5, :WithCharsIn = [ "D", "E" ])
		o1.Show()
		#--> "ABCDEDE"

		*/

		if isString(n) and n = :String

			# Case 1: o1.ExtendXT( :String, :With = "DE")
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if isList(pWith) and Q(pWith).IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeadted(n[2])
					# Note this is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    Q(pWith).IsOneOfThese([
				:ByRepeatingChars, :WithCharsItemsRepeated, :ByCharsRepeated ] )

				if isList(n) and Q(n).IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithCharsRepeadted(n)
				return

			# Case 5: o1.ExtendXT( :ToPostion = 5, :WithCharsIn = "DE")
			but Q(pWith).IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

/*
		if isString(n) and n = :String

			# Case 1: o1.ExtendXT( :String, :With = "DE")
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if Q(pWith).IsWithOrUsingNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeadted )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeadted(n[2])
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    ( pWith = :ByRepeatingChars or pWith = :WithCharsRepeated )

				This.ExtendToPositionWithCharsRepeadted(n)
				return

			# Case 5: o1.ExtendXT( :ToPostion = 5, :WithCharsIn = [ "D", "E" ])
			but Q(pWith).IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

		StzRaise("Unsupported syntax!")
*/
		#< @FunctionFluentForm
	
		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		cResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return cResult

	  #--------------------------------------------#
	 #  SHRINKING THE STRING TO A GIVEN POSITION  #
	#============================================#

	def ShrinkTo(n)
		if isList(n) and
		   ( Q(n).IsPositionNamedParam() or Q(n).IsNCharsNamedParam() )

			n = n[2]
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveSection( n+1, nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNCharsQ(n)
				This.ShrinkToNChars(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================#
	 #     LOWERCASING THE STRING    #
	#===============================#

	def ApplyLowercase() # Understand it as a verb, an action on main string!
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toLower(This.String()) )

		#< @FunctionFluentForm

	 	// Transforms the string to lowercase AND Returns the lowercased
		// stzString object to take other actions on it!
		def ApplyLowercaseQ() # Q for Queue -> a chain of actions
			This.ApplyLowercase()
			return This

		#>

		#< @FunctionAlternativeForm

		def Lowercase() # Understand it as a verb that "lowercases" the string
			This.ApplyLowercase()

			def LowercaseQ()
				This.Lowercase()
				return This
	
		#>

		#< @FunctionMisspelledForm

		def Lowcase()
			This.ApplyLowercase()

		def ApplyLowcase()
			This.ApplyLowercase()

		#>

	def Lowercased()
		cResult = This.Copy().LowercaseQ().Content()
		return cResult

		def Lowcased()
			return This.Lowercased()

		def ToLowercase()
			return This.Lowercased()

	  #-------------------------------------------------#
	 #     LOWERCASING THE STRING IN A GIVEN LOCALE    #
	#-------------------------------------------------#

	// Tranforms the string to LOCALE-SENSITIVE lowercase
	def ApplyLowercaseInLocale(pcLocale)
		/*
		Apply the special cases documented in unicode here:
		--> http://unicode.org/Public/UNIDATA/SpecialCasing.txt

		*/

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToLowercase(This.String()) )

		#< @FunctionFluentForm

		def ApplyLowercaseInLocaleQ(pcLocale)
			This.ApplyLowercaseInLocale(pcLocale)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def LowercaseInLocale(pLocale) # Understand it as a verb that "lowercases" the string in the givan locale
			This.ApplyLowercaseInLocale(pLocale)

			def LowercaseInLocaleQ(pLocale)
				This.LowercaseInLocale(pLocale)
				return This
	
		#>

		#< @FunctionMisspelledForm

		def ApplyLowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)

		def LowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)
			
		#>

	def LowercasedInLocale(pcLocale)
		cResult = This.Copy().LowercaseInLocaleQ(pcLocale).Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedInLocaleQ(pLocale)
			return new stzString( This.LowercasedInLocale(pLocale) )

		#>

		#< @FunctionMisspelledForm

		def LowcasedInLocale(pcLocale)
			return This.LowercasedInLocale(pcLocale)

		#>

	  #----------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE  #
	#----------------------------------------#

	def IsLowercase()
	
		if This.Lowercased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsLowercased()
			return This.IsLowercase()

		def IsLower()
			return This.IsLowercase()
		#>

		#< @FunctionNegativeForm

		def IsNotLowercase()
			return NOT This.IsLowercase()

		def IsNotLowercased()
			return This.IsNotLowercase()

		def IsNotLower()
			return This.IsNotLowercase()

		#>

		#< @FunctionMisspelledForm

		def IsLowcased()
			return This.IsLowercase()

		def IsLowcase()
			return This.IsLowercase()

		#>

	  #----------------------------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE IN A GIVEN LOCALE  #
	#----------------------------------------------------------#

	def IsLowercaseInLocale(pLocale)
		bResult = StzLocaleQ(pLocale).StringLowercased(This.String()) = This.String() # TODO: replace with DefaultLocale
		return bResult

		def IsLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#< @FunctionMisspelledForm

		def IsLowcaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

	  #-------------------------------------------------------------#
	 #  CHECHINK IF THE STRING IS THE LOWERCASE OF A GIVEN STRING  #
	#-------------------------------------------------------------#

	def IsLowercaseOf(pcStr)
		return StzStringQ(pcStr).Lowercased() = This.String()

	def IsLowercaseOfXT(pcStr, paLocale)
		/* Example
		Q("many").IsLowercaseOfXT("MANY", :InThisLocale = "fr_FR")
		*/
	
		if NOT ( isList(paLocale) and len(paLocale) = 2 )
			stzRaise("Incorrect format!")
		ok
	
		if NOT isString(paLocale[1])
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( Q(paLocale[1]).IsOneOfThese([ :InThisLocale, :InLocale ]) )
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( isString(paLocale[2]) or (isList([paLocale[2]]) and len(paLocale[2]) = 2) )
			stzRaise("Incorrect format!")
		ok
	
		if isString(paLocale[2]) and NOT StzStringQ(paLocale[2]).IsLocaleAbbreviation()
			stzRaise("Incorrect format!")
		ok
	
		if isList(paLocale[2]) and NOT StzListQ(paLocale[2]).IsLocaleList()
			stzRaise("Incorrect format!")
		ok
	
		return Q(pcStr).LowercasedInLocale(paLocale[2]) = This.String()

	  #===============================#
	 #     UPPERCASING THE STRING    #
	#===============================#

	def ApplyUppercase()
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toUpper(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseQ()
			This.ApplyUppercase()
			return This
	
		#>

		#< @FunctionAlternativeForm	// TODO: replace with @FunctionAlternativeFormForm

		def Uppercase() # Understand it as a verb that "uppercases" the string
			This.ApplyUppercase()

			def UppercaseQ()
				This.Uppercase()
				return This
	
		#>

	def Uppercased()
		return This.Copy().UppercaseQ().Content()

		def ToUppercase()
			return This.Uppercased()

	// Tranforms the string to LOCALE-SENSITIVE UPPERCase
	def ApplyUppercaseInLocale(pcLocale)

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToUpperCase(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseInLocaleQ(pcLocale)
			This.ApplyUppercaseInLocale(pcLocale)
			return This

		#>

		#< @FunctionAlternativeForm

		def UppercaseInLocale(pLocale) # Understand it as a verb that "uppercases" the string in the givan locale
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInLocaleQ(pLocale)
				This.ApplyUppercaseInLocale(pLocale)
				return This
	
		def LocaleUppercase(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def LocaleUppercaseQ(pLocale)
				This.LocaleUppercase(pLocale)
				return This
		#>

	def UppercasedInLocale(pLocale)
		return This.Copy().UppercaseInLocaleQ(pLocale).Content()

		def LocaleUppercased(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercasedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		def toLocaleUppercase(pLocale)
			return This.UppercasedInLocale(pLocale)

	def IsUppercase()

		if This.Uppercased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsUppercased()
			return This.IsUppercase()

		def IsAnUppercase()
			return This.IsUppercase()

		def IsUpper()
			return This.IsUppercase()

		#>

	def IsUppercaseOf(pcStr)
		return Q(pcStr).UppercaseQ().IsEqualTo(This.Content())

	def IsUppercaseOfInLocale(pcStr, pLocale)
		return This.UppercasedInLocale(pLocale) = pcStr

	  #================================#
	 #     CAPITALIZING THE STRING    #
	#================================#

	def ApplyCapitalcase()
		if This.IsEmpty()
			return
		ok

		# Getting the positions of the words in the string
		# TODO: delegate the work to stzText when ready

		anPos = This.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]
		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 0, 1)

		ok

		nLen = len(anPos)

		for i = 1 to nLen
			cCapChar = This.CharARQ(anPos[i]).Uppercased()
			This.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		#< @FunctionFluentForm

		def ApplyCapitalcaseQ()
			This.ApplyCapitalcase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Capitalcase() # Understand it as a verb that "capitalcases" the string
			This.ApplyCapitalcase()

			def CapitalcaseQ()
				This.Capitalcase()
				return This

		def Capitalise()
			This.ApplyCapitalcase()

			def CapitaliseQ()
				This.Capitalise()
				return This

		def Capitalize()
			This.ApplyCapitalcase()

			def CapitalizeQ()
				This.Capitalize()
				return This

		#>	
	
	def CapitalCased()
		return This.Copy().ApplyCapitalCaseQ().Content()

		def CapitalCaseApplied()
			return This.CapitalCased()

		def Capitalised()
			return This.CapitalCased()

		def Capitalized()
			return This.CapitalCased()

		def ToCapitalCase()
			return This.CapitalCased()

	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyCapitalCaseInLocale(pLocale)
		# Lowercasing all the string first

		oStr = This.Copy().LowercaseQ()

		# Getting the positions of the words in the string
		# TODO: delegate the work to stzText when ready

		anPos = oStr.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]

		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)
			anPos = ring_sort(anPos)
		ok

		nLen = len(anPos)

		for i = 1 to nLen
			
			cCapChar = oStr.CharAtPositionQR(anPos[i], :stzString).
						UppercasedInLocale(pLocale)

			oStr.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		This.Update( oStr.Content() )

		#< @FunctionFluentForm

		def ApplyCapitalcaseInLocaleQ(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def CapitalcaseInLocale(pLocale) # Understand it as a verb that "capitalcases" the string in the givan locale
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInLocaleQ(pLocale)
				This.CapitalcaseInLocale(pLocale)
				return This

		def CapitaliseInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInLocaleQ(pLocale)
				This.CapitaliseInLocale(pLocale)
				return This

		def CapitalizeInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInLocaleQ(pLocale)
				This.CapitalizeInLocale(pLocale)
				return This
		
		#>
		
	def CapitalCasedInLocale(pLocale)
		return This.Copy().CapitalCaseInLocaleQ(pLocale).Content()

		#< @FunctionFluentForm

		def CapitalcasedInLocaleQ()
			return new stzString( This.CapitalCasedInLocale() )

		#>

		#< @FunctionAlternativeForms

		def CapitalisedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def CapitalizedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		#>

	def IsCapitalcase()
		return This.CapitalCased() = This.String()
		
		#< @FunctionAlternativeForms

		def IsCapitalCased()
			return This.IsCapitalcase()

		def IsCapitalised()
			return This.IsCapitalcase()

		def IsCapitalized()
			return This.IsCapitalcase()

		#>

	def IsCapitalcaseOf(pcStr)
		return This.Capitalcased() = pcStr

	def IsCapitalcaseOfInLocale(pcStr, pLocale)
		return This.CapitalcasedInLocale(pLocale) = pcStr

	  #=============================#
	 #   TITLECASING THE STRING    #
	#=============================#

	def ApplyTitlecase()
		oLocale = new stzLocale( "C" )
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseQ()
			This.ApplyTitlecase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Titlecase() # Understand it as a verb that "titlecases" the string
			This.ApplyTitleCase()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def Titelise()
			This.ApplyTitleCase()

			def TiteliseQ()
				This.Titelise()
				return This

		def Titelize()
			This.ApplyTitleCase()

			def TitelizeQ()
				This.Titelize()
				return This
		#>	

	def TitleCased()
		return This.Copy().ApplyTitleCaseQ().Content()

		def Titelised()
			return This.TitleCased()
	
		def Titelized()
			return This.TitleCased()
	
	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyTitlecaseInLocale(pLocale)
		oLocale = new stzLocale(pLocale)
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseInLocaleQ(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def TitlecaseInLocale(pLocale) # Understand it as a verb that "titlecases" the string in the givan locale
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInLocaleQ(pLocale)
				This.TitlecaseInLocale(pLocale)
				return This
		
		def TiteliseInLocale(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInLocaleQ(pLocale)
				This.TiteliseInLocale(pLocale)
				return This

		def TitelizeInLocale(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInLocaleQ(pLocale)
				This.TitelizeInLocale(pLocale)
				return This
		#>
			
	def TitlecasedInLocale(pLocale)
		return This.Copy().TitleCaseInLocaleQ(pLocale).Content()

		def TitelisedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

	def IsTitlecase()
		
		return This.TitleCased() = This.String()

		#< @FunctionAlternativeForms

		def IsTitlecased()
			return This.IsTitlecase()

		def IsTitelised()
			return This.IsTitlecase()

		def IsTitelized()
			return This.IsTitlecase()

		#>

	def IsTitlecaseOf(pcStr)
		return This.Titlecased() = pcStr

	  #================================#
	 #    CASEFOLDING THE STRING      #
	#================================#

	/*
	INFO
	----

	The casefold() method is an aggressive lower() method which
	converts strings to case folded strings for caseless matching.
	
	WARNING:
	--------

	Review the Qt behaviour regarding QString.toCaseFolded() method.

	In fact, when writing:

	? StzStringQ("der Fluß").CaseFolded()

	We should have as result:

	"der fluss"

	since "ß" is casefolded to "ss" in german.

	But, Qt don't do that!
	
	*/

	// Transforms the string to casefolded style
	def CaseFold() # Understand it as a verb that "casefolds" the string
		This.Update( This.CaseFolded() )

		#< @FunctionFluentForm

		def CaseFoldQ()
			This.CaseFold()
			return This
	
		#>

	def CaseFolded()
		return @oQString.toCasefolded()

	def IsCaseFolded()
		If This.IsEmpty()
			return FALSE
		ok

		if This.Copy().CaseFolded() = This.Content()
			return TRUE
		else
			return FALSE
		ok

		return bResult

		#< @FunctionAlternativeForm

		def IsCaseFold()
			return This.IsCaseFolded()

		#>

	def IsCaseFoldedOf(pcStr)
		return This.CaseFolded() = pcStr

	  #================================#
	 #   CHECKING IF STRING IS WORD   #
	#================================#
	# TODO: should move to stzText

	def IsWord()

		if This.IsEmpty() or This.IsNumberInString()
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsNotLetter() and
			   oChar.IsNotNumber() and
			   c != HyphenShort() and
			   c != HyphenLong() and
			   c != Underscore() and
			   oChar.IsNotArabic7arakah() and
			   c != ArabicTamdeed()

				bResult = FALSE
				exit
			ok

		next

		return bResult

	def IsArabicWord()
		bResult = This.ToStzText().IsArabicWord()
		return bResult

	def IsLatinWord()
		bResult = This.ToStzText().IsLatinWord()
		return bResult

	  #-------------------------------------#
	 #   CHECKING IF STRING IS STOPWORD    #
	#-------------------------------------#
	# TODO: Should move to stzText

	def IsStopWord()
		return StopWordsQ().Contains(This.Lowercased())

	def IsStopWordIn(pcLang)
		bResult = This.ToStzText().IsStopWordIn(pcLang)
		return bResult

	def LanguageIfStopWord()
		cResult = This.ToStzText().LanguageIfStopWord()
		return cResult

	  #===================================================#
	 #  NUMBER OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#===================================================#

	def NumberOfSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return 0
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = 0

		if pCaseSensitive = TRUE
			n = This.NumberOfChars()
			nResult = n * (n + 1) / 2
	
		else
			# TODO (Future): Think of a numeric solution
			acSubStringsCS = This.SubStringsCS(FALSE)
			nResult = len(acSubStringsCS)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def HowManySubstringsCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		def HowManySubstringCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStrings()
		return This.NumberOfSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HowManySubstrings()
			return This.NumberOfSubStrings()

		def HowManySubstring()
			return This.NumberOfSubStrings()

		#>
	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------------------------#

	def SubStringsCS(pCaseSensitive)
		# NOTE: Got help from Google Bard for the basic algorithm used here

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()
		# TODO: Chexk wether ..CS() extension is needed here!

		for i = 1 to nLen
			for j = i to nLen
				cSubStr = This.Section(i, j)
				if pCaseSensitive = TRUE
					acResult + cSubStr

				else
					# TODO: Optimise it for better performance
					if NOT Q(acResult).ContainsCS(cSubStr, FALSE)
						acResult + cSubStr
					ok
				ok
			next
		next
		
		 return acResult


		#< @FunctionFluentForm

		def SubStringsCSQ(pCaseSensitive)
			return This.SubStringsCSQR(pCaseSensitive, :stzList)

		def SubStringsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @AlternativeFuntionForm

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStrings()
		return This.SubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubStringsQ()
			return This.SubStringsQR(:stzList)

		def SubStringsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStrings() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------#
	 #  LIST OF UNIQUE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------#

	def UniqueSubStringsCS(pCaseSensitive)
		acResult = This.SubStringsCSQR(pCaseSensitive, :stzListOfStrings).
				DuplicatesRemoved()

		return acResult

		def SubStringsUCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

		def SubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStrings()
		return This.UniqueSubStringsCS(:CaseSensitive = TRUE)

		def SubStringsU()
			return This.UniqueSubStrings()

		def SubStringsWithoutDuplication()
			return This.UniqueSubStrings()

	  #---------------------------------------------#
	 #  NUMBER OF UNIQUE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------#

	def NumberOfUniqueSubStringsCS(pCaseSensitive)
		return len( This.UniqueSubStringsCS(pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfSubStringsUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringsCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#--

		def NumberOfSubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStrings()
		return This.NumberOfUniqueSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfSubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstrings()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstring()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringU()
			return This.NumberOfUniqueSubStrings()

		#--

		def NumberOfSubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		#>

	  #----------------------------------------------------------#
	 #  POSITIONS OF ALL THE POSSIBLE SUBSTRINGS IN THE STRING  #
	#----------------------------------------------------------#

	def FindSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		nLen = len(acSubStrings)
		anResult = []

		for i = 1 to nLen
			anResult + This.FindSubStringCS( acSubStrings[i], pCaseSensitive )
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStrings(pCaseSensitive)
		return This.FindSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStrings()
			return This.FindSubStrings()

		def FindAllPossibleSubStrings()
			return This.FindSubStrings()

		def PositionsOfSubStrings()
			return This.FindSubStrings()

		def PositionsOfAllSubStrings()
			return This.FindSubStrings()

		def PositionsOfAllPossibleSubStrings()
			return This.FindSubStrings()

		#>

	  #-----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def SubStringsZCS(pCaseSensitive)
	
		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		aResult = []

		for i = 1 to len(acSubStrings)
			cSubStr = acSubStrings[i]
			anPos = This.FindAllCS(cSubStr, pCaseSensitive)
			aResult + [ cSubStr, anPos ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.SubStringsZCS(pCaseSensitive)

		def AllSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.SubStringsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsZ()
		return This.SubStringsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsAndTheirPositions()
			return This.SubStringsZ()

		def AllSubStringsAndTheirPositions()
			return This.SubStringsZ()

		#>

	  #----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR SECTIONS  #
	#----------------------------------------------#

	def SubStringsZZCS(pCaseSensitive)
		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		aResult = []

		for i = 1 to len(acSubStrings)
			cSubStr = acSubStrings[i]
			aSection = This.FindAsSectionsCS(cSubStr, pCaseSensitive)
			aResult + [ cSubStr, aSection ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.SubStringsZZCS(pCaseSensitive)

		def AllSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.SubStringsZZCS(pCaseSensitive)

		def SubStringsCSZZ(pCaseSensitive)
			return This.SubStringsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsZZ()
		return This.SubStringsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsAndTheirSections()
			return This.SubStringsZZ()

		def AllSubStringsAndTheirSections()
			return This.SubStringsZZ()

		#>

	  #------------------------------------------#
	 #  SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------#

	def NumberOfSubStringsW(pcCondition)
		return len( This.SubStringsW(pcCondition) )

	def SubStringsW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		acSubStr = This.SubStringsU() # Or UniqueSubStrings()

		nLen = len(acSubStr)

		cCode = 'if (' + StzCCodeQ(pcCondition).Transpiled() + ') { bOk = TRUE }'

		aResult = []
		
		for i = 1 to nLen
			@substring = acSubStr[i]
			bOk = FALSE
			eval(cCode)

			if bOk
				aResult + @substring
			ok
		next

		return aResult

	  #------------------------------------------------------#
	 #  GETTING THE LIST OF ALL SUBSTRINGS MADE OF N CHARS  #
	#------------------------------------------------------#

	def SubStringsOfNCharsCS(n, pCaseSensitive)
		acResult = This.SubStringsW(' Q(@SubStr).NumberOfCharsCS(pCaseSensitive) = n ')
		return acResult

		def SubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.SubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOfNChars(n)
		return This.SubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def SubStringsMadeOfNChars(n)
			return This.SubStringsOfNChars(n)

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-------------------------------------------------------------#

	def UniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		acSubStrings = This.SubStringsOfNCharsCS(n, pCaseSensitive)
		acResult = Q(acSubStrings).DuplicatesRemovedCS(pCaseSensitive)
		return acResult

		def UniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsWithoutDuplicationMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESITIVITY

	def UniqueSubStringsOfNChars(n)
		return This.UniqueSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def UniqueSubStringsMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsWithoutDuplicationMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS MADE OF N CHARS  #
	#----------------------------------------------------#

	def NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.SubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsOfNChars(n)
		return This.NumberOfSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def NumberOfSubStringsMadeOfNChars(n)
			return This.NumberOfSubStringsOfNChars(n)

	  #-----------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-----------------------------------------------------------#

	def NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfUniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManyUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsOfNChars(n)
		return This.NumberOfUniqueSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def NumberOfUniqueSubStringsMadeOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		def HowManyUniqueSubStringsOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

	  #=================================================#
	 #  SUBSTRING USED IN NEAR-NATURAL LANGUAGE STYLE  #
	#=================================================#

	def SubStringCS(pcSubStr, paOption, pCaseSensitive)
		/*
		o1 = new stzString("blabla .♥. blabla")
		? o1.SubString("♥", :IsBoundedBy = ".")
		#--> TRUE
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT isList(paOption)
			StzRaise("Incorrect param type! paOption must be a list.")
		ok

		if Q(paOption).IsIsBoundedByNamedParam() # Yes! IsIs... and not only Is :)
			pBounds = paOption[2]

			return This.SubStringIsBoundedByCS(pcSubStr, pBounds, pCaseSensitive)

		# TODO: support other cases

		ok

	#-- WITHOUT CASESENSITIVITY

	def SubString(pcSubStr, paOption)
		return This.SubStringCS(pcSubStr, paOption, :CaseSensitive = TRUE)
		

	  #=================#
	 #      LINES      #
	#=================#

	def Lines()
		return This.Split(NL)

		#< @FunctionFluentForm

		def LinesQ()
			return new stzListOfStrings( This.Lines() )

		def LinesQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.Lines())

			on :stzListOfStrings
				return new stzListOfStrings(This.Lines())

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
	def NumberOfLines()
		return len(This.Lines())

	  #----------------#
	 #  UNIQUE LINES  #
	#----------------#

	def UniqueLines()
		acResult = This.LinesQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForm

		def UniqueLinesQ()
			return new stzListOfStrings( This.UniqueLines() )

		def UniqueLinesQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueLines())

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueLines())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LinesU()
			return This.UniqueLines()

			def LinesUQ()
				return This.LinesQR(:stzList)

			def LinesUQR(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		def LinesWithoutDuplication()
			return This.UniqueLines()

			def LinesWithoutDuplicationQ()
				return This.LinesWithoutDuplicationQR(:stzList)

			def LinesWithoutDuplicationQR(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		#>

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#------------------------------------------#

	def RemoveLinesW(pcCondition)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(@line).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		oListOfStr = This.LinesQR(:stzListOfStrings)

		pcCondition = Q(pcCondition).
			      ReplaceCSQ("@line", "This[@i]", :CS = FALSE).
			      Content()

		cResult = oListOfStr.RemoveWQ(pcCondition).ConcatenatedUsing(NL)

		This.Update(cResult)

		def RemoveLinesWQ(pcCondition)
			This.RemoveLinesW(pcCondition)
			return This

	  #------------------------#
	 #  REMOVING EMPTY LINES  #
	#------------------------#

	def RemoveEmptyLines()
		cResult = This.LinesQR(:stzListOfStrings).
				RemoveEmptyStringsQ().
				ConcatenatedUsing(NL)

		This.Update(cResult)

		def RemoveEmptyLinesQ()
			This.RemoveEmptyLines()
			return This

	  #========================#
	 #  NORMALIZING MARQUERS  #
	#========================#
	// Removing zeros at the begining of marquer numbers

	def NormalizeMarquers()
		/* Example

		StzStringQ("The first candidate is #003, the second is #01, while the third is #2!") {	
			NormalizeMarquers()
			? Content()
		}

		#--> "The first candidate is #3, the second is #1, while the third is #2!"
		*/
		if This.Contains("#0")

			bContinue = TRUE
	
			While bContinue
	
				n = This.ReplaceLast("#0", "#")
	
				if This.ContainsNo("#0")
					bContinue = FALSE
				ok
			end
		ok

		def NormaliseMarquers()
			This.NormaliseMarquers()

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MARQUERS  #
	#============================================#

	def ContainsMarquers()
		if This.NumberOfMarquers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #----------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING  #
	#==============================================#

	def Marquers()
		anPos = This.FindAll("#")

		if len(anPos) = 0
			return []
		ok

		aResult = []

		for n in anPos
			n1 = n + 1
			n2 = This.WalkForewardW( :StartingAt = n+1, :Until = '{ NOT StzStringQ(@char).RepresentsNumberInDecimalForm() }' )

			if n1 != n2

				cMarquer = This.SectionQ(n1, n2).OnlyNumbersQ().RemoveThisRepeatedLeadingCharQ("0").Content()

				if cMarquer != ""
					if cMarquer[1] = "0"
						cMarquer = StzStringQ(cMarquer).Section(2, :LastChar)
					ok
				
					aResult + ("#" + cMarquer)
				ok
			ok
			
		next

		return aResult

		def MarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.Marquers())

			on :stzList
				return new stzList(This.Marquers())

			other
				stzRaise("Unsupported return type!")
			off

	  #---------------------------------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING -- WITHOUT DUPLICATION  #
	#=====================================================================#

	def UniqueMarquers()
		return StzListQ(This.Marquers()).UniqueItems()

		#< @FunctionFluentForms

		def UniqueMarquersQ()
			return This.UniqueMarquersQR(:stzList)

		def UniqueMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueMarquers())

			on :stzList
				return new stzList(This.UniqueMarquers())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SetOfMarquers()
			return This.UniqueMarquers()

			def SetOfMarquersQ()
				return This.UniqueMarquersQ()

			def SetOfMarquersQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersU()
			return This.UniqueMarquers()

			def MarquersUQ()
				return This.UniqueMarquersQ()

			def MarquersUQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersWithoutDuplication()
			return This.UniqueMarquers()

			def MarquersWithoutDuplicationQ()
				return This.UniqueMarquersQ()

			def MarquersWithoutDuplicationQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #  GETTING THE NUMBER OF MARQUERS IN THE STRING  #
	#================================================#

	def NumberOfMarquers()
		return len(This.Marquers())

		def CountMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquer()
			return This.NumberOfMarquers()

	  #-------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS IN EACH MARQUER IN THE STRING  #
	#=============================================================#

	def NumberOfCharsInEachMarquer()
		aResult = []
		for cMarquer in This.Marquers()
			aResult + len(cMarquer)
		next

		return aResult

		#< @FunctionAlternativeForms

		def SizeOfEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def MarquersNumbersOfChars()
			return This.NumberOfCharsInEachMarquer()

		def CountCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		#>

	  #-------------------------------#
	 #   MFINDING ARQUERS POSITIONS  #
	#===============================#

	def MarquersPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersPositions()
			#--> [ 12, 25, 44, 66 ]
		
		}
		*/

		acMarquers = This.Marquers()
		aResult = []

		n = 1

		for cMarquer in acMarquers
			n = This.FindNextOccurrence( cMarquer, n )
			/* WARNING: Don't use:
			n = This.FindNextMarquer(cMarquer)
			--> Circular call --> Stackoverflow
			*/
			aResult + n
		next

		return aResult

		#< @FunctionFluentForm

		def MarquersPositionsQ()
			return This.MarquersPositionsQR(:stzListOfNumbers)

		def MarquersPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfNumbers
				return new stzListOfNumbers(This.MarquersPositions())

			on :stzList
				return new stzList(This.MarquersPositions())

			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def MarquersOccurrences()
			return This.MarquersPositions()

			def MarquersOccurrencesQ()
				return This.MarquersOccurrencesQR(:stzListOfNumbers)
	
			def MarquersOccurrencesQR(pcReturnType)
				return This.MarquersPositionsQR(pcReturnType)

		def FindMarquers()
			return This.MarquersPositions()

			def FindMarquersQ()
				return This.FindMarquersQR(:stzListOfNumbers)
	
			def FindMarquersQR(pcReturnType)
				return This.MarquersPositionsQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#================================================#

	def MarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersAndPositions() " Use MarquersZ() instead
			#--> [ "#1" = 12, "#2" = 25 , "#3" = 44, "#1" = 66 ]
		
		}
		*/

		aResult = StzPairOfListsQ( This.Marquers(), This.MarquersPositions() ).AssociateQ().Content()
		return aResult

		#< @FunctionFluentForm

		def MarquersAndPositionsQ()
			return This.MarquersAndPositionsQR(:stzList)

		def MarquersAndPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndPositions() )

			on :stzHashList
				return new stzHashList( This.MarquersAndPositions() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def MarquersAndTheirPositions()
			return This.MarquersAndPositions()

			def MarquersAndTheirPositionsQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndTheirPositionsQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersAndOccurrences()
			return This.MarquersAndPositions()

			def MarquersAndOccurrencesQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndOccurrencesQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersAndTheirOccurrences()
			return This.MarquersAndPositions()

			def MarquersAndTheirOccurrencesQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndTheirOccurrencesQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersZ()
			return This.MarquersAndPositions()

			def MarquersZQ()
				return This.MarquersAndPositionsQR(:stzList)

			def MarquersZQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturntype)

		#>

	  #-------------------------------------------------------#
	 #   UNIQUE MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#=======================================================#

	def UniqueMarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? UniqueMarquersAndPositions() # Use MarquersUZ() instead
			#--> [ "#1" = [12, 66], "#2" = [26], "#3" = [44] ]
		
		}
		*/
		acMarquers = This.UniqueMarquers()
		nLen = len(acMarquers)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindAll(acMarquers[i])
			aResult + [ cMarquer, anPos ]
		next

		return aResult
		
		#< @FunctionFluentForm

		def UniqueMarquersAndPositionsQ()
			return This.UniqueMarquersAndPositionsQR(:stzList)

		def UniqueMarquersAndPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueMarquersAndPositions() )

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndPositions() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def UniqueMarquersAndTheirPositions()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndTheirPositionsQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndTheirPositionsQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersAndOccurrences()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndOccurrencesQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndOccurrencesQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersAndTheirOccurrences()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndTheirOccurrencesQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndTheirOccurrencesQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersZ()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersZQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def UniqueMarquersZQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersZU()
			return This.UniqueMarquersAndPositions()

			def MarquersZUQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def MarquersZUQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersUZ()
			return This.UniqueMarquersAndPositions()

			def MarquersUZQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def MarquersUZQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersWithoutDuplicationZ()
			return This.UniqueMarquersAndPositions()

			def MarquersWithoutDuplicationZQ()
				return This.MarquersWithoutDuplicationQR(:stzList)

			def MarquersWithoutDuplicationZQR(pcReturnType)
				return This.MarquersUZQR(pcReturnType)

		#>

	  #----------------------------#
	 #      FINDING A MARQUER     #
	#============================#

	def OccurrencesOfMarquer(pcMarquer)
		
		aResult = This.MarquersAndTheirPositions()[pcMarquer]
		if isString(aResult) and aResult = NULL
			return []
		else
			return aResult
		ok

		#< @FunctionFluentForm

		def OccurrencesOfMarquerQ(pcMarquer)
			return This.OccurrencesOfMarquerQR(pcMarquer, :stzList)

		def OccurrencesOfMarquerQR(pcMarquer, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.OccurrencesOfMarquer(pcMArquer) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.OccurrencesOfMarquer(pcMArquer) )

			other
				stzRaise("Unsupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def PositionsOfMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def MarquerPositions(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def MarquerPositionsQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def MarquerPositionsQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def FindMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)


			#>

	  #-------------------------------------#
	 #    GETTING A MARQUER BY POSITION    #
	#=====================================#

	def MarquerByPosition(pnPosition)
		aMarquers = This.MarquersAndTheirPositions()
		nLen = len(aMarquers)

		cResult = ""

		for i = 1 to nLen
			n = ring_find(aMarquers[2], pnPosition)
			if n > 0
				cResult = aMarquers[1]
				exit
			ok
		next

		return cResult

		def MarquerByPositionQ(pnPosition)
			return new stzString( This.MarquerByPosition() )

		def MarquerByOccurrence(pnPosition)
			return This.MarquerByPosition(pnPosition)

			def MarquerByOccurrenceQ(pnPosition)
				return new stzString( This.MarquerByOccurrence(pnPosition) )

	  #----------------------------------#
	 #   FINDING MARQUERS AS SECTIONS   #
	#==================================#

	def MarquersSections()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersPositions()
			#--> [  [12, 13], [ 25, 26],  [44, 45], [66, 67]  ]
		
		}
		*/

		anStartPos  = This.MarquersPositions()
		anNbOfChars = This.MarquersNumbersOfChars()

		aResult = []

		for i = 1 to len(anStartPos)
			aResult + [ anStartPos[i], anStartPos[i] + anNbOfChars[i] - 1 ]
		next

		return aResult


		#< @FunctionFluentForm

		def MarquersSectionsQ()
			return new stzList( This.MarquersSections() )

		def MarquersSectionsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersSections() )

			on :stzListOfLists
				return new stzListOfLists( This.MarquersSections() )

			on :stzListOfPairs
				return new stzListOfPairs( This.MarquersSections() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm >

		def FindMarquersAsSections()
			return This.MarquersSections()

			def FindMarquersAsSectionsQ()
				return This.MarquersSectionsQ()

			def FindMarquersAsSectionsQR(pcReturnType)
				return This.MarquersSectionsQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR SECTIONS -- ZZ/Extended   #
	#================================================#

	def MarquersAndSections()

		aResult = Association([ This.Marquers(), This.MarquersSections() ])
		return aResult

		#< @FunctionFluentForm

		def MarquersAndSectionsQ()
			return This.MarquersAndSectionsQR(:stzList)

		def MarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndSections() )

			on :stzHashList
				return new stzHashList( This.MarquersAndSections() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZ()
			return This.MarquersAndSections()

			def MarquersZZQ()
				return This.MarquersAndSectionsQ()

			def MarquersZZQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		def MarquersAndTheirSections()
			return This.MarquersAndSections()

			def MarquersAndTheirSectionsQ()
				return This.MarquersAndSectionsQ()

			def MarquersAndTheirSectionsQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		#>

	  #-------------------------------------------------------#
	 #  UNIQUE MARQUERS AND THEIR SECTIONS -- ZZU/Extended   #
	#=======================================================#

	def UniqueMarquersAndSections()

		aMarquers = This.MarquersAndTheirPositions()
		nLen = len(aMarquers)

		aResult = []

		for i = 1 to nLen
			cMarquer = aMarquers[i][1]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			anMarquerPositions = aMarquers[i][2]
			nNumberOfPos = len(anMarquerPositions)

			aMarquerSections = []

			for j = 1 to nNumberOfPos
				nPos = anMarquerPositions[j]
				aMarquerSections + [ nPos, nPos + nLenMarquer - 1 ]
			next

			aResult + [ cMarquer, aMarquerSections ]
		next
		
		return aResult

		#< @FunctionFluentForm

		def UniqueMarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndSections() )

			on :stzList
				return new stzList( This.UniqueMarquersAndSections() )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZU()
			return This.UniqueMarquersAndSections()

			def MarquersZZUQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersZZUQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUZZ()
			return This.UniqueMarquersAndSections()

			def MarquersUZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def UniqueMarquersAndTheirSections()
			return This.UniqueMarquersAndSections()

			def UniqueMarquersAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def UniqueMarquersandTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersUAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationZZ()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		#>
	
	  #-----------------------------------------#
	 #    SORTING MARQUERS INSIDE THE STRING   #
	#=========================================#

	def MarquersAreSorted()
		bResult = StzListQ(This.Marquers()).ItemsAreSorted()
		return bResult

	def MarquersSortingOrder()
		bResult = StzListQ(This.Marquers()).SortingOrder()
		return bResult

	def MarquersAreUnsorted()
		bResult = StzListQ(This.Marquers()).ItemsAreUnsorted()
		return bResult

		def MarquersAreNotSorted()
			return This.MarquersAreUnsorted()

	def MarquersAreSortedInAscending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInAscending()
		return bResult

	def MarquersAreSortedInDescending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInDescending()
		return bResult

	def MarquersSortedInAscending()
		aResult = StzListQ(This.Marquers()).SortedInAscending()
		return aResult

	def MarquersSortedInDescending()
		aResult = StzListQ(This.Marquers()).SortedInDescending()
		return aResult

	def MarquersPositionsSortedInAscending()
		aResult = StzListQ(This.MarquersPositions()).SortedInAscending()
		return aResult

	def MarquersPositionsSortedInDescending()
		aResult = StzListQ(This.MarquersPositions()).SortedInDescending()
		return aResult

	def MarquersAndPositionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = StzPairOfListsQ( acMarquers, anPositions).Associate()

		return aResult

		def MarquersSortedInAscendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedOInDescending()
			return This.MarquersAndPositionsSortedInAscending()

	def MarquersAndPositionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		anPositions = This.MarquersPositionsSortedInDescending()

		aResult = StzPairOfListsQ( acMarquers, anPositions ).Associate()

		return aResult

		def MarquersSortedInDescendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedInDescending()
			return This.MarquersAndPositionsSortedInDescending()

	def MarquersAndSectionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		nLen = len(acMarquers)

		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLen
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPositions[i]
			n2 = n1 + nLenMarquer - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		def MarquersSortedInAscendingAndTheirSections()
			return This.MarquersAndSectionsSortedInAscending()

	def MarquersAndSectionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		nLenMarquers = len(acMarquers)

		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLenMarquers
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPositions[i]
			n2 = n1 + nLenMarquers - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		def MarquersSortedInDescendingAndTheirSections()
			return This.MarquersAndSectionsSortedInDescending()

	def SortMarquersInAscending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInAscending()
			? Content()
		}

		# !--> My name is #1, may age is #2, and my job is #3.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		/* Reminder
		#--> [ "#1" = [12, 13], "#1" = [26, 27], "#2" = [44, 45], "#3" = [66, 67] ]
		*/

		for i = len(aMarquersSections) to 1 step -1
			cMarquer = aMarquersSections[i][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInAscendingQ()
			This.SortMarquersInAscending()
			return This

	def StringWithMaquersSortedInAscending()
		cResult = This.Copy().SortMarquersInAscendingQ().Content()
		return cResult

	def SortMarquersInDescending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInDescending()
			? Content()
		}

		# !--> My name is #3, may age is #2, and my job is #1.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersSections)

		/* Reminder
		Q("My name is #2, may age is #1, and my job is #3.") {
			? MarquersAndSections()
		}

		#--> [ "#1" = [12, 13], "#2" = [27, 28], "#3" = [45, 46]  ]
		*/

		for i = nLen to 1 step - 1
			cMarquer = aMarquersSections[nLen - i + 1][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInDescendingQ()
			This.SortMarquersInDescending()
			return This

	def StringWithMaquersSortedInDescending()
		cResult = This.Copy().SortMarquersInDescendingQ().Content()
		return cResult

	  #--------------------------------------------#
	 #  REPLACING MARQUERS WITH GIVEN SUBSTRINGS  #
	#============================================#

	def ReplaceMarquers(pacSubStrings)
		if isList(pacSubStrings) and Q(pacSubStrings).IsWithOrByNamedParam()
			pacSubStrings = pacSubStrings[2]
		ok

		aMarquersXT = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersXT)

		nMin = Min([ len(pacSubStrings), nLen ])

		for i = nLen to 1 step -1
			
			cMarquer = aMarquersXT[i][1]

			This.ReplaceAll(cMarquer, pacSubStrings[i])
		next

		def ReplaceMarquersQ(pacSubStrings)
			This.ReplaceMarquers(pacSubStrings)
			return This

	def MarquersReplaced(pacSubStrings)
		return This.Copy().ReplaceMarquersQ(pacSubStrings).Content()

		#< @FunctionMisspelledForm

		def MarquersRepalced(pacSubStrings)
			return This.MarquersReplaced(pacSubStrings)

		#>

	  #------------------------------------------#
	 #    REPLACING SUBSTRINGS WITH MARQUERS    # TODO: Test it!
	#==========================================#

	def ReplaceSubstringsWithMarquersCS(pacSubstrings, pCaseSensitive)

		acSubStrings = StzListOfStringsQ(pacSubstrings).DuplicatesRemovedCS(pCaseSensitive)

		acMarquers = []

		for i = 1 to len(acSubStrings)
			acMarquers + ( "#" + i )
		next

		This.ReplaceManyByManyCS( acSubStrings, acMarquers, pCaseSensitive )

		def ReplaceSubstringsWithMarquersCSQ(pacSubstrings, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubstrings, pCaseSensitive)
			return This

	def SubstringsReplacedWithMarquersCS(pacSubstrings, pCaseSensitive)
		cResult = This.Copy().ReplaceSubstringsWithMarquersCSQ(pacSubstrings, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubstringsWithMarquers(pacSubstrings)
		This.ReplaceSubstringsWithMarquersCS(pacSubstrings, :CaseSensitive = TRUE)

	def SubstringsReplacedWithMarquers(pacSubstrings)
		return This.SubstringsReplacedWithMarquersCS(pacSubstrings, :CaseSensitive = TRUE)

	  #------------------------#
	 #    PARSING MARQUERS    #
	#========================#

	def NthMarquer(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		try
			return This.Marquers()[n]
		catch
			return NULL
		done

		def NthMarquerQ(n)
			return new stzString( This.NthMarquer(n) )

	def FirstMarquer()
		return This.NthMarquer(1)

		def FirstMarquerQ()
			return new stzString( This.LastMarquer() )

	def LastMarquer()
		n = This.NumberOfMarquers()
		acResult = This.Marquers()[ n ]
		return acResult

		def LastMarquerQ()
			return new stzString( This.LastMarquer() )

	  #------------------------------#
	 #    FINDING THE NTH MARQUER   #
	#==============================#

	def FindNthMarquer(n)
		if isString(n)
			if n = :First or n = :FirstMarquer
				n = 1
			but n = :Last or n = :LastMarquer
				n = This.NumberOfMarquers()
			ok
		ok

		return This.FindNthOccurrence( n, "#" )

		def NthMarquerOccurrence(n)
			return This.FindNthMarquer(n)

		def NthMarquerPosition(n)
			return This.FindNthMarquer(n)

		def PositionOfNthMarquer(n)
			return This.FindNthMarquer(n)

	def FindFirstMarquer()
		return This.FindNthMarquer(1)

		def FirstMarquerOccurrence()
			return This.FindFirstMarquer()

		def FirstMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFirstMarquer()
			return This.FindFirstMarquer()

	def FindLastMarquer()
			return This.FindNthMarquer(:Last)

		def LastMarquerOccurrence()
			return This.FindLastMarquer()

		def LastMarquerPosition()
			return This.FindLastMarquer()

		def PositionOfLastMarquer()
			return This.FindLastMarquer()


	  #--------------------------------------------------#
	 #    NEXT MARQUERS STARTING AT A GIVEN POSITION    #
	#==================================================#

	def NextMarquers(pnStartingAt)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		return This.SectionQ(pnStartingAt, :LastChar).Marquers()

		def NextMarquersQ(pnStartingAt)
			return This.NextMarquersQR(pnstartingAt, :stzList)

		def NextMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NextMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.NextMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

	  #--------------------------------------#
	 #    RETURNING THE NTH NEXT MARQUER    #
	#======================================#

	def NthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> #3
		*/

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(pnStartingAt, :LastChar)
		return oStr.Marquers()[ n ]


		def NthNextMarquerQ(n, pnStartingAt)
			return new stzString( This.NthNextMarquer(n, pnStartingAt) )

		def NextNthMarquer(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerQ(n, pnStartingAt)
				return new stzString( This.NextNthMarquer(n, pnStartingAt) )

	  #------------------------------------#
	 #    FINDING THE NTH NEXT MARQUER    #
	#====================================#

	def FindNthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> 44
		*/

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(pnStartingAt, :LastChar)

		nPos = oStr.MarquersPositions()[ n ] + pnStartingAt - 1
		
		return nPos

		def FindNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

	  #-------------------------------------------------#
	 #    NTH NEXT MARQUER, ALONG WITH ITS POSITION    #
	#=================================================#

	def NthNextMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthNextMarquer(n, pnStartingAt)
		nPosition = This.FindNthNextMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthNextMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthNextMarquerAndItsPositionQR(n, pnStartingAt, pnStartingAt, :stzList)

		def NthNextMarquerAndItsPositionQR(n, pnStartingAt, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQ(n, pnStartingAt)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

		def NextNthMarquerDZ(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    FINDING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def FindNextMarquer(pnStartingAt)
		return This.FindNthNextMarquer(1, pnStartingAt)

		def NextMarquerPosition(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquer(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrence(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def FindNextMarquerD(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

	  #---------------------------------------------------------#
	 #    GETTING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def NextMarquer(pnStartingAt)
		return This.NthNextMarquer(1, pnStartingAt)

		def NextMarquerQ(pnStartingAt)
			return new stzString( This.NextMarquer(pnStartingAt) )

		def NextMarquerD(pnStartingAt)
			return This.NextMarquer(pnStartingAt)

	  #--------------------------------------------------------------------------#
	 #    GETTING NEXT MARQUER AND ITS POSITION STARTING AT A GIVEN POSITION    #
	#==========================================================================#

	def NextMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.NextMarquer(pnStartingAt)
		nPosition = This.NextMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		def NextMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.NextMarquerAndItsPosition(pnStartingAt) )

		def NextMarquerAndItsOccurrence(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

			def NextMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.NextMarquerAndItsOccurrence(pnStartingAt) )

		def NextMarquerDZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		def NextMarquerZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

	  #---------------------------------#
	 #    GETTING PREVIOUS MARQUERS    #
	#=================================#

	def PreviousMarquers(pnStartingAt)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0 )
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		return This.SectionQ(1, pnStartingAt).Marquers()

		#< @FunctionFluentForms

		def PreviousMarquersQ(pnStartingAt)
			return This.PreviousMarquersQR(pnstartingAt, :stzList)

		def PreviousMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquersD(pnStartingAt)
			return This.PreviousMarquers(pnStartingAt)

			def PreviousMarquersDQ()
				return This.PreviousMarquersQ()

			def PreviousMarquersDQR(pnStartingAt, pcReturnType)
				return This.PreviousMarquersQR(pnstartingAt, pcReturnType)

		#>

	  #------------------------------------#
	 #    GETTING NTH PREVIOUS MARQUER    #
	#====================================#

	def NthPreviousMarquer(n, pnStartingAt)
		nPos = This.FindNthPreviousMarquer(n, pnStartingAt)

		return This.MarquerByPosition(nPos)
		
		def NthPreviousMarquerQ(n, pnStartingAt)
			return new stzString( This.NthPreviousMarquer(n, pnStartingAt) )

		def PreviousNthMarquer(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

			def PreviousNthMarquerQ(n, pnStartingAt)
				return new stzString( This.PreviousNthMarquer(n, pnStartingAt) )

	  #------------------------------------#
	 #    FINDING NTH PREVIOUS MARQUER    #
	#====================================#

	def FindNthPreviousMarquer(n, pnStartingAt)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(1,  pnStartingAt)

		aPositions = oStr.MarquersPositions()
		
		try
			return aPositions[ len(aPositions) - n + 1 ]
		catch
			return 0
		done
		
		#< @FunctionAlternativeForm

		def FindPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING NTH PREVIOUS MARQUER  ALONG WITH ITS POSITION -- Z/Extended   #
	#=========================================================================#

	def NthPreviousMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthPreviousMarquer(n, pnStartingAt)
		nPosition = This.FindNthPreviousMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthPreviousMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)

		def NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def PreviousNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerAndItsPositionD(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)


		def PreviousNthMarquerZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerZD(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)
 
		#>

	  #------------------------------#
	 #   FINDING PREVIOUS MARQUER   #
	#==============================#

	def FindPreviousMarquer(pnStartingAt)
		return This.FindNthPreviousMarquer(1, pnStartingAt)

		def PreviousMarquerPosition(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquer(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrence(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

	  #------------------------------#
	 #   GETTING PREVIOUS MARQUER   #
	#==============================#

	def PreviousMarquer(pnStartingAt)
		return This.NthPreviousMarquer(1, pnStartingAt)

		def PreviousMarquerQ(pnStartingAt)
			return new stzString( This.PreviousMarquer(pnStartingAt) )

	  #--------------------------------------------------------------------#
	 #   FINDING PREVIOUS MARQUER ALONG WITH ITS POSITION -- Z/Extension  #
	#====================================================================#

	def PreviousMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.PreviousMarquer(pnStartingAt)
		nPosition = This.PreviousMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def PreviousMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.PreviousMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerAndItsOccurrence(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.PreviousMarquerAndItsOccurrence(pnStartingAt) )

		def PreviousMarquerAndItsPositionD(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsPositionDQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerAndItsOccurrenceD(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceDQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerDZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerDZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		#>

	  #===========================================================#
	 #   CHECKING IF THE STRING CONTAINS DUPLICATED SUBSTRINGS   #
	#===========================================================#

	def ContainsDuplicatedSubStringsCS(pCaseSensitive)

		if This.NumberOfDuplicatesCS(pCaseSensitive) > 0
			return TRUE
		else
			return FALSE
		ok

		def ContainsDuplicatesCS(pCaseSensitive)
			return This.ContainsDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedSubStrings()
		return This.ContainsDuplicatedSubStringsCS(:CaseSensitive = TRUE)
	
		def ContainsDuplicates()
			return This.ContainsDuplicatedSubStrings()

	  #----------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED IN THE STRING   #
	#----------------------------------------------------------------#

	def ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		return bResult

		def ContainsDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicated(pcSubStr)
		return This.ContainsDuplicatedCS(pcSubStr, :CaseSensitive = TRUE)

		def ContainsDuplicatedSubString(pcSubStr)
			return This.ContainsDuplicated(pcSubStr)

	  #-----------------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED N-TIMES IN THE STRING  #
	#-----------------------------------------------------------------------#

	def ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def SubStringIsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedNTimes(n, pcSubStr)
		return This.ContainsDuplicatedNTimesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def SubStringIsDuplicatedNTimes(n, pcSubStr)
			return This.ContainsDuplicatedNTimes(n, pcSubStr, pItem)

	  #-----------------------------------------------------------------------#
	 #   HOW MANY TIMES A GIVEN SUBSTRING IS DUPLICATED INSIDE THE STRING?   #
	#-----------------------------------------------------------------------#

	def NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		nResult =  This.SubStringsCSQ(pCaseSensitive).
				NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfTimesSubStringIsDuplicated(pcSubStr)
		return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicated(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#--

		def NumberOfDuplicatesOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOf(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING THE EXISTENCE OF NON DUPLICATED SUBSTRINGS IN THE STRING  #
	#=====================================================================#

	def ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

		bResult = This.SubStringsCSQ(pCaseSensitive).
			       ContainsNonDuplicatedItemsCS(pCaseSensitive)

		return bResult

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedsubStrings()
		return This.ContainsNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

		def ContainsNoDuplications()
			return This.ContainsNonDuplicatedSubStrings()

	  #-------------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsCS(pCaseSensitive)
		acResult = This.Copy().RemoveDuplicatedSubStringsCSQ(pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedISubStrings()
		return This.NonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #---------------------------------------#
	 #  NUMBER OF NON DUPLICATED SUBSTRINGS  #
	#---------------------------------------#

	def NumberOfNonDuplicatedSubStringsCS(pCaseSensitive)
		nResult = This.SubStringsCSQ(pCaseSensitive).NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedSubStrings()
		return This.NumberOfNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #-------------------------------------#
	 #  FINDING NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------#

	def FindNonDuplicatedSubStringsCS(pCaseSensitive)
		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)
		anResult = []

		for i = 1 to nLen
			# By defintion, a non duplicated substring apprears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			anResult + nPos
		next

		anResult = Q(anResult).Sorted()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedSubStrings()
		return This.FindNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #-------------------------------------------------#
	 #  NON DUPLICATED SUBSTRINGS AND THEIR POSITIONS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated substrings appears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			aResult + [ acNonDuplicated[i], nPos ]
		next

		return aResult

		def NonDuplicatedSubstringsZCS(pCaseSensitive)
			return This.NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedSubStringsAndTheirPositions()
		return This.NonDuplicatedSubStringsAndTheirPositionsCS(:CaseSensitive = TRUE)

		def NonDuplicatedSubStringsZ()
			return This.NonDuplicatedSubStringsAndTheirPositions()

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)

		nResult = len( This.DuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(:CaseSensitive = TRUE)

		#< @functionAlternativeForms

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		#>

	  #----------------------#
	 #  FINDING DUPLICATES  #
	#----------------------#

	def FindDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesXTCS(pCaseSensitive)
		anResult = Q(anPos).ToSet()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(:CaseSensitive = TRUE)

	  #----------------------------------#
	 #  FINDING DUPLICATES -- EXTENDED  #
	#----------------------------------#

	# This extended form keeps the positions even if they are duplicated
	# For example :
	# 	
	def FindDuplicatesXTCS(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesXTCS(:CaseSensitive = TRUE)

	  #----------------------------------#
	 #  FINDING DUPLICATES AS SECTIONS  #
	#----------------------------------#

	def FindDuplicatesAsSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		nLen = len(acDuplicates)

		aResult = []

		for i = 1 to nLen
			aSections = This.FindAsSectionsCSQ(acDuplicates[i], pCaseSensitive).
					 FirstItemRemoved()

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = QR(aResult, :stzListOfPairs).Sorted()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesAsSections()
		return This.FindDuplicatesAsSectionsCS(:CaseSensitive = TRUE)

	  #--------------#
	 #  DUPLICATES  #
	#--------------#

	def DuplicatesCS(pCaseSensitive)
		
		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = This.Section(i, j)

				if Q(acResult).ContainsNoCS(cSubStr, pCaseSensitive) and
				   This.NumberOfOccurrenceCS(cSubStr, TRUE) > 1

					acResult + cSubStr
				ok

			next
		next
		
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(:CaseSensitive = TRUE)

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR POSITIONS -- Z/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirPositionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesXTCS(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesZCS(pCaseSensitive)
			return This.DuplicatesAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirPositions()
		return This.DuplicatesAndTheirPositionsCS(:CaseSensitive = TRUE)

		def DuplicatesZ()
			return This.DuplicatesAndTheirPositions()

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR SECTIONS -- ZZ/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesZZCS(pCaseSensitive)
			return This.DuplicatesAndTheirSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirSections()
		return This.DuplicatesAndTheirSectionsCS(:CaseSensitive = TRUE)

		def DuplicatesZZ()
			return This.DuplicatesAndTheirSections()

	  #---------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		anResult = []
		anPos = This.FindOccurrenceCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			anResult = Q(anPos).FirstItemRemoved()
		ok

		return anResult
		

		def PositionsOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubString(pcSubStr)
		return This.FindDuplicatesOfSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def PositionsOfDuplicatesOfSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

	  #---------------------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING AS SECTIONS   #
	#---------------------------------------------------------#

	def FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = []
		anPos = This.FindOccurrencesAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			aResult = Q(anPos).FirstItemRemoved()
		ok

		return aResult
		

		def PositionsOfDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubStringAsSections(pcSubStr)
		return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def PositionsOfDuplicatesOfSubStringAsSections(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

	  #-------------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE STRING   #
	#===========================================#

	def RemoveDuplicatesCS(pCaseSensitive)

		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

	def DuplicatesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(:CaseSensitive = TRUE)

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

  	  #----------------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN SUBSTRING   #
	#----------------------------------------------#

	def RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

			def RemoveDuplicatesOfThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisSubstringRemovedCS(pcSubStr, pCaseSensitive)
			return This.DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubString(pcSubStr)
		This.RemoveDuplicatesOfSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringQ(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcsubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubString(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcSubStr)

			def RemoveDuplicatesOfThisSubStringQ(pcSubStr)
				This.RemoveDuplicatesOfThisSubString(pcSubStr)
				return This

		#>

	def DuplicatesOfSubStringRemoved(pcSubStr)
		return This.DuplicatesOfSubStringRemovedCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisSubStringRemoved(pcSubStr)
			return This.DuplicatesOfSubStringRemoved(pcSubStr)

		#>

	  #--------------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN SUBSTRINGS   #
	#--------------------------------------------------#

	def RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param! paItems must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(pacSubStr[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsCSQ(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

			def RemoveDuplicatesOfTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubStrings(pacSubStr)
		This.RemoveDuplicatesOfSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsQ(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOfTheseSubStrings(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)

			def RemoveDuplicatesOfTheseSubStringsQ(pacSubStr)
				This.RemoveDuplicatesOfTheseSubStrings(pacSubStr)
				return This

		#>

	  #===============================================#
	 #   TRANSFORMING THE STRING TO A STZTEXTOBJECT  #
	#===============================================#

	def ToStzText()
		return new stzText( This.String() )

	  #===============================================#
	 #      NUMBER OF OCCURRENCE OF A SUBSTRING      #
	#===============================================#

	def NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		nResult = -1 + This.SplitCSQ(pcSubStr, pCaseSensitive).NumberOfItems()
		return nResult

		#< @FunctionFluentForm

		def NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def CountCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def CountCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def HowManyCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def HowManyCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pcSubStr)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		return NumberOfOccurrenceCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumberOfOccurrenceQ(pcSubStr)
			return new stzNumber( This.NumberOfOccurrence(pcSubStr) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrences(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrenceOfSubstring(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfSubstringCQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOfSubstring(pcSubStr)
			return This.NumberOfOccurrenceOfSubstring(pcSubStr)

			def NumberOfOccurrencesOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def Count(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def CountQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def HowMany(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def HowManyQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		#>

	  #=======================================================#
	 #    CHECKING IF THE STRING IS ONE OF THE RING TYPES    #
	#=======================================================#

	def IsRingType()
		return This.UppercaseQ().IsOneOfThese([ "NUMBER", "STRING", "LIST", "OBJECT", "COBJECT" ])

	  #==============================#
	 #  GETTING THE SIZE IN BYTES   #
	#==============================#

	def NumberOfBytes()
		return This.ToStzListOfBytes().NumberOfBytes()

		#< @FunctionAlternativeForm

		def SizeInBytes()
			return This.NumberOfBytes()

		def CountBytes()
			return This.NumberOfBytes()

		def HowManyBytes()
			return This.NumberOfBytes()

		def HowManyByte()
			return This.NumberOfBytes()

		def LengthInBytes()
			return This.NumberOfBytes()

		def LengthInByte()
			return This.NumberOfBytes()

		#>
	
	def NumberOfBytesPerChar()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.CharQ(i).NumberOfBytes() ]
		next

		return aResult

		#< @FunctionAlternativeFormss

		def CountBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytePerChar()
			return This.NumberOfBytesPerChar()

	  #------------------------------#
	 #   BYTES AND BYTES PER CHAR   #
	#==============================#

	def Bytes()
		return This.ToStzListOfBytes().Content()

		#< @FunctionFluentForms

		def BytesQ()
			return This.ToStzListOfBytes()

		#>
	
		#< @FunctionAlternativeForm

		def ToListOfBytes()
			return This.Bytes()
	
			def ToListOfBytesQ()
				return This.BytesQ()
	
		#>

	def BytesPerChar()
		return This.ToStzListOfBytes().BytesPerChar()

	  #--------------------------------------#
	 #   BYTECODES AND BYTECODES PER CHAR   #
	#--------------------------------------#

	def Bytecodes()
		return This.ToStzListOfBytes().Bytecodes()

	def BytecodesPerChar()
		return This.ToStzListOfBytes().BytecodesPerChar()

	  #--------------------------------------------------------#
	 #   TRANSFORMING THE STRING TO A stzListOfBytes OBJECT   #
	#--------------------------------------------------------#

	def ToStzListOfBytes()
		return new stzListOfBytes( This.String() )

	  #===========================================#
	 #   N RIGHT CHARS RETURNED AS A SUBSTRING   #
	#===========================================#

	def NRightCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok


		if n = 0
			return NULL
		else
			if This.IsRightToleft()
				cResult = This.Section( 1, n )
			else
				cResult = This.Section( This.NumberOfChars() - n + 1, NumberOfChars() )
			end
					
			return cResult
		ok

		#< @FunctionFluentForm

		def NRightCharsAsSubStringQ(n)
			return new stzString( This.NRightCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NRightCharsAsString(n)
			return This.NRightCharsAsSubString(n)

			def NRightCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

		def RightNCharsAsSubString(n)
			return This.NRightCharsAsSubString(n)
	
			def RightNCharsAsString(n)
				return This.RightNCharsAsSubString(n)

			def RightNCharsAsSubStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

			def RightNCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)
	
		def Right(n)
			return This.NRightCharsAsSubString(n)

			def RightQ(n)
				return This.NRightCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Right2CharsAsSubString()
			return This.NRightCharsAsSubString(2)

			def Right2CharsAsString()
				return This.Right2CharsAsSubString()

			def 2RightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def 2RightCharsAsString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsString()
				return This.NRightCharsAsSubString(2)

		def Right3CharsAsSubString()
			return This.NRightCharsAsSubString(3)

			def Right3CharsAsString()
				return This.Right3CharsAsSubString()

			def 3RightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def 3RightCharsAsString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsString()
				return This.NRightCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLeftCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return NULL
		else
			if IsRightToleft()
				cResult = Section( This.NumberOfChars()-n+1, NumberOfChars() )
			else
				cResult = Section( 1, n)
			end
	
			return cResult
		ok

		#< @FunctionFluentForm

		def NLeftCharsAsSubStringQ(n)
			return new stzString( This.NLeftCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLeftCharsAsString(n)
			return This.NLeftCharsAsSubString(n)

			def NLeftCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def LeftNCharsAsSubString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsSubStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)
	
		def LeftNCharsAsString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def Left(n)
			return This.NLeftCharsAsSubString(n)

			def LeftQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Left2CharsAsSubString()
			return This.NLeftCharsAsSubString(2)

			def Left2CharsAsString()
				return This.Left2CharsAsSubString()

			def 2LefthtCharsAsSubString()
				return This.NLefttCharsAsSubString(2)

			def 2LefthtCharsAsString()
				return This.NLefttCharsAsSubString(2)

			def LeftTwoCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def LeftTwoCharsAsString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsString()
				return This.NLeftCharsAsSubString(2)

		def Left3CharsAsSubString()
			return This.NLeftCharsAsSubString(3)

			def Left3CharsAsString()
				return This.Left3CharsAsSubString()

			def 3LeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def 3LeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

		#>

	  #-------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A SUBSTRING   #
	#-------------------------------------------#

	def NFirstCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NRightCharsAsSubString(n)
		else
			return This.NLeftCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsAsSubStringQ(n)
			return new stzString( This.NFirstCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NFirstCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFirstCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FirstNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FirstNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
		#>

		#< @FunctionSpecificForms

		def First2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def First2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def First3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def First3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LAST CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLastCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftCharsAsSubString(n)
		else
			return This.NRightCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsAsSubStringQ(n)
			return new stzString( This.NLastCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLastCharsAsString(n)
			return This.NLastCharsAsSubString(n)

			def NLastCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsSubString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsSubStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2CharsAsSubString()
			return This.NLastCharsAsSubString(2)

			def Last2CharsAsString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsString()
				return This.NLastCharsAsSubString(2)

		def Last3CharsAsSubString()
			return This.NLastCharsAsSubString(3)

			def Last3CharsAsString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsString()
				return This.NLastCharsAsSubString(3)

		#>

	  #-----------------------------------------------------------#
	 #   GETTING THE NEXT NTH CHAR STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------#

	def NextNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return NULL
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstStringItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString, :LastStringItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(1, This.NumberOfChars() - 1)
			if pnStartingAt + n <= This.NumberOfChars()
				cResult = This.CharAt(pnStartingAt + n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def NextNthCharQ(n, pnStartingAt)
			return This.NextNthCharQR(n, pnStartingAt, :stzString)

		def NextNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NextNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.NextNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthNextChar()
			return This.NextNthChar()

			def NthNextCharQ()
				return This.NthNextCharQR(:stzString)
	
			def NthNextCharQR(pcReturnType)
				return This.NextNthCharQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2ndChar()
			return This.NextNthChar(2)

			def 2ndNextChar()
				return This.NextNthChar(2)

			def NextSecondChar()
				return This.NextNthChar(2)

			def SecondNextChar()
				return This.NextNthChar(2)

		def Next3rdChar()
			return This.NextNthChar(3)

			def 3rdNextChar()
				return This.NextNthChar(3)

			def NextThirdChar()
				return This.NextNthChar(3)

			def ThirdNextChar()
				return This.NextNthChar(3)

		#>

	  #-------------------------------------------------------#
	 #   GETTING THE NEXT CHAR STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------------#

	def NextChar(paStartingAt)
		return This.NextNthChar(1)

		#< @FunctionFluentForm

		def NextCharQ(pnStartingAt)
			return This.NextCharQR(pnStartingAt, :stzString)

		def NextCharQR(pnStartingAt, pcReturnType)
			return This.NextNthCharQR(1, pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #   GETTING THE PREVIOUS NTH CHAR STARTING AT A GIVEN POSITION   #
	#----------------------------------------------------------------#

	def PreviousNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstStringItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString, :LastStringItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(2, This.NumberOfChars())
			if pnStartingAt - n >= 1
				cResult = This.CharAt(pnStartingAt - n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def PreviousNthCharQ(n, pnStartingAt)
			return This.PreviousNthCharQR(n, pnStartingAt, :stzString)

		def PreviousNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthPreviousChar()
			return This.PreviousNthChar()

			def NthPreviousCharQ()
				return This.NthPreviousCharQR(:stzString)
	
			def NthPreviousCharQR(pcReturnType)
				return This.PreviousNthCharQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2ndChar()
			return This.PreviousNthChar(2)

			def 2ndPreviousChar()
				return This.PreviousNthChar(2)

			def PreviousSecondChar()
				return This.PreviousNthChar(2)

			def SecondPreviousChar()
				return This.PreviousNthChar(2)

		def Previous3rdChar()
			return This.PreviousNthChar(3)

			def 3rdPreviousChar()
				return This.PreviousNthChar(3)

			def PreviousThirdChar()
				return This.PreviousNthChar(3)

			def ThirdPreviousChar()
				return This.PreviousNthChar(3)

		#>

	  #------------------------------------------------------------#
	 #   GETTING THE PREVIOUS CHAR STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------------#

	def PreviousChar(n)
		return This.PreviousNthChar(n, 1)

		#< @FunctionFluentForm

		def PreviousCharQ(pnStartingAt)
			return This.PreviousCharQR(pnStartingAt, :stzString)

		def PreviousCharQR(pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousChar(pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousChar(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off	
		#>

	  #------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A SUBSTRING)   #
	#------------------------------------------------------------------------#

	def NextNCharsAsSubString(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt, pnStartingAt + n - 1)

		return cResult

		#< @FunctionFluentForm

		def NextNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString(This.NextNCharsAsSubString(n, pnStartingAt))

		#>

		#< @FunctionAlternativeForm

		def NextNCharsAsString(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Next2CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(2, pnStartingAt)

			def Next2CharsAsString(pnStartingAt)
				return This.Next2CharsAsSubString(pnStartingAt)

			def 2NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def 2NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

		def Next3CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(3, pnStartingAt)

			def Next3CharsAsString(pnStartingAt)
				return This.Next3CharsAsSubString(pnStartingAt)

			def 3NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def 3NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A SUBSTRING  #
	#-------------------------------------------------------------------------#

	def PreviousNCharsAsSubString(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt - n + 1, pnStartingAt)

		return cResult

		#< @FunctionFluentForm

		def PreviousNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString( This.PreviousNCharsAsSubString(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def PreviousNCharsAsString(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)
	
		#>

		#< @FunctionSpecificForms

		def Previous2CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def Previous2CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

		def Previous3CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def Previous3CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)
	
			def PreviousThreeCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def PreviousThreeCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

		#>

	  #===============================================#
	 #   N RIGHT CHARS RETURNED AS A LIST OF CHARS   #
	#===============================================#

	def NRightChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		acResult = []

		if This.IsRightToleft()
			acResult = This.SectionQ( 1, n ).Chars()
		else
			acResult = This.SectionQ( This.NumberOfChars() - n + 1, NumberOfChars() ).Chars()
		end
					
		return acResult

		#< @FunctionFluentForm

		def NRightCharsQ(n)
			return This.NRightCharsQR(n, :stzList)

		def NRightCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NRightChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NRightChars(n) )

			on :stzListOfChars
				return new stzListOfchars( This.NRightChars(n) )

			on :stzString
				return new stzString( This.NRightCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def RightNChars(n)
			return This.NRightChars(n)
	
			def RightNCharsQ(n)
				return This.NRightCharsQ(n)

			def RightNCharsQR(n, pcReturnType)
				return This.NRightCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Right2Chars()
			return This.NRightChars(2)

			def 2RightChars()
				return This.NRightChars(2)

			def RightTwoChars()
				return This.NRightChars(2)

			def TwoRightChars()
				return This.NRightChars(2)

	
		def Right3Chars()
			return This.NRightChars(3)

			def 3RightChars()
				return This.NRightChars(3)

			def RightThreeChars()
				return This.NRightChars(3)

			def ThreeRightChars()
				return This.NRightChars(3)

		#>

	  #----------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLeftChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		acResult = []

		if IsRightToleft()
			acResult = SectionQ( This.NumberOfChars()-n+1, NumberOfChars() ).Chars()
		else
			acResult = SectionQ( 1, n).Chars()
		end
	
		return acResult


		#< @FunctionFluentForm

		def NLeftCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NLeftCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLeftChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLeftChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLeftChars(n) )

			on :stzString
				return new stzString( This.NLeftCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LeftNChars(n)
			return This.NLeftChars(n)
	
			def LeftNCharsQ(n)
				return This.NLeftCharsQ(n)

			def LeftNCharsQR(n, pcReturnType)
				return This.NLeftCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Left2Chars()
			return This.NLeftChars(2)

			def 2LefthtChars()
				return This.NLefttChars(2)

			def LeftTwoChars()
				return This.NLeftChars(2)

			def TwoLeftChars()
				return This.NLeftChars(2)

	
		def Left3Chars()
			return This.NLeftChars(3)

			def 3LeftChars()
				return This.NLeftChars(3)

			def LeftThreeChars()
				return This.NLeftChars(3)

			def ThreeLeftChars()
				return This.NLeftChars(3)

		#>

	  #-----------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A LIST OF CHARS   #
	#-----------------------------------------------#

	def NFirstChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		if This.IsRightToLeft()
			return This.NRightChars(n)
		else
			return This.NLeftChars(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NFirstCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NFirstChars(n) )

			on :stzString
				return new stzString( This.NFirstCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def FirstNChars(n)
			return This.NFirstChars(n)
	
			def FirstNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FirstNCharsQR(n, pcReturnType)
				return This.NFirstCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def First2Chars()
			return This.NFirstChars(2)

			def 2FirstChars()
				return This.NFirstChars(2)

			def FirstTwoChars()
				return This.NFirstChars(2)

			def TwoFirstChars()
				return This.NFirstChars(2)

		def First3Chars()
			return This.NFirstChars(3)

			def 3FirstChars()
				return This.NFirstChars(3)

			def FirstThreeChars()
				return This.NFirstChars(3)

			def ThreeFirstChars()
				return This.NFirstChars(3)

		def First4Chars()
			return This.FirstNChars(4)
	
			def 4FirstChars()
				return This.First4Chars()
	
			def FirstFourChars()
				return This.First4Chars()
	
			def FourFirstChars()
				return This.First4Chars()
	
		def First5Chars()
			return This.FirstNChars(5)
	
			def 5FirstChars()
				return This.First5Chars()
	
			def FirstFiveChars()
				return This.First5Chars()
	
			def FiveFirstChars()
				return This.First5Chars()
	
		def First6Chars()
			return This.FirstNChars(6)
	
			def 6FirstChars()
				return This.First6Chars()
	
			def FirstSixChars()
				return This.First6Chars()
	
			def SixFirstChars()
				return This.First6Chars()
	
		def First7Chars()
			return This.FirstNChars(7)
	
			def 7FirstChars()
				return This.First7Chars()
	
			def FirstSevenChars()
				return This.First7Chars()
	
			def SevenFirstChars()
				return This.First7Chars()
	
		def First8Chars()
			return This.FirstNChars(8)
	
			def 8FirstChars()
				return This.First8Chars()
	
			def FirstEightChars()
				return This.First8Chars()
	
			def EightFirstChars()
				return This.First8Chars()
	
		def First9Chars()
			return This.FirstNChars(9)
	
			def 9FirstChars()
				return This.First9Chars()
	
			def FirstNineChars()
				return This.First9Chars()
	
			def NineFirstChars()
				return This.First9Chars()
	
		def First10Chars()
			return This.FirstNChars(10)
	
			def 10FirstChars()
				return This.First10Chars()
	
			def FirstTenChars()
				return This.First10Chars()
	
			def TenFirstChars()
				return This.First10Chars()
	
		#>

	  #----------------------------------------------#
	 #   N LAST CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLastChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftChars(n)
		else
			return This.NRightChars(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsQ(n)
			return This.NLastCharsQR(n, pcReturnType)

		def NLastCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLastChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLastChars(n) )

			on :stzString
				return new stzString( This.NLastCharsQR(n, :stzListOfStrings).Concatenated() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNChars(n)
			return This.NLastChars(n)
	
			def LastNCharsQ(n)
				return This.NLastCharsQ(n)

			def LastNCharsQR(n, pcReturnType)
				return This.NLastCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Last2Chars()
			return This.NLastChars(2)

			def 2LastChars()
				return This.NLastChars(2)

			def LastTwoChars()
				return This.NLastChars(2)

			def TwoLastChars()
				return This.NLastChars(2)

		def Last3Chars()
			return This.NLastChars(3)

			def 3LastChars()
				return This.NLastChars(3)

			def LastThreeChars()
				return This.NLastChars(3)

			def ThreeLastChars()
				return This.NLastChars(3)

		def Last4Chars()
			return This.LastNChars(4)
	
			def 4LastChars()
				return This.Last4Chars()
	
			def LastFourChars()
				return This.Last4Chars()
	
			def FourLastChars()
				return This.Last4Chars()
	
		def Last5Chars()
			return This.LastNChars(5)
	
			def 5LastChars()
				return This.Last5Chars()
	
			def LastFiveChars()
				return This.Last5Chars()
	
			def FiveLastChars()
				return This.Last5Chars()
	
		def Last6Chars()
			return This.LastNChars(6)
	
			def 6LastChars()
				return This.Last6Chars()
	
			def LastSixChars()
				return This.Last6Chars()
	
			def SixLastChars()
				return This.Last6Chars()
	
		def Last7Chars()
			return This.LastNChars(7)
	
			def 7LastChars()
				return This.Last7Chars()
	
			def LastSevenChars()
				return This.Last7Chars()
	
			def SevenLastChars()
				return This.Last7Chars()
	
		def Last8Chars()
			return This.LastNChars(8)
	
			def 8LastChars()
				return This.Last8Chars()
	
			def LastEightChars()
				return This.Last8Chars()
	
			def EightLastChars()
				return This.Last8Chars()
	
		def Last9Chars()
			return This.LastNChars(9)
	
			def 9LastChars()
				return This.Last9Chars()
	
			def LastNineChars()
				return This.Last9Chars()
	
			def NineLastChars()
				return This.Last9Chars()
	
		def Last10Chars()
			return This.LastNChars(10)
	
			def 10LastChars()
				return This.Last10Chars()
	
			def LastTenChars()
				return This.Last10Chars()
	
			def TenLastChars()
				return This.Last10Chars()
	
		#>

	  #---------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A LIST OF CHARS)  #
	#---------------------------------------------------------------------------#

	def NextNChars(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt, pnStartingAt + n - 1).Chars()

		return acResult

		#< @FunctionFluentForm

		def NextNCharsQ(n, pnStartingAt)
			return This.NextNCharsQR(n, pnStartingAt, :stzList)

		def NextNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NNextChars(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsQ(n, pnStartingAt)
				return This.NNextCharsQR(n, pnStartingAt, :stzList)

			def NNextCharsQR(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2Chars(pnStartingAt)
			return This.NextNChars(2, pnStartingAt)

			def 2NextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def NextTwoChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def TwoNextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

		def Next3Chars(pnStartingAt)
			return This.NextNChars(3, pnStartingAt)

			def 3NextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def NextThreeChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def ThreeNextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A LIST OF CHARS  #
	#-----------------------------------------------------------------------------#

	def PreviousNChars(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt - n + 1, pnStartingAt).Chars()

		return acResult

		#< @FunctionFluentForm

		def PreviousNCharsQ(n, pnStartingAt)
			return This.PreviousNCharsQR(n, pnStartingAt, :stzList)

		def PreviousNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NPreviousChars(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsQ(n, pnStartingAt)
				return This.NPreviousCharsQR(n, pnStartingAt, :stzList)

			def NPreviousCharsQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2Chars(pnStartingAt)
			return This.PreviousNChars(2, pnStartingAt)

			def 2PreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def PreviousTwoChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def TwoPreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

		def Previous3Chars(pnStartingAt)
			return This.PreviousNChars(3, pnStartingAt)

			def 3PreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def PreviousThreeChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def ThreePreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

		#>

	  #====================================================#
	 #  INFERING A RING OR SOFTANZA TYPE FROM THE STRING  #
	#====================================================#

	def InfereType()
		cStr = This.Lowercased()

		# Checking if the string correponds to one of the 4 Ring types

		if cStr = :number or cStr = :numbers or Q(cStr).BeginsWith(:Number)
			return :Number
	
		but cStr = :string or cStr = :strings or Q(cStr).BeginsWith(:String)
			return :String
	
		but cStr = :list or cStr = :lists or Q(cStr).BeginsWith(:List) or
		    cStr = :pair or cStr = :pairs or Q(cStr).BeginsWith(:pair)
	
			return :List
	
		but cStr = :object or cStr = :objects or Q(cStr).BeginsWith(:Object)
			return :Object
	
		ok
	
		# Checking if the string correponds to one of the Softanza types

		if Q(cStr).BeginsWithCS("stz", :CS = FALSE)
			acStzClasses = StzClassesXT()
			nLen = len(acStzClasses)

			for i = 1 to nLen
				aPair = acStzClasses[i]
				if aPair[1] = cStr or aPair[2] = cStr
					return aPair[1]
				ok
			next

		but Q("stz" + cStr).IsStzType()
			return "stz" + cStr

		but Q(cStr).IsPluralOfAStzType()
			return PluralToStzType(cStr)

		but Q("stz" + cStr).IsPluralOfAStzType()
			return PluralToStzType("stz" + cStr)

		ok

		#< @FunctionAlternativeForms

		def InfereTypeQ()
			return new stzString( This.InfereType() )

		def InfereStzClass()
			return This.InfereType()

			def InfereStzClassQ()
				return new stzString( This.InfereStzClass() )

		def InfereStzClassName()
			return This.InfereType()

			def InfereStzClassNameQ()
				return new stzString( This.InfereStzClass() )

		#>

	def InferedType()
		return This.InfereType()

		#< @FunctionAlternativeForms

		def InferedStzClass()
			return This.InfereType()

		def InferedStzClassName()
			return This.InfereType()

		#>

	  #----------------------------------------------------#
	 #  INFERING A SOFTANZA CLASS METHOD FROM THE STRING  #
	#----------------------------------------------------#

	def InfereMethod(pcFromStzClass)

		if isList(pcFromStzClass) and
		   Q(pcFromStzClass).IsOneOfTheseNamedParams([ :From, :In, :Of ])
			pcFromStzClass = pcFromStzClass[2]
		ok

		if NOT isString(pcFromStzClass)
			stzRaise("Incorrect param type! pcFromStzClass must be a string.")
		ok

		if Q(pcFromStzClass).IsPluralOfAStzType()
			pcFromStzClass = PluralToStzType(pcFromStzClass)
		ok

		if NOT Q(pcFromStzClass).IsStzClass()
			stzRaise("Syntax error! pcFromStzClass must be a valid Softanza class name.")
		ok

		cCode = 'acTheseMethods = Stz("' +
			Q(pcFromStzClass).FirstNCharsRemoved(3) + '",
			:Methods)'

		eval(cCode)

		cMethod = ""

		oList = new stzList( acTheseMethods )

		if oList.ContainsCS( "is" + This.String(), :CS = FALSE )
			cMethod = "is" + This.String()

		but oList.ContainsCS( "is" + This.LastCharRemoved(), :CS = FALSE )
			cMethod = "is" + This.LastCharRemoved()

		else
			stzRaise("Sorry! Can't infere the method name from the provided string.")
		ok

		return cMethod

		def InfereMethodQ()
			return new stzString( This.InfereMethod() )

	def InferedMethod()
		return InfereMthod()

	  #--------------------------------------------------------------#
	 #    CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	#--------------------------------------------------------------#

	def IsStzClassName()
		acStzClasses = StzClasses()

		n = ring_find( StzClasses(), This.Lowercased() )

		if n > 0
			return TRUE
		else
			return FALSE
		ok

		def IsStzType()
			return This.IsStzClassName()

		def IsStzClass()
			return This.IsStzClassName()

		def IsAStzClassName()
			return This.IsStzClassName()

		def IsAStzType()
			return This.IsStzClassName()

		def IsAStzClass()
			return This.IsStzClassName()

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF ANY SOFTANZA TYPE  #
	#------------------------------------------------------------------#

	def IsPluralOfAStzType()

		if QR( StzTypesXT(), :stzListOfPairs ).
		   SecondItemsQ().
		   ContainsCS( This.Content(), :CaseSensitive = FALSE )

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsPluralOfStzType()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClassName()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClassName()
			return This.IsPluralOfAStzType()

		#--

		def IsStzClassInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassInPlural()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPlural()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPlural()
			return This.IsPluralOfAStzType()

		#>

	   #-------------------------------------------------------------#
	  #   CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	 #   NO MATTER IT WAS IN SINGULAR OR PLURAL FORM               #
	#-------------------------------------------------------------#

	def IsStzClassNameXT()
		
		if This.IsStzClassName() or This.IsStzClassNameInPluralForm()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsStzTypeXT()
			return This.IsStzClassNameXT()

		def IsStzClassXT()
			return This.IsStzClassNameXT()

		def IsAStzClassNameXT()
			return This.IsStzClassNameXT()

		def IsAStzTypeXT()
			return This.IsStzClassNameXT()

		def IsAStzClassXT()
			return This.IsStzClassNameXT()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF A GIVEN SOFTANZA TYPE  #
	#----------------------------------------------------------------------#

	def IsPluralOfThisStzType(cType)

		if Q(cType).IsAStzType() and
		   PluralOfThisStzType(cType) = This.String()

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsPluralOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsPluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsThePluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#>

	   #==================================================#
	  #  SITTING ON A GIVEN POSITION (OR SECTION) AND    #
	 #  THEN HARVESTING N CHARS BEORE AND N CHARS LEFT  #
	#==================================================#

	def Sit(paPositionOrSection, paHarvest)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.Sit(
			:OnSection = [10, 13],
			:Harvest = [ :NCharsBefore = 2, :NCharsAfter = 3 ]
		)

		#--> [ "<<", ">>>" ]

		*/

		if isList(paPositionOrSection) and
			Q(paPositionOrSection).IsOneOfTheseNamedParams([
				:On, :OnPosition, :OnSection,
				:Position, :Section
			])

			paPositionOrSection = paPositionOrSection[2]
		ok

		if isNumber(paPositionOrSection)

			aTemp = []
			aTemp + paPositionOrSection
			aTemp + paPositionOrSection

			paPositionOrSection = aTemp
		ok

		if NOT ( isList(paPositionOrSection) and
			 Q(paPositionOrSection).IsPairOfNumbers() )

			stzRaise("Incorrect param! paPositionOrSection must be a position (number) or a section (pair of numbers).")
		ok

		aSection = paPositionOrSection
		bReturnSections = FALSE

		if isList(paHarvest) and
		   Q(paHarvest).IsOneOfTheseNamedParams([

				:Harvest, :AndHarvest,
				:AndThenHarvest, :ThenHarvest,

				:Yield, :AndYield,
				:AndThenYield, :ThenYield,

				:HarvestSection, :AndHarvestSection,
				:AndThenHarvestSection, :ThenHarvestSection,

				:YieldSection, :AndYieldSection,
				:AndThenYieldSection, :ThenYieldSection,

				:HarvestSections, :AndHarvestSections,
				:AndThenHarvestSections, :ThenHarvestSections,

				:YieldSections, :AndYieldSections,
				:AndThenYieldSections, :ThenYieldSections ])

			if Q(paHarvest[1]).ContainsCS(:Section, :CS = FALSE)
				bReturnSections = TRUE
			ok

			paHarvest = paHarvest[2]
		ok

		if NOT len(paHarvest) = 2
			stzRaise("Incorrect param! paHarvest must be a list of 2 items.")
		ok

		if isList(paHarvest[1]) and Q(paHarvest[1]).IsNCharsBeforeNamedParam()
			paHarvest[1] = paHarvest[1][2]
		ok

		if isList(paHarvest[2]) and Q(paHarvest[2]).IsNCharsAfterNamedParam()
			paHarvest[2] = paHarvest[2][2]
		ok

		if NOT BothAreNumbers(paHarvest[1], paHarvest[2])
			stzRaise("Incorrect param! paHarvest must be a pair of numbers.")
		ok

		nCharsBefore = paHarvest[1]
		nCharsAfter  = paHarvest[2]

		anSectionBefore = [0, 0]
		if nCharsBefore != 0
			anSectionBefore[1] = (aSection[1] - nCharsBefore)
			anSectionBefore[2] = (aSection[1] - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (aSection[2] + 1)
			anSectionAfter[2] = (aSection[2] + nCharsAfter)
		ok

		if bReturnSections
			aResult = [ anSectionBefore, anSectionAfter ]
			
		else
			aResult = This.Sections([ anSectionBefore, anSectionAfter ])
		ok

		return aResult

		def Settle(paPositionOrSection, paHervest)
			return Sit(paPositionOrSection, paHervest)

		def Enclose(paSection, paHervest)
			return Sit(paSection, paHervest)

	  #==============================#
	 #     BOUNDS OF THE STRING     #
	#==============================#

	// Verifies if the string is bounded by substrings 1 and 2 
	def IsBoundedByCS(pacBounds, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("-♥-")
		? o1.IsBoundedBy("-") #--> TRUE

		o1 = new stzString("-♥_")
		? o1.IsBoundedBy([ "-", "_" ]) #--> TRUE

		*/

		# Managing this special syntax:
		# ? Q("♥").IsBoundedBy([ "-", :In = "-♥-" ])

		if isList(pacBounds) and Q(pacBounds).IsPair() and
		   isList(pacBounds[2]) and Q(pacBounds[2]).IsPair()

			if Q(pacBounds[2]).IsInNamedParam()
				return This.IsBoundedByInCS(pacBounds[1], :In = pacBounds[2], pCaseSensitive)

			but Q(pacBounds[2]).IsAndNamedParam()
				pacBounds[2] = pacBounds[2][2]
			ok

		ok

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a list of pairs.")
		ok

		if This.BeginsWithCS(cBound1, pCaseSensitive) and
		   This.EndsWithCS(cBound2, pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsBoundedBy(pacBounds)
		return This.IsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

	   #--------------------------------------------------------#
	  #  CHECKING IF THE STRING IS BOUNDED BY A GIVEN PAIR OF  #
	 #  SUBSTRINGS INSIDE A GIVEN STRING                      #
	#--------------------------------------------------------#

	# NOTE: There is a more elegant alternative I suggest to use: IsBoundeByXT()
	def IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("♥")
		? o1.IsBoundedByIn([ "-", "-" ], :In = "... -♥- ...")
		#--> TRUE

		*/

		if isString(pacBounds)
			aTemp = []
			aTemp + pacBounds + pacBounds

			pacBounds = aTemp
		ok

		if NOT ( isList(pacBounds) and Q(pacBounds).IsPairOfStrings() )
			StzRaise("Incorrect param type! paBounds must be a pair of strings.")
		ok


		if isList(pIn) and Q(pIn).IsInOrInsideNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pIn must be a string or list.")
		ok

		bResult = FALSE

		if isString(pIn)

			oStr = new stzString(pIn)
			bResult = oStr.SubStringIsBoundedByCS( This.String(), pacBounds, pCaseSensitive )

		but isList(pIn) and Q(pIn).IsListOfStrings()

			# TODO
			StzRaise("Currently, the function works only on one string. List of strings are not supported.")
		ok
	
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundedByIBCS(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenIBCS(pacBounds, pIn, pCaseSensitive)

			if NOT isList(pacBounds) and len(pacBounds) = 2
				StzRaise("Incorrect param! pacBounds must be a list of 2 items.")
			ok

			acBounds = []

			if isString(pacBounds[1])
				acBounds + pacBounds[1]
			ok

			if isString(pacBounds[2])
				acBounds + pacBounds[2]

			but isList(pacBounds[2]) and
			   Q(pacBounds[2]).IsAndNamedParam() and
			   isString(pacBounds[2][2])

				acBounds + pacBounds[2][2]
				
			ok

			if NOT Q(acBounds).IsPairOfStrings()
				StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
			ok

			bResult = This.IsBoundedByInCS(acBounds, pIn, pCaseSensitive)

			return bResult
		#>


	#-- WITHOUT CASESENSITIVITY

	def IsBoundedByIn(pacBounds, pIn)
		return This.IsboundedByInCS(pacBounds, pIn, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def IsBoundedByIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenIB(pacBounds, pIn)
			return This.IsBetweenIBCS(pacBounds, pIn, :CaseSensitive = TRUE)

		#>

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDING OF A GIVEN STRING INSIDE ANOTHER STRING  #
	#------------------------------------------------------------------------------#

	def IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("_")
		? o1.IsBoundOf("world", :In = "hello _world_ and <world>!")
		#--> TRUE
		*/

		pcStr = pcInStr[2]
		acBounds = Q(pcStr).BoundsOfCS(pcSubStr, :UpToNChars = This.NumberOfChars(), pCaseSensitive )
		#--> [ [ "_", "_" ], [ "<", ">" ] ]

		bResult = Q(acBounds).Contains( [ This.String(), This.String() ] )
		return bResult

	#-- WITHOUT CASESNESITUVURT

	def IsBoundOf(pcSubStr, pcInStr)
		bResult = This.IsBoundOfCS(pcSubStr, pcInStr, :CaseSensitive = TRUE)
		return bResult

	def IsFirstBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).FirstBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsLastBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LastBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

		def IsSecondBoundOfCS(pcOtherStr, pCaseSensitive)
			return This.IsLastBoundOfCS(pcOtherStr, pCaseSensitive)

	def IsLeftBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LeftBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsRightBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).RightBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	  #------------------------------------#
	 #     ADDING BOUNDS TO THE STRING    #
	#------------------------------------#

	def AddBounds(pacBounds)
		if isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		but isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			StzString("Incorrect param type! pacBounds mus tbe a string or pair of strings.")
		ok

		cResult = cBound1 + This.String() + cBound2
		This.UpdateWith( cResult )

		def AddBoundsQ(pacBounds)
			This.AddBounds(pacBounds)
			return This

		def BoundWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundWithQ(pacBounds)
				This.BoundWith(pacBounds)
				return This

	def StringWithBoundsAdded(pacBounds)
		cResult = This.Copy().AddBoundsQ(pacBounds).Content()

		def StringBoundedWith(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		def BoundedWith()
			return This.StringWithBoundsAdded(pacBounds)

		def BoundsAdded()
			return This.StringWithBoundsAdded(pacBounds)

		def StringBoundedBy(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

	  #-------------------------------------#
	 #  IDENTIFYING BOUNDS OF A SUBSTRING  #
	#-------------------------------------#
	
	def SubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("aa♥♥aaa bb♥♥bbb")
		
		? o1.SubStringIsBoundedBy("♥♥", "aa") #--> TRUE
		? o1.SubStringIsBoundedBy("♥♥", "bb") #--> TRUE
		
		? o1.SubStringIsBoundedBy("♥♥", [ "aa", "aaa" ] ) #--> TRUE
		? o1.SubStringIsBoundedBy("♥♥", [ [ "aa","aaa" ], ["bb","bbb"] ]) #--> TRUE		*/
	
		if isList(pacBounds) and Q(pacBounds).IsPairOfStrings()

			aTemp = []
			aTemp + pacBounds
			pacBounds = aTemp

		but isString(pacBounds)
			aTemp = [ [ pacBounds, pacBounds ] ]
			pacBounds = aTemp
		ok

		if NOT ( isList(pacBounds) and Q(pacBounds).AllItemsArePairsOfStrings() )
			StzRaise("Incorrect param type! pacBounds must be lists of pairs of strings.")
		ok

		bResult = FALSE
		nLen = len(pacBounds)


		for i = 1 to nLen
			acPair = pacBounds[i]
			anUpToNChars = [ Q(acPair[1]).NumberOfChars(),
					 Q(acPair[2]).NumberOfChars() ]

			acBounds = This.BoundsXTCS( :Of = pcSubStr, anUpToNChars, pCaseSensitive)

			bResult = Q(pacBounds).AllItemsExistIn(acBounds)
		next

		return bResult
		

	def SubStringIsBoundedBy(pcSubStr, pacBounds)
		return This.SubStringIsBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

	  #=============================================================================#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING BY RETURNING THEIR SECTIONS  #
	#=============================================================================#

	def FindBoundsAsSectionsCS(pCaseSensitive)

		aResult = [
			This.FindLeadingCharsAsSectionCS(pCaseSensitive),
			This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBoundsAsSections()
		return This.FindBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSections()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsAsSectionCS(pCaseSensitive),
			This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBoundsAsSections()
		return This.FindLastAndFirstBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftAndRightBoundsAsSections()
		return This.FindLeftAndRightBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSections()
			return This.FindLeftAndRightBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSectionsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightAndLeftBoundsAsSections()
		return This.FindRightAndLeftBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSections()
			return This.FindRightAndLeftBoundsAsSections()

		#>

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDED (HAS BOUNDS)  #
	#==================================================#

	def IsBoundedCS(pCaseSensitive)
		if len(This.BoundsCS(pCaseSensitive)) > 0
			return TRUE
		else
			return FALSE
		ok

		def HasBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsBounded()
		return This.IsBoundedCS(:CaseSensitive = TRUE)

		def HasBounds()
			return This.IsBounded()

	  #-------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def FindBoundsCS(pCaseSensitive)

		aResult = [
			This.FindLeadingCharsCS(pCaseSensitive),
			This.FindTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBounds()
		return This.FindBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringBounds()
			return This.FindBounds()

		def FindFirstAndLastBounds()
			return This.FindBounds()

			def FindFirstAndSecondBounds()
				return This.FindBounds()
	
		def FindFirstAndLastStringBounds()
			return This.FindBounds()

			def FindFirstAndSecondStringBounds()
				return This.FindBounds()
	
		def FindStringFirstAndLastBounds()
			return This.FindBounds()

			def FindStringFirstAndSecondBounds()
				return This.FindBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLastAndFirstBoundsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsCS(pCaseSensitive),
			This.FindLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBounds()
		return This.FindLastAndFirstBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringLastAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLeftAndRightBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.This.FindTrailingCharsCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringLeftAndRightBoundsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsCS(pCaseSensitive)

	#--

	def FindLeftAndRightBounds()
		return This.FindLeftAndRightBoundsCS(:CaseSensitive = TRUE)

		def FindStringLeftAndRightBounds()
			return This.FindLeftAndRightBounds()

	  #--------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindRightAndLeftBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)

		else
			a1 = This.This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)
			
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringRightAndLeftBoundsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsCS(pCaseSensitive)

	#--

	def FindRightAndLeftBounds()
		return This.FindRightAndLeftBoundsCS(:CaseSensitive = TRUE)

		def FindStringRightAndLeftBounds()
			return This.FindRightAndLeftBounds()

	  #-------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def BoundsCS(pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("<<Ring>>")
		? o1.Bounds()
		#--> [ "<<", ">>" ]

		EXAMPLE 2

		o1 = new stzString("---Ring___")
		? o1.Bounds()
		#--> [ "---, "___" ]

		*/

		acResult = []

		if This.ContainsLeadingAndTrailingCharsCS(pCaseSensitive)

			acResult = [
				This.LeadingCharsAsStringCS(pCaseSensitive),
				This.TrailingCharsAsStringCS(pCaseSensitive)
			]
		ok

		return acResult

		#< @FunctionAlternativeForms

		def StringBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def FirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Bounds()
		return This.BoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def StringBounds()
			return This.Bounds()

		def FirstAndLastBounds()
			return This.Bounds()

		def StringFirstAndLastBounds()
			return This.Bounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LastAndFirstBoundsCS(pCaseSensitive)
		acResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FirstBoundCS(pCaseSensitive)
		]

		return acResult

		#< @FunctionAlternatoveForms

		def SecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringLastAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBounds()
		return This.LastAndFirstBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternatoveForms

		def SecondAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringLastAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringSecondAndFirstBounds()
			return This.LastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LeftAndRightBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = This.LastBoundCS(pCaseSensitive)

		else
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = Thus.FirstBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringLeftAndRightBoundsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBounds()
		return This.LeftAndRightBoundsCS(:CaseSensitive = TRUE)

		def StringLeftAndRightBounds()
			return This.LeftAndRightBoundsCS()

	  #--------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def RightAndLeftBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = This.FirstBoundCS(pCaseSensitive)

		else
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = Thus.LastBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringRightAndLeftBoundsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBounds()
		return This.RightAndLeftBoundsCS(:CaseSensitive = TRUE)

		def StringRightAndLeftBounds()
			return This.RightAndLeftBoundsCS()

	  #------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#========================================================================#

	def BoundsZCS(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		def StringBoundsZCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		def StringBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		#--

		def FirstAndLastBoundsZCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		def FirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		def StringFirstAndLastBoundsZCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZ()
		return This.BoundsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositions()
			return This.BoundsZ()

		def StringBoundsZ()
			return This.BoundsZ()

		def StringBoundsAndTheirPositions()
			return This.BoundsZ()

		#--

		def FirstAndLastBoundsZ()
			return This.BoundsZ()

		def FirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFirstAndLastBoundsZ()
			return This.BoundsZ()

		def StringFirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------------------#

	def BoundsZZCS(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		def StringBoundsZZCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		def StringBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		#--

		def FirstAndLastBoundsZZCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		def FirstAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		def StringFirstAndLastBoundsZZCS(pCaseSensitive)
			return This.BoundszZCS(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZZ()
		return This.BoundsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirSections()
			return This.BoundsZZ()

		def StringBoundsZZ()
			return This.BoundsZZ()

		def StringBoundsAndTheirSrctions()
			return This.BoundsZZ()

		#--

		def FirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def FirstAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LastAndFirstBoundsZCS(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZCS(pCaseSensitive)
			return This.LastAndFirstBoundsZCS(pCaseSensitive)

		def LastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsZCS(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsZCS(pCaseSensitive)
	
		def StringLastAndFirstBoundsZCS(pCaseSensitive)
			return This.LastAndFirstBoundsZCS(pCaseSensitive)

			def StringSecondAndFirstBoundsZCS(pCaseSensitive)
				return This.LastAndFirstBoundsZCS(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsZCS(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsZCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZ()
		return This.LastAndFirstBoundsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

		def LastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def SecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsZ()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LastAndFirstBoundsZZCS(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZZCS(pCaseSensitive)
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)

		def LastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsZZCS(pCaseSensitive)
	
		def StringLastAndFirstBoundsZZCS(pCaseSensitive)
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)

			def StringSecondAndFirstBoundsZZCS(pCaseSensitive)
				return This.LastAndFirstBoundsZZCS(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsZZCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZZ()
		return This.LastAndFirstBoundsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

		def LastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def SecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsZZ()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LeftAndRightBoundsZCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsZCS(pCaseSensitive)

		else
			return This.LastAndFirstBoundsZCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsZCS(pCaseSensitive)

		def StringLeftAndRightBoundsZCS(pCaseSensitive)
			return This.LeftAndRightBoundsZCS(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZ()
		return This.LeftAndrightBoundsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsZ()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LeftAndRightBoundsZZCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsZZCS(pCaseSensitive)

		else
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsZZCS(pCaseSensitive)

		def StringLeftAndRightBoundsZZCS(pCaseSensitive)
			return This.LeftAndRightBoundsZZCS(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZZ()
		return This.LeftAndRightBoundsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndrightBoundsZZ()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ(pCaseSensitive)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def RightAndLeftBoundsZCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsZCS(pCaseSensitive)

		else
			return This.FirstAndLastBoundsZCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsZCS(pCaseSensitive)

		def StringRightAndLeftBoundsZCS(pCaseSensitive)
			return This.RightAndLeftBoundsZCS(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZ()
		return This.RightAndLeftBoundsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsZ()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def RightAndLeftBoundsZZCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsZZCS(pCaseSensitive)

		else
			return This.FirstAndLastBoundsZZCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsZZCS(pCaseSensitive)

		def StringRightAndLeftBoundsZZCS(pCaseSensitive)
			return This.RightAndLeftBoundsZZCS(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZZ()
		return This.RightAndLeftBoundsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSections()
		return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsZZ()
			return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsAndTheirSections()
			return This.RightAndLeftBoundsZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING  #
	#=========================================#

	def FindFirstBoundCS(pCaseSensitive)
		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			return 1
		else
			return 0
		ok

		def FindStringFirstBoundCS(pCaseSensitive)
			return This.FindFirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBound()
		return This.FindFirstBoundCS(:CaseSensitive = TRUE)

		def FindStringFirstBound()
			return This.FindFirstBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			anResult + 1 + n
		ok

		return anResult

		def FindStringFirstBoundAsSectionCS(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBoundAsSection()
		return This.FindFirstBoundAsSectionCS(:CaseSensitive = TRUE)

		def FindStringFirstBoundAsSection()
			return This.FindFirstBoundAsSection()

	  #-----------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING  #
	#-----------------------------------------#

	def FirstBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[1]
		return cResult

		def StringFirstBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstBound()
		return This.FirstBoundCS(:CaseSensitive = TRUE)

		def StringFirstBound()
			return This.FirstBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def FirstBoundZCS(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundZCS(pCaseSensitive)

		def StringFirstBoundZCS(pCaseSensitive)
			return This.FirstBoundZCS(pCaseSensitive)

		def StringFirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZ()
		return This.FirstBoundZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFirstBoundZ()
			return This.FirstBoundZ()

		def StringFirstBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def FirstBoundZZCS(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundZZCS(pCaseSensitive)

		def StringFirstBoundZZCS(pCaseSensitive)
			return THis.FirstBoundZZCS(pCaseSensitive)

		def StringFirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZZ()
		return This.FirstBoundZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFirstBoundZZ()
			return THis.FirstBoundZZ()

		def StringFirstBoundAndItsSection()
			return THis.FirstBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING  #
	#========================================#

	def FindLastBoundCS(pCaseSensitive)
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			return This.NumberOfChars() - n + 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindStringLastBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindStringSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBound()
		return This.FindLastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBound()
			return This.FindLastBound()

		def FindSecondBound()
			return This.FindLastBound()

		def FindStringSecondBound()
			return This.FindLastBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			nLen = This.NumberOfChars()
			anResult + (nLen - n + 1) + nLen
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBoundAsSection()
		return This.FindLastBoundAsSectionCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING  #
	#----------------------------------------#

	def LastBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[2]
		return cResult

		#< @FunctionAlternativeForms

		def StringLastBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def SecondBoundCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def StringSecondBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBound()
		return This.LastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def StringLastBounds()
			return This.LastBound()

		def SecondBound()
			return This.LastBound()

		def StringSecondBounds()
			return This.LastBound()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LastBoundZCS(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundZCS(pCaseSensitive)
			return This.LastBoundZCS(pCaseSensitive)

		def LastBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundZCS(pCaseSensitive)

		def SecondBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZ()
		return This.LastBoundZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZ()
			return This.LastBoundZ()

		def LastBoundAndItsPosition()
			return This.LastBoundZ()

		def SecondBoundAndItsPosition()
			return This.LastBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LastBoundZZCS(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundZZCS(pCaseSensitive)
			return This.LastBoundZZCS(pCaseSensitive)

		def LastBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundZZCS(pCaseSensitive)

		def SecondBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZZ()
		return This.LastBoundZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZZ()
			return This.LastBoundZZ()

		def LastBoundAndItsSection()
			return This.LastBoundZZ()

		def SecondBoundAndItsSection()
			return This.LastBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING  #
	#========================================#

	def FindLeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundCS(pCaseSensitive)
		ok


		def FindStringLeftBoundCS(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindLeftBound()
		return This.FindLeftBoundCS(:CaseSensitive = TRUE)


		def FindStringLeftBound()
			return This.FindLeftBound()

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLeftBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)
		ok


		def FindStringLeftBoundAsSectionCS(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBoundAsSection()
		return This.FindLeftBoundAsSectionCS(:CaseSensitive = TRUE)


		def FindStringLeftBoundAsSection()
			return This.FindLeftBoundAsSection()

	  #----------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING  #
	#----------------------------------------#

	def LeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[1]

		else # case IsRightToLeft()
			return This.BoundsCS(pCaseSensitive)[2]
		ok


		def StringLeftBoundCS(pCaseSensitive)
			return This.LeftBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftBound()
		return This.LeftBoundCS(:CaseSensitive = TRUE)

		def StringLeftBound()
			return This.LeftBound()

	  #----------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LeftBoundZCS(pCaseSensitive)
		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPositionCS(pCaseSensitive)
			return This.LeftBoundZCS(pCaseSensitive)

		def StringLeftBoundZCS(pCaseSensitive)
			return This.LeftBoundZCS(pCaseSensitive)

		def StringLeftBoundAbdItsPositionCS(pCaseSensitive)
			return This.LeftBoundZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZ()
		return This.LeftBoundZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPosition()
			return This.LeftBoundZ()

		def StringLeftBoundZ()
			return This.LeftBoundZ()

		def StringLeftBoundAbdItsPosition()
			return This.LeftBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LeftBoundZZCS(pCaseSensitive)

		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSectionCS(pCaseSensitive)
			return This.LeftBoundZZCS(pCaseSensitive)

		def StringLeftBoundZZCS(pCaseSensitive)
			return This.LeftBoundZZCS(pCaseSensitive)

		def StringLeftBoundAbdItsSectionCS(pCaseSensitive)
			return This.LeftBoundZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZZ()
		return This.LeftBoundZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSection()
			return This.LeftBoundZZ()

		def StringLeftBoundZZ()
			return This.LeftBoundZZ()

		def StringLeftBoundAbdItsSection()
			return This.LeftBoundZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING  #
	#=========================================#

	def FindRightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundCS(pCaseSensitive)
		ok


		def FindStringRightBoundCS(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRightBound()
		return This.FindRightBoundCS(:CaseSensitive = TRUE)

		def FindStringRightBound()
			return This.FindRightBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindRightBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)
		ok


		def FindStringRightBoundAsSectionCS(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindRightBoundAsSection()
		return This.FindRightBoundAsSectionCS(:CaseSensitive = TRUE)


		def FindStringRightBoundAsSection()
			return This.FindRightBoundAsSection()

	  #-----------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING  #
	#-----------------------------------------#

	def RightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[2]

		else # case IsRightToRight()
			return This.BoundsCS(pCaseSensitive)[1]
		ok

		def StringRightBoundCS(pCaseSensitive)
			return This.RightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightBound()
		return This.RightBoundCS(:CaseSensitive = TRUE)

		def StringRightBound()
			return This.RightBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def RightBoundZCS(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundZCS(pCaseSensitive)

		def StringRightBoundZCS(pCaseSensitive)
			return This.RightBoundZCS(pCaseSensitive)

		def StringRightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZ()
		return This.RightBoundZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsPosition()
			return This.RightBoundZ()

		def StringRightBoundZ()
			return This.RightBoundZ()

		def StringRightBoundAndItsPosition()
			return This.RightBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def RightBoundZZCS(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundZZCS(pCaseSensitive)

		def StringRightBoundZZCS(pCaseSensitive)
			return This.RightBoundZZCS(pCaseSensitive)

		def StringRightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZZ()
		return This.RightBoundZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsSection()
			return This.RightBoundZZ()

		def StringRightBoundZZ()
			return This.RightBoundZZ()

		def StringRightBoundAndItsSection()
			return This.RightBoundZZ()

		#>

	  #-------------------------------------#
	 #  REMOVING BOUNDS OF THE THE STRING  #
	#=====================================#

	def RemoveStringBoundsCS(pCaseSensitive)

		if This.IsBoundedCS(pCaseSensitive)
			aSections = This.FindStringBoundsAsSectionsCS(pCaseSensitive)
			This.RemoveSections(aSections)
		ok

		#< @FunctionFluentForm

		def RemoveStringBoundsCSQ(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveBoundsCSQ(pCaseSensitive)
				This.RemoveBoundsCS(pCaseSensitive)
				return This
	
		#--

		def RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveStringFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndSecondBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#>

	def StringBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveStringBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringFirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringFirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)


		#--

		def StringLastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringSecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def SecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringRightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def RightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringBounds()
		return This.RemoveStringBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringBoundsQ()
			This.RemoveStringBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBounds()
			This.RemoveStringBounds()

			def RemoveBoundsQ()
				This.RemoveBounds()
				return This
	
		#--

		def RemoveStringFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndLastBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		def RemoveStringFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndSecondBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		#--

		def RemoveFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndLastBoundsQ()
				This.RemoveFirstAndLastBounds()
				return This

		def RemoveFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndSecondBoundsQ()
				This.RemoveFirstAndSecondBounds()
				return This

		#--

		def RemoveStringLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringLastAndFirstBoundsQ()
				This.RemoveStringLastAndFirstBounds()
				return This

		def RemoveStringSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringSecondAndFirstBoundsQ()
				This.RemoveStringSecondAndFirstBounds()
				return This

		#--

		def RemoveLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveLastAndFirstBoundsQ()
				This.RemoveLastAndFirstBounds()
				return This

		def RemoveSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveSecondAndFirstBoundsQ()
				This.RemoveSecondAndFirstBounds()
				return This

		#--

		def RemoveStringLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveStringLeftAndRightBoundsQ()
				This.RemoveStringLeftAndRightBounds()
				return This

		#--

		def RemoveLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveLeftAndRightBoundsQ()
				This.RemoveLeftAndRightBounds()
				return This

		#--

		def RemoveStringRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveStringRightAndLeftBoundsQ()
				This.RemoveStringRightAndLeftBounds()
				return This

		#--

		def RemoveRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveRightAndLeftBoundsQ()
				This.RemoveRightAndLeftBounds()
				return This

		#>

	def StringBoundsRemoved()
		cResult = This.Copy().RemoveStringBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringFirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringFirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()


		#--

		def StringLastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def LastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringSecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def SecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		def LeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringRightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		def RightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		#>

	  #--------------------------------------#
	 #  REMOVING LEFT BOUND OF THE STRING   #
	#======================================#

	def RemoveStringLeftBoundCS(pCaseSensitive)
	
		cBounds = This.LeftBoundCS(pCaseSensitive)
		This.RemoveFromLeftCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundCSQ(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundCS(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)

			def RemoveLeftBoundCSQ(pCaseSensitive)
				This.RemoveLeftBoundCS(pCaseSensitive)
				return This

		#>

	def StringLeftBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pCaseSensitive).Content()
		return cResult

		def LeftBoundRemovedCS(pCaseSensitive)
			return This.StringLeftBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLeftBound()
		This.RemoveStringLeftBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundQ()
			This.RemoveStringLeftBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBound()
			This.RemoveStringLeftBound()

			def RemoveLeftBoundQ()
				This.RemoveLeftBound()
				return This

		#>

	def StringLeftBoundRemoved()
		cResult = This.Copy().RemoveStringLeftBoundQ().Content()
		return cResult

		def LeftBoundRemoved()
			return This.StringLeftBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringRightBoundCS(pCaseSensitive)
	
		cBounds = This.RightBoundCS(pCaseSensitive)
		This.RemoveFromRightCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringRightBoundCSQ(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundCS(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)

			def RemoveRightBoundCSQ(pCaseSensitive)
				This.RemoveRightBoundCS(pCaseSensitive)
				return This

		#>

	def StringRightBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pCaseSensitive).Content()
		return cResult

		def RightBoundRemovedCS(pCaseSensitive)
			return This.StringRightBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringRightBound()
		This.RemoveStringRightBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringRightBoundQ()
			This.RemoveStringRightBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBound()
			This.RemoveStringRightBound()

			def RemoveRightBoundQ()
				This.RemoveRightBound()
				return This

		#>

	def StringRightBoundRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundQ().Content()
		return cResult

		def RightBoundRemoved()
			return This.StringRightBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING FIRST BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringFirstBoundCS(pCaseSensitive)
	
		cBounds = This.FirstBoundCS(pCaseSensitive)
		This.RemoveFromStartCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundCSQ(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundCS(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)

			def RemoveFirstBoundCSQ(pCaseSensitive)
				This.RemoveFirstBoundCS(pCaseSensitive)
				return This

		#>

	def StringFirstBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pCaseSensitive).Content()
		return cResult

		def FirstBoundRemovedCS(pCaseSensitive)
			return This.StringFirstBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringFirstBound()
		This.RemoveStringFirstBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundQ()
			This.RemoveStringFirstBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBound()
			This.RemoveStringFirstBound()

			def RemoveFirstBoundQ()
				This.RemoveFirstBound()
				return This

		#>

	def StringFirstBoundRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundQ().Content()
		return cResult

		def FirstBoundRemoved()
			return This.StringFirstBoundRemoved()

	  #--------------------------------------#
	 #  REMOVING LAST BOUND OF THE STRING   #
	#--------------------------------------#

	def RemoveStringLastBoundCS(pCaseSensitive)
	
		cBounds = This.LastBoundCS(pCaseSensitive)
		This.RemoveFromEndCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLastBoundCSQ(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveLastBoundCSQ(pCaseSensitive)
				This.RemoveLastBoundCS(pCaseSensitive)
				return This


		def RemoveStringSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveStringSecondBoundCSQ(pCaseSensitive)
				This.RemoveStringSecondBoundCS(pCaseSensitive)
				return This

		def RemoveSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveSecondBoundCSQ(pCaseSensitive)
				This.RemoveSecondBoundCS(pCaseSensitive)
				return This

		#>

	def StringLastBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def StringSecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def SecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLastBound()
		This.RemoveStringLastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringLastBoundQ()
			This.RemoveStringLastBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBound()
			This.RemoveStringLastBound()

			def RemoveLastBoundQ()
				This.RemoveLastBound()
				return This


		def RemoveStringSecondBound()
			This.RemoveStringLastBound()

			def RemoveStringSecondBoundQ()
				This.RemoveStringSecondBound()
				return This

		def RemoveSecondBound()
			This.RemoveStringLastBound()

			def RemoveSecondBoundQ()
				This.RemoveSecondBound()
				return This

		#>

	def StringLastBoundRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemoved()
			return This.StringLastBoundRemoved()

		def StringSecondBoundRemoved()
			return This.StringLastBoundRemoved()

		def SecondBoundRemoved()
			return This.StringLastBoundRemoved()

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE THE STRING AND RETURNING THEIR SECTIONS  #
	#========================================================================================#

	def FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsZZCS(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1][2]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2][2]
		ok

		return aResult

		def FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseStringBoundsAsSections(pcBound1, pcBound2)
		return This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindTheseBoundsAsSections(pcBound1, pcBound2)
			return This.FindTheseStringBoundsAsSections(pcBound1, pcBound2)

	  #----------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE THE STRING AND RETURNING THEIR SECTIONS  #
	#========================================================================================#

	def FindTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsZCS(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1][2]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2][2]
		ok

		return aResult

		def FindTheseBoundsAsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseStringBounds(pcBound1, pcBound2)
		return This.FindTheseStringBoundsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindTheseBounds(pcBound1, pcBound2)
			return This.FindTheseStringBounds(pcBound1, pcBound2)

	  #---------------------------------------------------------------------------------#
	 #  GETTING THE GIVEN TWO BOUNDS (IF ANY) OF THE THE STRING ALONG THEIR POSITIONS  #
	#---------------------------------------------------------------------------------#

	def TheseStringBoundsZCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsZCS(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult +aBounds[2]
		ok

		return aResult

		def TheseBoundsZCS(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsZCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseStringBoundsZ(pcBound1, pcBound2)
		return This.TheseStringBoundsZCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def TheseBoundsZ(pcBound1, pcBound2)
			return This.TheseStringBoundsZ(pcBound1, pcBound2)

	  #--------------------------------------------------------------------------------#
	 #  GETTING THE GIVEN TWO BOUNDS (IF ANY) OF THE THE STRING ALONG THEIR SECTIONS  #
	#--------------------------------------------------------------------------------#

	def TheseStringBoundsZZCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsZZCS(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2]
		ok

		return aResult

		def TheseBoundsZZCS(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsZZCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseStringBoundsZZ(pcBound1, pcBound2)
		return This.TheseStringBoundsZZCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def TheseBoundsZZ(pcBound1, pcBound2)
			return This.TheseStringBoundsZZ(pcBound1, pcBound2)


	  #------------------------------------------------------------#
	 #  REMOVING THE GIVEN TWO BOUNDS (IF ANY) IN THE THE STRING  #
	#============================================================#

	def RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveTheseStringBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

			def RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
				This.RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
				return This

		#>

	def TheseStringBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseStringBoundsCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def TheseBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseStringBounds(pcBound1, pcBound2)
		return This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveTheseStringBoundsQ(pcBound1, pcBound2)
			This.RemoveTheseStringBounds(pcBound1, pcBound2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveTheseBounds(pcBound1, pcBound2)
			This.RemoveTheseStringBounds(pcBound1, pcBound2)

			def RemoveTheseBoundsQ(pcBound1, pcBound2)
				This.RemoveTheseBounds(pcBound1, pcBound2)
				return This

		#>

	def TheseStringBoundsRemoved(pcBound1, pcBound2)
		cResult = This.Copy().RemoveTheseStringBoundsQ(pcBound1, pcBound2).Content()
		return cResult

		#< @FunctionAlternativeForm

		def TheseBoundsRemoved(pcBound1, pcBound2)
			return This.TheseStringBoundsRemoved(pcBound1, pcBound2)

		#>

	  #-------------------------------------#
	 #  SWAPPING BOUNDS OF THE THE STRING  #
	#=====================================#

	def SwapBoundsCS(pCaseSensitive)
		aSections = This.FindBoundsAsSectionsCS(pCaseSensitive)
		This.SwapSections( aSections[1], aSections[2] )

		#< @FunctionFluentForm

		def SwapBoundsCSQ(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBoundsCS(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)

			def SwapStringBoundsCSQ(pCaseSensitive)
				This.SwapStringBoundsCS(pCaseSensitive)
				return This

		#>

	def BoundsSwappedCS(pCaseSensitive)
		cResult = This.Copy(). SwapBoundsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SwapBounds()
		return This.SwapBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SwapBoundsQ()
			This.SwapBounds()
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBounds()
			This.SwapBounds()

			def SwapStringBoundsQ()
				This.SwapStringBounds()
				return This

		#>

	def BoundsSwapped()
		cResult = This.Copy(). SwapBoundsQ().Content()
		return cResult

		def StringBoundsSwapped()
			return This.BoundsSwapped()


	  #=========================================================#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

			#--

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		def FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSections()
		return This.FindSubStringBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindBoundsOfAsSections()
			return This.FindSubStringBoundsAsSections()

	  #---------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------#

	def FindSubStringBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		def FindBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBounds(pcSubStr)
		return This.FindSubStringBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindBoundsOf(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS BOUNDS OF A GIVEN SUBSTRING  #
	#---------------------------------------------------------------#

	def ContainsBoundsOfCS(pcSubStr, pCaseSensitive)
		if len( This.BoundsOfCS(pcSubStr, pCaseSensitive) ) > 0
			return TRUE

		else
			return FALSE
		ok

		def SubStringIsBoundedCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

		def SubStringHasBoundsCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundsOf(pcSubStr)
		return This.ContainsBoundsOfCS(pcSubStr, :CaseSensitive = TRUE)

		def SubStringIsBounded(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

		def SubStringHasBounds(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringFirstBoundsAsSections()
		return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSections()
			return This.FindSubStringFirstBoundsAsSections()

		def FindFirstBoundsAsSections()
			return This.FindSubStringFirstBoundsAsSections()

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLastBoundsAsSections(pcSubStr)
		return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLeftBoundsAsSections(pcSubStr)
		return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringRightBoundsAsSections(pcSubStr)
		return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		def FindRightBoundsAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringFirstBounds(pcSubStr)
		return This.FindSubStringFirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOf(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBounds(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForsm

		def FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLastBounds(pcSubStr)
		return This.FindSubStringLastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForsm

		def FindLastBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLeftBounds(pcSubStr)
		return This.FindSubStringLeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOf(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBounds(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringRightBounds(pcSubStr)
		return This.FindRightBoundsOfCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOf(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBounds(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def SubStringBoundsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<Ring>>, the beautiful ((Ring))!")
		? o1.BoundsOf("Ring")
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def BoundsOfCS(pcsubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

		def SubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBounds(pcSubstr)
		return This.SubStringBoundsCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsOf(pcsubStr)
			return This.SubStringBounds(pcSubStr)

		#--

		def SubStringFirstAndLastBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

		def SubStringFirstAndSecondBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

		def FirstAndLastBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

		def FirstAndSecondBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE FIRST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#-------------------------------------------------------------#

	def SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		def FirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringFirstBounds(pcSubStr)
		return This.SubStringFirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def FirstBoundsOf(pcSubStr)
			return This.SubStringFirstBounds(pcSubStr)

	  #------------------------------------------------------------#
	 #  GETTING THE LAST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#------------------------------------------------------------#

	def SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def LastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringLastBounds(pcSubStr)
		return This.SubStringLastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LastBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SubStringSecondBounds(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SecondBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		def LeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SubStringLeftBounds(pcSubStr)
		return This.SubStringLeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def LeftBoundsOf(pcSubStr)
			return This.SubStringLeftBounds(pcSubStr)

	  #------------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUNDS OF A GIVEN SUBSTRIG INSIDE THE STRING  #
	#------------------------------------------------------------------#

	def SubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		def RightBoundsOfCS(pcsubStr, pCaseSensitive)
			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SubStringRightBounds(pcSubStr)
		return This.SubStringRightBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def RightBoundsOf(pcsubStr)
			return This.SubStringRightBounds(pcSubStr)

	  #=======================================================#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=======================================================#

	def RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetween(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)


	def AnyBetweenRemoved(pcBound1, pcBound2)
		acResult = This.Copy().RemoveAnyBetweenCSQ(pcBound1, pcBound2).Content()
		return acResult

	  #-------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#-------------------------------------------------------------------#
	#--> Bounds are also removed (TODO: Generalise this feature)

	def RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveAnyBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetweenIB(pcBound1, pcBound2)
		return This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

	def AnyBetweenRemovedIB(pcBound1, pcBound2)
		acResult = This.Copy().RemoveBetweenIBQ(pcBound1, pcBound2).Content()
		return acResult

	  #============================================================#
	 #     REMOVING LEFT BOUND OF A SUBSTRING FROM THE STRING     #
	#============================================================#

	def RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.LeftNChars( nLenSubStr ) = pcSubStr
			This.ReplaceFirstOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			return This
		#>


		#< @FunctionAlternativeForms

		def RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBound(pcSubStr)
		This.RemoveSubStringLeftBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundQ(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveLeftBoundOfQ(pcSubStr)
				This.RemoveLeftBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLeftBound(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachSubStringLeftBoundQ(pcSubStr)
				This.RemoveEachSubStringLeftBound(pcSubStr)
				return This

		def RemoveEachLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachLeftBoundOfQ(pcSubStr)
				This.RemoveEachLeftBoundOf(pcSubStr)
				return This

		#>

	def SubStringLeftBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLeftBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemoved(pcSubStr)
			return This.SubStringLeftBoundRemoved(pcSubStr)

		#>

	  #--------------------------------------------#
	 #    REMOVING RIGHT BOUND FROM THE STRING    #
	#--------------------------------------------#

	def RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.RightNChars( nLenSubStr ) = pcSubStr
			This.ReplaceLastOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringrightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult


		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBound(pcSubStr)
		This.RemoveSubStringRightBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundQ(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOf(pcSubStr)
			This.RemoveSubStringrightBound(pcSubStr)

			def RemoveRightBoundOfQ(pcSubStr)
				This.RemoveRightBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringRightBound(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachSubStringRightBoundQ(pcSubStr)
				This.RemoveEachSubStringRightBound(pcSubStr)
				return This

		def RemoveEachRightBoundOf(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachRightBoundOfQ(pcSubStr)
				This.RemoveEachRightBoundOf(pcSubStr)
				return This

		#>

	def RightSubStringBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringRightBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemoved(pcSubStr)
			return This.SubStringRightBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   REMOVING FIRST BOUND FROM THE STRING    #
	#-------------------------------------------#

	def RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() than...
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm
	
		def RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBound(pcSubStr)
		This.RemoveSubStringFirstBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveFirstBoundOfQ(pcSubStr)
				This.RemoveFirstBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringFirstBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringFirstBoundQ(pcSubStr)
				This.RemoveEachSubStringFirstBound(pcSubStr)
				return This

		def RemoveEachFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveEachFirstBoundOfQ(pcSubStr)
				This.RemoveEachFirstBoundOf(pcSubStr)
				return This

		#>


	def SubStringFirstBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringFirstBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemoved(pcSubStr)
			return This.SubStringFirstBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REMOVING EACH LAST BOUND OF A SUBSTRING FROM THE STRING   #
	#-------------------------------------------------------------#

	def RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() then...
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def EachSubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBound(pcSubStr)
		This.RemoveSubStringLastBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveLastBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSecondBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSubStringSecondBoundQ(pcSubStr)
				This.RemoveSubStringSecondBound(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLastBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringLastBoundQ(pcSubStr)
				This.RemoveEachSubStringLastBound(pcSubStr)
				return This

		def RemoveEachLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachLastBoundOfQ(pcSubStr)
				This.RemoveEachLastBoundOf(pcSubStr)
				return This

		def RemoveEachSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSecondBoundOfQ(pcSubStr)
				This.RemoveEachSecondBoundOf(pcSubStr)
				return This

		def RemoveEachSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringSecondBoundQ(pcSubStr)
				This.RemoveEachSubStringSecondBound(pcSubStr)
				return This

		#>

	def SubStringLastBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLastBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def SubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def EachSubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CHECKING OF THE STRING CONTAINS THE GIVEN BOUNDS   #
	#------------------------------------------------------#

	def ContainsTheseBoundsCS(pacBounds, pCaseSensitive)
		if NOT ( isList(pacBounds) and Q(pacBounds).IsAPairOfStrings() )
			StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
		ok

		if (NOT This.ContainsCS(pacBounds[1])) or
		   (NOT This.ContainsCS(pacBounds[2]))

			return FALSE
		ok

		n1 = This.FindFirstCS(pacBounds[1])
		n2 = This.FindFirstCS(pacBounds[2])

		if n1 < n2
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseBounds(pacBounds)
		return This.ContainsTheseBoundsCS(pacBounds, :CaseSensitive = TRUE)


	  #------------------------------------------------------------------------#
	 #   ADDING BOUNDS TO THE OCCURRENCES OF A SUBSTRING INSIDE THE STRING    #
	#------------------------------------------------------------------------#

	def AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		anSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed()
	
		for aSection in anSections
			n1 = aSection[1]
			n2 = aSection[2]

			nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

			if n2 < This.NumberOfChars() and
			   This.Section(n2 + 1, n2 + nLenBound2) != pcBound2

				This.InsertAfter(n2, pcBound2)
			ok

			nLenBound1 = StzStringQ(pcBound1).NumberOfChars()

			if n1 > 1 and
			   This.Section(n1 - nLenBound1, n1 - 1) != pcBound1

				This.InsertBefore(n1, pcBound1)
			ok
		next

		#< @FunctionFluentForm

		def AddBoundsToSubStringCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddTheseBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			def AddTheseBoundsToSubStringCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.AddTheseBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def BoundSubStringWithCS(pcSubStr,  pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			def BoundSubStringWithCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.BoundSubStringWithCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)
		This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AddBoundsToSubStringQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddTheseBoundsToSubString(pcSubStr, pcBound1, pcBound2)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)

			def AddTheseBoundsToSubStringQ(pcSubStr, pcBound1, pcBound2)
				This.AddTheseBoundsToSubString(pcSubStr, pcBound1, pcBound2)
				return This

		def BoundSubStringWith(pcSubStr,  pcBound1, pcBound2)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)

			def BoundSubStringWithQ(pcSubStr, pcBound1, pcBound2)
				This.BoundSubStringWith(pcSubStr, pcBound1, pcBound2)
				return This

		#>

	  #---------------------------------------------------------#
	 #   ADDING BOUNDS TO MANYS SUBSTRINGS AT THE SAME TIME    #
	#---------------------------------------------------------#

	def AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.AddBoundsToSubStringCS(pacSubStr[i], pcBound1, pcBound2, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def AddBoundsToManySubStringsCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddBoundsToSubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def AddBoundsToSubStringsCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.AddBoundsToSubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def BoundManySubStringsWithCS(pacSubStr,  pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def BoundManySubStringsWithCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.BoundManySubStringsWithCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def BoundSubStringsWithCS(pacSubStr,  pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def BoundSubStringsWithCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.BoundSubStringsWithCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)
		This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AddBoundsToManySubStringsQ(pacSubStr, pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddBoundsToSubStrings(pacSubStr, pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def AddBoundsToSubStringsQ(pacSubStr, pcBound1, pcBound2)
				This.AddBoundsToSubStrings(pacSubStr, pcBound1, pcBound2)
				return This

		def BoundManySubStringsWith(pacSubStr,  pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def BoundManySubStringsWithQ(pacSubStr, pcBound1, pcBound2)
				This.BoundManySubStringsWith(pacSubStr, pcBound1, pcBound2)
				return This

		def BoundSubStringsWith(pacSubStr,  pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def BoundSubStringsWithQ(pacSubStr, pcBound1, pcBound2)
				This.BoundSubStringsWith(pacSubStr, pcBound1, pcBound2)
				return This

		#>

	  #============================#
	 #   REPEATED LEADING CHARS   #
	#============================#

	def RepeatedLeadingCharsCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> 'eee'
			'exeeeeeTUNIS' 	--> ''
		*/

		if This.IsEmpty()
			return ""
		ok

		nLen = This.NumberOfChars()
		# TODO: Check wether the ...CS() extension is needed here!

		cResult = ""
	
		bContinue = TRUE
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = FALSE
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = FALSE
			ok

		end

		if i > 2
			return This.NFirstChars(i-1)
		ok

		#< @FunctionFluentForm

		def RepeatedLeadingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedLeadingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingRepeatedCharsCSQ(pCaseSensitive)
				return new stzList( This.LeadingRepeatedCharsCS(pCaseSensitive) )
	
		def LeadingCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingCharsCSQ(pCaseSensitive)
				return new stzList( This.LeadingCharsCS(pCaseSensitive) )
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChars()
		return This.RepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsQ()
			return new stzList( This.RepeatedLeadingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChars()
			return This.RepeatedLeadingChars()

			def LeadingRepeatedCharsQ()
				return new stzList( This.LeadingRepeatedChars() )
	
		def LeadingChars()
			return This.RepeatedLeadingChars()

			def LeadingCharsQ()
				return new stzList( This.LeadingChars() )
	
		#>

	  #-----------------------------------------------------#
	 #  GETTING THE REPEATED LEADING CHARS AS A SUBSTRING  #
	#-----------------------------------------------------#

	def RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)
		acChars = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = len(acChars)

		cResult = ""
		for i = 1 to nLen
			cResult += acChars[i]
		next

		return cResult


		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def LeadingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#--

		def RepeatedLeadingCharsAsStringCS(pCaseSensitive)
			This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.RepeatedLeadingCharsAsStringCS(pCaseSensitive) )

		def LeadingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def LeadingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingCharsAsSubStringCS(pCaseSensitive) )

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingCharsAsSubString()
		return This.RepeatedLeadingCharsAsSubStringCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringQ()
			return new stzString( This.RepeatedLeadingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsSubStringQ()
				return new stzString( This.LeadingRepeatedCharsAsSubString() )
	
		def LeadingCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsSubStringQ()
				return new stzString( This.LeadingCharsAsSubString() )

		#--

		def RepeatedLeadingCharsAsString()
			This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsAsStringQ()
				return new stzString( This.RepeatedLeadingCharsAsString() )

		def LeadingRepeatedCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsStringQ()
				return new stzString( This.LeadingRepeatedCharsAsSubString() )
	
		def LeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsStringQ()
				return new stzString( This.LeadingCharsAsSubString() )
	
		#>

	  #-------------------------------------#
	 #  GETTING THE REPEATED LEADING CHAR  #
	#-------------------------------------#

	def RepeatedLeadingCharCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return This[1]
		ok

		#< @FunctionFleuntForms

		def RepeatedLeadingCharCSQ(pCaseSensitive)
			return This.RepeatedLeadingCharCSQR(pCaseSensitive, :stzChar)

		def RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedLeadingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingRepeatedCharCSQ(pCaseSensitive)
				return This.LeadingRepeatedCharCSQR(pCaseSensitive, :stzChar)
	
		def LeadingCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingCharCSQ(pCaseSensitive)
				return This.LeadingCharCSQR(pCaseSensitive, :stzChar)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChar()
		return This.RepeatedLeadingCharCS(:CaseSensitive = TRUE)


		#< @FunctionFleuntForms

		def RepeatedLeadingCharQ()
			return This.RepeatedLeadingCharQR(:stzChar)

		def RepeatedLeadingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingChar())

			on :stzString
				return new stzString(This.RepeatedLeadingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChar()
			return This.RepeatedLeadingChar()

			def LeadingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingRepeatedCharQ()
				return This.LeadingRepeatedCharQR(:stzChar)
				# TODO: Should it be always :stzString by default?
				# check this beghaviour all over the library!
	
		def LeadingChar()
			return This.RepeatedLeadingChar()

			def LeadingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingCharQ()
				return This.LeadingCharQR(:stzChar)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED LEADING CHARS IN THE STRING  #
	#--------------------------------------------------------------#

	def NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0

		if This.ContainsLeadingCharsCS(pCaseSensitive)
			nResult = This.LeadingCharsCSQ(pCaseSensitive).NumberOfChars()
		ok

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def NumberOfLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
	
		def CountLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def CountLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedLeadingChars()
		return This.NumberOfRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def NumberOfLeadingChars()
			return This.NumberOfRepeatedLeadingChars()
	
		def CountLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChar()
			return This.NumberOfRepeatedLeadingChars()

		def CountLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChar()
			return This.NumberOfRepeatedLeadingChars()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED LEADING CHAR IN THE STRING  #
	#---------------------------------------------------------------------#

	def RepeatedLeadingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)

		def LeadingCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedLeadingCharIs(c)
		return This.RepeatedLeadingCharIsCS(c, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIs(c)
			return This.RepeatedLeadingCharIs(c)

		def LeadingCharIs(c)
			return This.RepeatedLeadingCharIs(c)
	
		#>

	  #----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED LEADING CHAR  #
	#----------------------------------------------------#

	def HasRepeatedLeadingCharsCS(pCaseSensitive)
		if This.RepeatedLeadingCharsCS(pCaseSensitive) != NULL
			return TRUE
		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingChars()
		return This.HasRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def HasLeadingChars()
			return This.HasRepeatedLeadingChars()

		#--

		def ContainsRepeatedLeadingChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingChars()
			return This.HasRepeatedLeadingChars()

		#>

	  #--------------------------------------------------------#
	 #   CHECKING IF THE STRING HAS REPEATED TRAILING CHARS   #
	#--------------------------------------------------------#

	def HasRepeatedTrailingCharsCS(pCaseSensitive)
		return This.Copy().ReverseCharsQ().HasRepeatedLeadingCharsCS(pCaseSensitive)

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedTrailingChars()
		return This.HasRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def HasTrailingChars()
			return This.HasRepeatedTrailingChars()

		#--

		def ContainsRepeatedTrailingChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingChars()
			return This.HasRepeatedTrailingChars()

		#>

	  #-----------------------------------------#
	 #   GETTING THE REPEATED TRAILING CHARS   #
	#-----------------------------------------#

	def RepeatedTrailingCharsCS(pCaseSensitive)
		/* Example:
			'TUNISeee' 	--> 'eee'
			'TUNISexeeeee' 	--> ''
		*/

		cResult = This.Copy().ReverseCharsQ().RepeatedLeadingCharsCS(pCaseSensitive)
		return cResult

		def RepeatedTrailingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedTrailingCharsCS(pCaseSensitive) )
	
		def TrailingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingRepeatedCharsCSQ(pCaseSensitive)
				return new stzList( This.TrailingRepeatedCharsCS(pCaseSensitive) )
	
		def TrailingCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingCharsCSQ(pCaseSensitive)
				return new stzList( This.TrailingCharsCS(pCaseSensitive) )
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChars()
		return This.RepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def RepeatedTrailingCharsQ()
			return new stzList( This.RepeatedTrailingChars() )
	
		def TrailingRepeatedChars()
			return This.RepeatedTrailingChars()

			def TrailingRepeatedCharsQ()
				return new stzList( This.TrailingRepeatedChars() )
	
		def TrailingChars()
			return This.RepeatedTrailingChars()

			def TrailingCharsQ()
				return new stzList( This.TrailingChars() )

	  #------------------------------------------------------#
	 #  GETTING THE REPEATED Trailing CHARS AS A SUBSTRING  #
	#------------------------------------------------------#

	def RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)
		acChars = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = len(acChars)

		cResult = ""
		for i = 1 to nLen
			cResult += acChars[i]
		next

		return cResult


		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def TrailingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#--

		def RepeatedTrailingCharsAsStringCS(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.RepeatedTrailingCharsAsStringCS(pCaseSensitive) )

		def TrailingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def TrailingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingCharsAsSubStringCS(pCaseSensitive) )

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharsAsSubString()
		return This.RepeatedTrailingCharsAsSubStringCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringQ()
			return new stzString( This.RepeatedTrailingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsSubStringQ()
				return new stzString( This.TrailingRepeatedCharsAsSubString() )
	
		def TrailingCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsSubStringQ()
				return new stzString( This.TrailingCharsAsSubString() )

		#--

		def RepeatedTrailingCharsAsString()
			This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsAsStringQ()
				return new stzString( This.RepeatedTrailingCharsAsString() )

		def TrailingRepeatedCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsStringQ()
				return new stzString( This.TrailingRepeatedCharsAsSubString() )
	
		def TrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsStringQ()
				return new stzString( This.TrailingCharsAsSubString() )
	
		#>

	  #----------------------------------------#
	 #   GETTING THE REPEATED TRAILING CHAR   #
	#----------------------------------------#

	def RepeatedTrailingCharCS(pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			return This[:LastChar]
		ok

		def RepeatedTrailingCharCSQ(pCaseSensitive)
			return This.RepeatedTrailingCharCSQR(pCaseSensitive, :stzString)

		def RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString(This.RepeatedTrailingChar(pCaseSensitive))

			on :stzChar
				return new stzChar(This.RepeatedTrailingCharCS(pCaseSensitive))

			other
				stzRaise("Unsupported returned type!")
			off
	
		def TrailingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingRepeatedCharCSQ(pCaseSensitive)
				return This.TrailingRepeatedCharQR(pCaseSensitive, :stzString)

			def TrailingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)
	
		def TrailingCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)

			def TrailingCharCSQ(pCaseSensitive)
				return This.TrailingCharCSQR(pCaseSensitive, :stzChar)
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChar()
		return This.RepeatedTrailingCharCS(:CaseSensitive = TRUE)

		def RepeatedTrailingCharQ()
			return This.RepeatedTrailingCharQR(:stzString)

		def RepeatedTrailingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString(This.RepeatedTrailingChar())

			on :stzChar
				return new stzChar(This.RepeatedTrailingChar())

			other
				stzRaise("Unsupported returned type!")
			off
	
		def TrailingRepeatedChar()
			return This.RepeatedTrailingChar()

			def TrailingRepeatedCharQ()
				return This.TrailingRepeatedCharQR(:stzString)

			def TrailingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

		def TrailingChar()
			return This.RepeatedTrailingChar()


			def TrailingCharQ()
				return This.TrailingCharQR(:stzString)

			def TrailingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

	  #--------------------------------------------------#
	 #   GETTING THE NUMBER OF REPEATED TRAILING CHARS  #
	#--------------------------------------------------#

	def NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		nResult = This.TrailingCharsCSQ(pCaseSensitive).NumberOfChars()
		return nResult

		def NumberOfTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def NumberOfTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedTrailingChars()
		return This.NumberOfRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def NumberOfTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def NumberOfTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

	  #------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN CHAR IS THE REPEATED TRAILING CHAR  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive) and
		   This.LastCharQ().IsEqualToCS(c, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		def TrailingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)

		def TrailingCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharIs(c)
		return This.RepeatedTrailingCharIsCS(c, :CaseSensitive = TRUE)

		def TrailingRepeatedCharIs(c)
			return This.RepeatedTrailingCharIs(c)

		def TrailingCharIs(c)
			return This.RepeatedTrailingCharIs(c)
	
	  #-----------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS  # 
	#===============================================#

	def FindRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0
		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			nResult = 1
		ok
		
		return nResult

		def FindLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingChars()
		return This.FindRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		def FindLeadingChars()
			return This.FindRepeatedLeadingChars()

	  #-----------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS AND RETURNING THEM AS SECTION  # 
	#-----------------------------------------------------------------------------#

	def FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		anResult = [ 1, n ]

		return anResult

		def FindLeadingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingCharsAsSection()
		return This.FindRepeatedLeadingCharsAsSectionCS(:CaseSensitive = TRUE)

		def FindLeadingCharsAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------#

	def RepeatedLeadingCharsZCS(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZCS(pCaseSensitive)

		def LeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZCS(pCaseSensitive)

		def LeadingCharsZCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZ()
		return This.RepeatedLeadingCharsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsZ()
			return This.RepeatedLeadingCharsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR SECTION  #
	#-----------------------------------------------------------#

	def RepeatedLeadingCharsZZCS(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZZCS(pCaseSensitive)

		def LeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZZCS(pCaseSensitive)

		def LeadingCharsZZCS(pCaseSensitive)
			return This.RepeatedLeadingCharsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZZ()
		return This.RepeatedLeadingCharsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsZZ()
			return This.RepeatedLeadingCharsZZ()

		#>

	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING CHARS   #
	#=====================================#

	def RemoveRepeatedLeadingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingCharsCSQ()
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingChars()
		This.RemoveRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedLeadingCharsQ()
			This.RemoveRepeatedLeadingChars()
			return This

		def RemoveLeadingRepeatedChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharsQ()
				This.RemoveLeadingRepeatedChars()
				return This
	
		def RemoveLeadingChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharsQ()
				This.RemoveLeadingChars()
				return This
	
	def RepeatedLeadingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingCharsQ().Content()
		return cResult

		def LeadingRepeatedCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

	  #------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS  # 
	#================================================#

	def FindRepeatedTrailingCharsCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return 0
		ok

		nLen = This.NumberOfChars()
		nResult = nLen - n + 1

		return nResult

		def FindTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingChars()
		return This.FindRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def FindTrailingChars()
			return This.FindRepeatedTrailingChars()

	  #------------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS AND RETURNING THEM AS SECTION  # 
	#------------------------------------------------------------------------------#

	def FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n = 0
			return []
		ok

		nLen = This.NumberOfChars()
		anResult = [ nLen - n + 1, nLen ]

		return anResult

		def FindTrailingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingCharsAsSection()
		return This.FindRepeatedTrailingCharsAsSectionCS(:CaseSensitive = TRUE)

		def FindTrailingCharsAsSection()
			return This.FindRepeatedTrailingCharsAsSection()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR POSITION  #
	#-------------------------------------------------------------#

	def RepeatedTrailingCharsZCS(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZCS(pCaseSensitive)

		def TrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZCS(pCaseSensitive)

		def TrailingCharsZCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZ()
		return This.RepeatedTrailingCharsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsZ()
			return This.RepeatedTrailingCharsZ()

		#>

	  #------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR SECTION  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharsZZCS(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZZCS(pCaseSensitive)

		def TrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZZCS(pCaseSensitive)

		def TrailingCharsZZCS(pCaseSensitive)
			return This.RepeatedTrailingCharsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZZ()
		return This.RepeatedTrailingCharsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsZZ()
			return This.RepeatedTrailingCharsZZ()

		#>

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING CHARS   #
	#======================================#

	def RemoveRepeatedTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedTrailingCharsCSQ()
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharsCSQ(pCaseSensitive)
				This.RemoveTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def TrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingChars()
		This.RemoveRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedTrailingCharsQ()
			This.RemoveRepeatedTrailingChars()
			return This

		def RemoveTrailingRepeatedChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharsQ()
				This.RemoveTrailingRepeatedChars()
				return This
	
		def RemoveTrailingChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharsQ()
				This.RemoveTrailingChars()
				return This
	
	def RepeatedTrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedTrailingCharsQ().Content()
		return cResult

		def TrailingRepeatedCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

////////////////////////////////////////////////////////////////////////////////	

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING AND TRAILING CHARS  # 
	#============================================================#

	def FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfChars() - n + 1
		ok
		
		anResult = [ n1, n2 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingChars()
		return This.FindRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingChars()
			return This.FindRepeatedLeadingAndTrailingChars()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING AND LEADING CHARS  # 
	#============================================================#

	def FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfCharsCS(pCaseSensitive) - n + 1
		ok

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok
		
		anResult = [ n2, n1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingChars()
		return This.FindRepeatedTrailingAndLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingChars()
			return This.FindRepeatedTrailingAndLeadingChars()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED LEADING AND TRAILING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok
		
		# Composing the result

		aResult = [ [ nLead1, nLead2], [ nTrail1, nTrail2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingCharsAsSections()
		return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsAsSections()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED TRAILING AND LEADING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok
		
		# Composing the result

		aResult = [ [ nTrail1, nTrail2], [ nLead1, nLead2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingCharsAsSections()
		return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsAsSections()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED LEADING AND TRAILING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedLeadingAndTrailingCharsZCS(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingAndTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsZCS(pCaseSensitive)

		def LeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsZCS(pCaseSensitive)

		def LeadingAndTrailingCharsZCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingAndTrailingCharsZ()
		return This.RepeatedLeadingAndTrailingCharsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsZ()
			return This.RepeatedLeadingAndTrailingCharsZ()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsZCS(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsZCS(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsZCS(pCaseSensitive)

		def TrailingAndLeadingCharsZCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZ()
		return This.RepeatedTrailingAndLeadingCharsZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsZ()
			return This.RepeatedTrailingAndLeadingCharsZ()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsZZCS(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsZZCS(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsZZCS(pCaseSensitive)

		def TrailingAndLeadingCharsZZCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsZZCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZZ()
		return This.RepeatedTrailingAndLeadingCharsZZCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsZZ()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		#>

//////////////////////////////////////////////////////////////////
	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING CHARS   #
	#==================================================#

	def RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingAndTrailingCharsCSQ()
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)

		def LeadingAndTrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingAndTrailingChars()
		This.RemoveRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedLeadingAndTrailingCharsQ()
			This.RemoveRepeatedLeadingAndTrailingChars()
			return This

		def RemoveLeadingAndTrailingRepeatedChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingRepeatedCharsQ()
				This.RemoveLeadingAndTrailingRepeatedChars()
				return This
	
		def RemoveLeadingAndTrailingChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingCharsQ()
				This.RemoveLeadingAndTrailingChars()
				return This
	
	def RepeatedLeadingAndrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsQ().Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

		def LeadingAndTrailingCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS REPEATED CHARS  #
	#==================================================#

	def HasRepeatedCharsCS(pCaseSensitive) # TODO: Test it!
		nLen = @oQString.count()
		if nLen < 2
			return FALSE
		ok

		nResult = FALSE

		for i = 2 to nLen
			if @oQString.at(i-1) = @oQString.at(i-2)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedChars()
		return This.HasRepeatedCharsCS(:CaseSensitive = TRUE)

		def ContainsRepeatedChars()
			return This.HasRepeatedChars()

	  #---------------------------------------#
	 #  FINDING POSITIONS OF REPEATED CHARS  # TODO
	#---------------------------------------#

	def FindRepeatedCharsCS(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedChars()
		return This.FindRepeatedCharsCS(:CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  GETTING REPEATED CHARS ALONG WITH THEIR POSITIONS  # TODO
	#-----------------------------------------------------#

	def RepeatedCharsZCS(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

		def RepeatedCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedCharsZCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RepatedCharsZ()
		return This.RepeatedCharsZCS(:CaseSensitive = TRUE)

		def RepeatedCharsAndTheirPositions()
			return This.RepatedCharsZ()

	  #----------------------------------------------------#
	 #  GETTING REPEATED CHARS ALONG WITH THEIR SECTIONS  # TODO
	#----------------------------------------------------#

	def RepeatedCharsZZCS(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

		def RepeatedCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedCharsZZCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RepatedCharsZZ()
		return This.RepeatedCharsZZCS(:CaseSensitive = TRUE)

		def RepeatedCharsAndTheirSecions()
			return This.RepatedCharsZZ()

	  #-------------------------#
	 #  REMOVE REPEATED CHARS  #
	#-------------------------#

	def RemoveRepeatedCharsCS(pCaseSensitive)
		cResult = This.CharsQ().
			  RemoveDuplicatesQR(:stzListOfStrings).Concatenated()

		This.UpdateWith(cResult)

		def RemoveRepeatedCharsCSQ(pCaseSensitive)
			This.RemoveRepeatedCharsCS(pCaseSensitive)
			return This

	def RepeatedCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedCharsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedChars()
		return This.RemoveRepeatedCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedCharsQ()
			This.RemoveRepeatedChars()
			return This

	def RepeatedCharsRemoved()
		return This.RepeatedCharsRemovedCS(:CaseSensitive = TRUE)
		
	  #----------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS LEADING AND TRAILING CHARS  #
	#----------------------------------------------------------#

	def HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.HasRepeatedTrailingCharsCS(pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingAndTrailingChars()
		return This.HasRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#--

		def ContainsRepeatedLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#>

	  #--------------------------------------------#
	 #   REMOVING A GIVEN REPEATED LEADING CHAR   #
	#============================================#

	def RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingCharCS(c, pCaseSensitive)
				return This

		def RemoveRepeatedLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveRepeatedLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveRepeatedLeadingCharCS(c, pCaseSensitive)
				return This

		def RemoveLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveLeadingCharCS(c, pCaseSensitive)
				return This

	def ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisLeadingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def ThisLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def RepeatedLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

			def RepeatedLeadingCharRemovedCSQ(c, pCaseSensitive)
				This.RepeatedLeadingCharRemovedCS(c, pCaseSensitive)
				return This

		def LeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

			def LeadingCharRemovedCSQ(c, pCaseSensitive)
				This.LeadingCharRemovedCSQ(c, pCaseSensitive)
				return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedLeadingChar(c)
		if This.RepeatedLeadingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedLeadingCharCS(c, :CaseSensitive = TRUE)
		ok

		def RemoveThisRepeatedLeadingCharQ(c)
			This.RemoveThisRepeatedLeadingChar(c)
			return This

		def RemoveThisLeadingRepeatedChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingRepeatedCharQ(c)
				This.RemoveThisLeadingRepeatedChar(c)
				return This

		def RemoveThisLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingCharQ(c)
				This.RemoveThisLeadingChar(c)
				return This

		def RemoveRepeatedLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveRepeatedLeadingCharQ(c)
				This.RemoveRepeatedLeadingChar(c)
				return This

		def RemoveLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveLeadingCharQ(c)
				This.RemoveLeadingChar(c)
				return This

	def ThisRepeatedLeadingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharQ(c).Content()
		return cResult

		def ThisLeadingRepeatedCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def ThisLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def RepeatedLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def LeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

	  #---------------------------------------------#
	 #   REMOVING A GIVEN REPEATED TRAILING CHAR   #
	#---------------------------------------------#

	def RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingCharCS(c, pCaseSensitive)
				return This

		def RemoveRepeatedTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisTrailingLeadingCharCS(c, pCaseSensitive)

			def RemoveRepeatedTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveRepeatedTrailingCharCS(c, pCaseSensitive)
				return This

		def RemoveTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveTrailingCharCS(c, pCaseSensitive)
				return This

	def ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisTrailingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemoved(c, pCaseSensitive)

		def ThisTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemoved(c, pCaseSensitive)

		def RepeatedTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		def TrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedTrailingChar(c)
		if This.RepeatedTrailingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedTrailingCharCS(c, :CaseSensitive = TRUE)
		ok

		def RemoveThisRepeatedTrailingCharQ(c)
			This.RemoveThisRepeatedTrailingChar(c)
			return This

		def RemoveThisTrailingRepeatedChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingRepeatedCharQ(c)
				This.RemoveThisTrailingRepeatedChar(c)
				return This

		def RemoveThisTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingCharQ(c)
				This.RemoveThisTrailingChar(c)
				return This

		def RemoveRepeatedTrailingChar(c)
			This.RemoveThisTrailingChar(c)

			def RemoveRepeatedTrailingCharQ(c)
				This.RemoveRepeatedTrailingChar(c)
				return This

		def RemoveTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveTrailingCharQ(c)
				This.RemoveTrailingChar(c)
				return This

	def ThisRepeatedTrailingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharQ(c).Content()
		return cResult

		def ThisTrailingRepeatedCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def ThisTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def RepeatedTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def TrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

	  #--------------------------------------------------------#
	 #   REMOVING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#--------------------------------------------------------#

	def RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
		This.RemoveThisRepeatedLeadingCharCS(c1, pCaseSensitive)
		This.RemoveThisRepeatedTrailingCharCS(c2, pCaseSensitive)
		
		def RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			return This

		def RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndRepeatedCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
				return This

		def RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

		def TheseLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
		This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, :CaseSensitive = TRUE)

		def RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
			return This

		def RemoveTheseLeadingAndRepeatedChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndRepeatedCharsQ(c1, c2)
				This.RemoveTheseLeadingAndRepeatedChars(c1, c2)
				return This

		def RemoveTheseLeadingAndTrailingChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndTrailingCharsQ(c1, c2)
				This.RemoveTheseLeadingAndTrailingChars(c1, c2)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)

		def TheseLeadingAndTrailingCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
	
	  #==========================================#
	 #   REPLACING EACH REPEATED LEADING CHAR   #
	#==========================================#

	def ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("aaaAAAH RING!").
		ReplaceEachLeadingCharCS( :With = "O", :CS = TRUE)
		--> Gives: "OOOAAAH RING!"

		StzStringQ("aaaAVAR").
		ReplaceEachLeadingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "OOOOOOH RING!"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			This.ReplaceSection(
				1, n,
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.REachepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingChar(cNewSubStr)

		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingCharQ(cNewSubStr)
				This.ReplaceEachLeadingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachLeadingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedLeadingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachLeadingCharEachReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

		def EachLeadingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

	  #----------------------------------#
	 #   REPLACING EACH TRAILING CHAR   #
	#----------------------------------#

	def ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", :CS = TRUE)
		--> Gives: "RINGaaaOOO"

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "RINGOOOOOO"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n > 0
			nStart = This.NumberOfChars() - n + 1
			This.ReplaceSection(
				nStart, This.NumberOfChars(),
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedTrailingChar(cNewSubStr)

		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedTrailingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingCharQ(cNewSubStr)
				This.ReplaceEachTrailingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachTrailingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedTrailingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

		def EachTrailingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

	  #-----------------------------------------------#
	 #   REPLACING EACH LEADING AND TRAILING CHARS   #
	#-----------------------------------------------#

	def ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		#-- Char withous "s"

		def ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingandTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChars(cNewSubStr)
				return This

		#-- Char without "s"

		def ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChar(cNewSubStr)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingOrLeadingChar(cNewSubStr)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		return This.ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplace(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplace(cNewSubStr)

		def EachLeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharsReplaced()
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#>

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceFirstNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
			This. ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		def ReplaceRepeatedLeadingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)
			return This

		def ReplaceLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)

			def ReplaceLeadingCharsQ(cNewSubStr)
				This.ReplaceLeadingChars(cNewSubStr)
				return This

	def RepeatedLeadingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedLeadingCharsQ(cNewSubStr).Content()

		def LeadingCharsReplaced(cNewSubStrà
			return This.RepeatedLeadingCharReplaced(wNewSubStr)

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceLastNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This. ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedTrailingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		def ReplaceRepeatedTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)
			return This

		def ReplaceTrailingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)

			def ReplaceTrailingCharsQ(cNewSubStr)
				This.ReplaceTrailingChars(cNewSubStr)
				return This

	def RepeatedTrailingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedTrailingCharsQ(cNewSubStr).Content()

		def TrailingCharsReplaced(cNewSubStrà
			return This.RepeatedTrailingCharReplaced(wNewSubStr)

	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------#
	
	def ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingChars(cNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingRepeatedCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingRepeatedCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

	  #---------------------------------------------#
	 #   REPLACING A GIVEN REPEATED LEADING CHAR   #
	#---------------------------------------------#

	def ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if NOT This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return
		ok

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfLeadingChars()
			This.ReplaceFirstNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisLeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingChar(c, cNewSubStr)
				return This

		def ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceRepeatedLeadingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingCharQ(c, cNewSubStr)
				This.ReplaceLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceLeadingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedLeadingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def ThisLeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#>

	  #----------------------------------------------#
	 #   REPLACING A GIVEN REPEATED TRAILING CHAR   #
	#----------------------------------------------#

	def ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfTrailingChars()
			This.ReplaceLastNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisTrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingChar(c, cNewSubStr)
				return This

		def ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceRepeatedTrailingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingCharQ(c, cNewSubStr)
				This.ReplaceTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceTrailingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedTrailingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def ThisTrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#>

	  #---------------------------------------------------------#
	 #   REPLACING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------------#

	def ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
	
		This.ReplaceThisRepeatedLeadingCharCS(c1, cNewSubStr, pCaseSensitive)
		This.ReplaceThisRepeatedTrailingCharCS(c2, cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
			This.ReplaceTheseRepeatedTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

				These.ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This
		
		#>

	def TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

		These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

				These.ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
				return This

		#>

	def TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		#>

	  #===============================#
	 #     FORWARD TO END OF LINE    #
        #===============================#

	def ForwardToEndOfLine(nStart)

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		bInside = TRUE
		cResult = ""
		i = nStart - 1

		while bInside
			i++
						 
			if i = This.NumberOfChars() or
			   This.CharAtQ(i).IsLineSeparator()
			   
				bInside = FALSE

			else
				cResult += This.NthChar(i)
			ok	
		end

		return cResult

		#< @FunctionFluentForm
	
		def ForwardToEndOfLineQ(nStart)
			return new stzString( This.ForwardToEndOfLine(nStart) )
	
		#>

	  #----------------------------------#
	 #     BACKWARD TO START OF LINE    #
        #----------------------------------#

	def BackwardToStartOfLine( nStart )

		/* Example:
	
			o1 = new stzString( "Mohammed Ali
				Ben Salah" )
			? o1.BackwardToStartOfLine( :StartingAt = 16 ) #--> Ben
			
		*/

		# Enabling the :StartingAt syntax

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		# Checking the range of possible values for nStart param

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		# Computing the rest of the line

		bInside = TRUE
		cResult = ""
		i = nStart + 1

		while bInside
			i--
					 
			if i = 0 or This.CharAtQ(i).IsLineSeparator()

				bInside = FALSE
			
			else
				cResult += This.NthChar(i)
			ok
				
		end

		return StringReverse(cResult)

		#< @FunctionFluentForm

		def BackwardToStartOfLineQ( nStart )
			return new stzString( This.BackToStartOfLine( nStart ) )
	
		#>

	  #------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING   #
	#------------------------------------------------#

	// Returns a subset of the string between n1 and n2 positions
	def Section(n1, n2)

		# Managing the use of :From and :To named params

		if isList(n1) and
		   StzListQ(n1).IsOneOfTheseNamedParams([
				:From, :FromPosition,
				:StartingAt, :StartingAtPosition
				])

			n1 = n1[2]
		ok

		if isList(n2) and
		   StzListQ(n2).IsOneOfTheseNamedParams([
				:To, :ToPosition,
				:Until, :UntilPosition,
				:UpTo, :UpToPosition
				])

			n2 = n2[2]
		ok

		# Managing the use of :NthToFirst named param

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
					:NthToFirst, :NthToFirstChar ])

			n1 = n1[2] + 1
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
					:NthToFirst, :NthToFirstChar ])

			n2 = n2[2] + 1
		ok

		# Managing the use of :NthToLast named param

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
					:NthToLast, :NthToLastChar ])

			n1 = This.NumberOfChars() - n1[2]
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
					:NthToLast, :NthToLastChar ])

			n2 = This.NumberOfChars() - n2[2]

		but isList(n2) and Q(n2).IsStoppingAtNamedParam()

			n2 = n2[2]
		ok

		# Managing the case of :First and :Last keywords

		if isString(n1)
			if Q(n1).IsOneOfThese([ :First, :FirstChar ])
				n1 = 1

			but Q(n1).IsOneOfThese([ :Last, :LastChar ])
				n1 = This.NumberOfChars()

			but n1 = :@
				n1 = n2
			ok
		ok
	
		if isString(n2)
			if Q(n2).IsOneOfThese([ :Last, :LastChar, :EndOfString ])
				n2 = This.NumberOfChars()

			but Q(n2).IsOneOfThese([ :First, :FirstChar ])
				n2 = 1

			but n2 = :@
				n2 = n1
			ok
		ok

		if n1 = :@ and n2 = :@
			n1 = 1
			n2 = This.NumberOfChars()
		ok

		if n1 < 0
			n1 = This.NumberOfItems() + n1 + 1
		ok

		if n2 < 0
			n2 = This.NumberOfItems() + n2 + 1
		ok

		# If the params are not numbers, so find them and take their positions
		# EXAMPLE: ? Q("SOFTANZA").Section(:From = "F", :To = "A") #--> "FTA"

		if isString(n1)
			n1 = This.FindFirst(n1)
		ok

		if NOT isNumber(n1)
			n1 = This.FindFirst(n1)
		ok

		# Managing the case of :EndOfSentence, :EndOfLine, and :EndOfWord keywords

		if n1 > 0 and n2 = :EndOfSentence
			return This.ToStzText().ForwardToEndOfSentence( :StartingAt = n1 )
		ok

		if n1 > 0 and n2 = :EndOfLine
			return This.ForwardToEndOfLine( :StartingAt = n1 )
		ok

		if n1 > 0 and n2 = :EndOfWord # TODO: should move to stzText?
			return This.ToStzText().ForwardToEndOfWord( :StartingAt = n1 )
		ok

		if isString(n2)
			n2 = This.FindFirst(n2)
		ok

		if NOT isNumber(n2)
			n2 = This.FindFirst(n2)
		ok

		# Params must be numbers

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect params! n1 and n2 must be numbers.")
		ok

		# Managing out of range params

		if NOT 	( Q(n1).IsBetween(1, this.NumberOfChars()) and
			  Q(n2).IsBetween(1, this.NumberOfChars())
			)
			
			return NULL
		ok

		# Finally, we're ready to extract the section...
		# NOTE: when positions are given in inversed order
		#--> Revert them!

		if n1 = n2
			cResult = This.Char(n1)

		but n1 < n2
			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		else // n2 < n1
			cResult = This.Section(n2, n1)

		ok

		return cResult

		#< @FunctionFluentForm

		def SectionQ(n1, n2)
			return new stzString( This.Section(n1, n2) )

		#>

		#< @FunctionAlternativeForm

		def Slice(n1, n2)
			return This.Section(n1, n2)

			#< @FunctionFluentForm

			def SliceQ(n1, n2)
				return This.SectionQ(n1, n2)

			#>
		#>	

	  #----------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- EXTENDED  #
	#----------------------------------------------------------#

	def SectionXT(n1, n2)
		aResult = [ This.Section(n1, n2), [n1, n2] ]
		return aResult

		def SliceXT(n1, n2)
			return This.Secrion(n1, n2)

	  #-----------------------------------#
	 #   GETTING A RANGE OF THE STRING   #
	#-----------------------------------#

	// Returns a subset of the string starting from nStart and ranging over nRange Chars
	def Range(nStartPos, nRange)
		
		# Chacking params

		if isString(nStartPos)
			if nStartPos = :First or nStartPos = :FirstChar
				nStartPos = 1

			but nStartPos = :Last or nStartPos = :LastChar
				nStartPos = This.NumberOfChars()
			ok
		ok

		if NOT BothAreNumbers(nStartPos, nRange)
			StzRaise("Incorrect param type! nStartPos and nRange must be both numbers.")
		ok

		# Doing the job

		if nStartPos < 0
			nStartPos = This.NumberOfChars() + nStartPos + 1
		ok

		if nStartPos = 0 or nRange = 0
			return NULL
		ok

		cResult = ""

		if nRange > 0
			cResult = This.Section( nStartPos, nStartPos + nRange -1 )

		else
			n1 = nStartPos + nRange + 1

			if n1 > 0
				cResult = This.Section( n1, nStartPos )
			ok	
		ok

		return cResult

		#< @FunctionFluentForm

		def RangeQ(nStartPos, nRange)
			return new stzString( This.Range(nStartPos, nRange) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRange(paParams)
			
			// Default values
			nStartPos = 1
			nRange = This.NumberOfChars()

			// Reading the params
			if StzListQ(paParams).IsRangeNamedParam()
				if isNumber(paParams[ :Start ])
					nStartPos = paParams[ :Start ]
				ok

				if isNumber(paParams[ :Range ])
					nRange = paParams[ :Range ]
				ok

				return This.Range(nStartPos, nRange)
			else
				stzRaise("Incorrect params!")
			ok

		#>

		#< @FunctionInfoForm

		def infRange()
			return [
				:Syntax = "Range(pnstart, pnRange)",
				:Description = "Returns pnRange chars starting at pnStart position",
				:ReturnType = "STRING",
				:NumberOfParams = 2,
				:Params = [
					[
						:Param = "pnStart",
						:Type = "NUMBER",
						:Description = "Start position",
						:Default = 1
					],
					[
						:Param = "pnRange",
						:Type = "NUMBER",
						:Description = "Number of chars of the range",
						:Default = This.NumberOfChars()
					]
				]
			]
		#>

		#< @FunctionDefaultForm

		def dftRange()
			return This.nmdRange([ :Start = 1, :Range = This.NumberOfChars() ])

		#>

		#< @FunctionExampleForm

		def expRange()
			return 	'StzStringQ("Ring programming language").Range(6, 11)' + NL +
				'--> "programming"'

		#>

		#< @FunctionRandomForm

		def rndRange()
			nStart = random( This.NumberOfChars() )
			nRange = random( This.NumberOfChars() - nStart )

			return 	'This.Range(' + nStart + ', ' + nRange + ')' + NL +
				'--> ' + This.Range(nStart, nRange)

		#>

		#< @FunctionTestForm

		def tstRange()
			nCases = This.tstRangeXT()[ :NumberOfTestCases ]
			nSucceeded = This.tstRangeXT()[ :NumberOfSuccessfulCases ]
			nFailed = This.tstRangeXT()[ :NumberOfFailedCases ]


			if nCases = 0
				return "Failed! (" + nFailed + "/" + nCases + ")"

			but nFailed = 0
				return "SUCCESS! (" + nSucceeded + "/" + nCases + ")"
			ok

			if nSucceeded != 0
				return "FAILED! (" + nFailed + "/" + nCases + ")"
			ok

		def tstRangeXT()
			aTestCases = [
			['StzStringQ("Ringorialand").Range(9, 4)' , 'land'],
			['StzStringQ("Ringorialand").Range(1, 4)' , 'Ring'],
			['StzStringQ("Ringorialand").Range(4, 6)' , 'gorial']
			]

			aSucceeded = []
			aFailed = []
			i = 0

			for aTest in aTestCases
				i++
				cCode = "cResult = " + aTest[1]

				try
					 eval(cCode)

					if cResult = aTest[2]
						aSucceeded + i
					else
						aFailed + i
					ok
				catch
					aFailed + i
				done
			next
			
			aResult = [
				:NumberOfTestCases = len(aTestCases),
				:NumberOfSuccessfulCases = len(aSucceeded),
				:NumberOfFailedCases = len(aFailed),

				:SuccessfulCases = aSucceeded,
				:FailedCases = aFailed,

				:TestCases = aTestCases
			]

			return aResult

		#>

	  #--------------------------------------------#
	 #  GETTING A RANGEOF THE STRING -- EXTENDED  #
	#--------------------------------------------#

	def RangeXT(nStartPos, nRange)
		aResult = [ This.Range(nStartPos, nRange), [nStartPos, nRange] ]
		return aResult

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #
	#---------------------------------------#

	def Sections(paSections)

		if isString(paSections) or
			(isList(paSections) and
				(Q(paSections).IsOfNamedParam() or
					Q(paSections).IsOfSubStringNamedParam()
				)
			)

			return This.FindAsSections(paSections)
		ok

		if NOT 	( isList(paSections) and
				Q(paSections).IsListOfPairsOfNumbers()
			)

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsQ(paSections)
			return This.SectionsQR(paSections, :stzList)

		def SectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Sections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Sections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

			def ManySectionsQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySectionsQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def Slices(paSections)
			return This.Sections(paSections)

			def SlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def SlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def ManySlices(paSections)
			return This.Sections(paSections)

			def ManySlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- EXTENDED  #
	#--------------------------------------------------#

	def SectionsXT(paSections)

		aResult = []

		for aSection in paSections
			cSection = This.Section( aSection[1], aSection[2] )
			aResult + [ cSection, aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsXTQ(paSections)
			return This.SectionsXTQR(paSections, pcReturnType)

		def SectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

			def ManySectionsXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySectionsXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

			def SlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def SlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

			def ManySlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		#>

	  #----------------------------------------------------------#
	 #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def NumberOfAntiSections(paSections)
		nResult = len( StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content() )

		return nResult

		#< @FunctionAlternativeForms

		def CountAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSection(paSections)
			return This.NumberOfAntiSections(paSections)

		#>

	   #-------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND  #
	 #  RETURNING THEM AS PAIRS OF NUMBERS                         #
	#-------------------------------------------------------------#

	def FindAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
			  FindAntiSectionsQ(paSections).
			  Content()

		return aResult

		def FindAntiSectionsQ(paSections)
			return new stzList( This.FindAntiSections(paSections) )

		def AntiSectionsAsPairsOfNumbers(paSections)
			return This.FindAntiSections(paSections)

			def AntiSectionsAsPairsOfNumbersQ(paSections)
				return This.AntiSectionsAsPairsOfNumbers(paSections)

	  #----------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("ABCDEFGHIJ")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ "AB", "F", "IJ" ]
		*/

		aResult = This.Sections( This.AntiSectionsAsPairsOfNumbers(paSections) )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return This.AntiSectionsQR(paSections, pcReturnType)

		def AntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThan(paSections)
			return This.AntiSections(paSections)

			def SectionsOtherThanQ(paSections)
				return This.AntiSectionsQ(paSections)
	
			def SectionsOtherThanQR(paSections, pcReturnType)
				return This.AntiSectionsQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#---------------------------------------------------------------------#

	def AntiSectionsXT(paSections)

		aAntiSections = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content()

		aResult = This.SectionsXT( aAntiSections )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsXTQ(paSections)
			return This.AntiSectionsXTQR(paSections, pcReturnType)

		def AntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThanXT(paSections)
			return This.AntiSectionsXT(paSections)

			def SectionsOtherThanXTQ(paSections)
				return This.AntiSectionsXTQ(paSections)
	
			def SectionsOtherThanXTQR(paSections, pcReturnType)
				return This.AntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------#
	 #   GETIING NTH ANTI-SECTION OF A GIVEN SET OF SECTIONS   #
	#---------------------------------------------------------#

	def NthAntiSection(n, paSections)
		if n = :First or n = :FirstAntiSection
			n = 1
		but n = :Last or n = :LastAntiSection
			n = This.NumberOfAntiSections(paSections)
		ok

		return This.AntiSections(paSections)[n]

	def FirstAntiSection(paSections)
		return This.NthAntiSections(1, paSections)

	def LastAntiSection(paSections)
		return This.NthAntiSection(:Last, paSections)

	  #-------------------------------------------------------------------#
	 #   FINDING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#

	def FindAsSectionsAndAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
				FindAsSectionsAndAntiSectionsQ(paSections).
				Content()

		return aResult

		#< @FunctionFluentForm

		def FindAsSectionsAndAntiSectionsQ(paSections)
			return This.FindAsSectionsAndAntiSectionsQR(paSections, :stzList)

		def FindAsSectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsAndAntiSections(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#
		
	def SectionsAndAntiSections(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections( aSectionsAntiSections )

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncluding(paSections)
			return This.SectionsAndAntiSections(paSections)

			def AllSectionsIncludingQ(paSections)
				return This.SectionsAndAntiSectionsQ(paSections)
	
			def AllSectionsIncludingQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#------------------------------------------------------------------------------#
		
	def SectionsAndAntiSectionsXT(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)

		aResult = []

		for aSection in aSectionsAntiSections
			aResult + [ This.Section(aSection[1], aSection[2]), aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsXTQ(paSections)
			return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncludingXT(paSections)
			return This.SectionsAndAntiSectionsXT(paSections)

			def AllSectionsIncludingXTQ(paSections)
				return This.SectionsAndAntiSectionsXTQ(paSections)
	
			def AllSectionsIncludingXTQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------#
	 #   GENERATING ALL POSSIBLE SECTIONS BETWEEN TOW SUBSTRINGS  #
	#------------------------------------------------------------#

	def SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TAYOUBTA")
		? o1.SectionsFromTo( :From = "T", :To = "A" )
		#--> [ "TA", "TAYOUBTA", "TA" ]

		*/

		if isList(pcSubStr1) and Q(pcSubStr1).IsFromNamedParam()
			pcSubStr1 = pcSubStr1[2]
		ok

		if isList(pcSubStr2) and Q(pcSubStr2).IsToNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		anSections = []

		anPos1 = This.FindAllCS(pcSubStr1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pcSubStr2, pCaseSensitive) #--> [ 2, 8 ]

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		def AllPossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AllPossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SectionsFromTo(pcSubStr1, pcSubStr2)
		return This.SectionsFromToCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def AllPossibleSectionsFromTo(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def AllPossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSectionsFromTo(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2)

	  #--------------------------------------#
	 #   GETTING MANY RANGES OF THE STRING  #
	#--------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

	  #========================#
	 #  INSERTING SUBSTRINGS  # TODO / UNCOMPLETE
	#========================#

	def InsertXT(pcSubStr, paOptions)
		/*
		o1 = new stzString("99999999999")
		o1.InsertXT("_", [ :After, :EachNChars = 3, :Going = :Forward ])

		? o1.Content()
		#--> 99_999_999_999é

		#--

		o1 = new stzString("99999999999")
		o1.InsertXT([".", "_"], [ :Repeat, :After, :EachNChars = 2, :Going = :Forward ])

		? o1.Content()
		#--> 9_99.99_99.99_99

		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(paOptions)

			oOptions = new stzList(paOptions)

			# Case : Q("999999").InsertXT("-", :EachNChars = 2) --> 99-99-99
			if oOptions.IsOneOfTheseNamedParams([ :Step, :EachNChars ])

				This.SpacifyXT(
					:Using = pcSubStr,
					:EachNChars = paOptions[2],
					:Going = :Forward)

			# Add other cases here

				/* ... */
			ok
		ok

	def InsertBeforeEachNChars(n, pcSubStr)
		This.InsertBeforeEachNCharsXT(n, pcSubStr, :FromEndToStart)

	def InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		This.InsertXT( pcSubStr, [ :After, :EachNChars = 3, :Going = :Forward ])

	  #-------------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE OR AFTER A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def Insert(pcSubStr, pWhere)
		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pWhere)
			if Q(pWhere).IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pWhere[2], pcSubStr)
				return

			but Q(pWhere).IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pWhere[2], pcSubStr)
				return
			ok
		else
			This.InsertBefore(pWhere, pcSubStr)
		ok

		#< @FunctionFluentForm

		def InsertQ(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubString(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)

			def InserSubStringQ(pcsubStr, pWhere)
				This.InsertSubString(pcSubStr, pWhere)
				return This
		
		#>

	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE A GIVEN POSITION   #
	#----------------------------------------------------#

	/* Inserts a substring:

	 	- in a given position inside the string
	 	  Note: in this case, if nPos > NumberOfChars()
		  --> string is extended with white spaces

		- or, before the occurrence of a given substring
	*/
	 
	def InsertBefore(nPos, pcSubStr)
		if isList(nPos) and Q(nPos).IsPositionNamedParam()
			nPos = nPos[2]
		ok

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertBeforeThesePositions(nPos, pcSubStr)
			return
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		@oQString.insert(nPos-1, pcSubStr)

		# The string has changed, check constraints...
		//This.VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertBeforeQ(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBeforePosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertBeforePositionQ(nPos, pcSubStr)
				This.InsertBeforePosition(nPos, pcSubStr)
				return This

		def InsertAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)

		def InsertAtPosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtPosiitonQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)

		#>

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#--------------------------------------------------------#

	def InsertBeforeW(pcCondition, pcSubStr)
		anPositions = This.FindCharsW(pcCondition)
		This.InsertBeforeManyPositions( anPositions, pcSubStr )

		def InsertBeforeWQ(pcCondition, pcSubStr)
			This.InsertBeforeW(pcCondition, pcSubStr)
			return This

		def InsertAtW(pcCondition, pcSubStr)
			This.InsertBefore(pcCondition, pcSubStr)

			def InsertAtWQ(pcCondition, pcSubStr)
				This.InsertAtW(pcCondition, pcSubStr)
				return This

	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING AFTER A GIVEN POSITION    #
	#----------------------------------------------------#

	def InsertAfter(nPos, pcSubStr)
		#< QtBased >

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertAtPositons(anPos, pcSubStr)
		ok

		@oQString.insert(nPos, pcSubStr)

		//VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertAfterQ(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAfterPosition(nPos, pcSubStr)
			This.InsertAfer(nPos, pcSubStr)

			def InsertAfterePositionQ(nPos, pcSubStr)
				This.InsertAfterPosition(nPos, pcSubStr)
				return This

		def InsertAfterCharAtPosition(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertAfterCharAtPositionQ(nPos, pcSubStr)
				This.InsertAfterCharAtPosition(nPos, pcSubStr)
				return This

		#>

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (BEFORE) EVERY N CHARS   #
	#---------------------------------------------------#

	def InsertBeforeEveryNChars(n, pcSubStr)

		if NOT isNumber(n)
			stzRaise("Incorrect param! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPositions = []

		if n = 1
			anPositions = [ 1 ]

		else
		
			for i = 2 to This.NumberOfChars() step n
				anPositions + [ i - 1 ]
			next
		ok

		This.InsertBeforeThesePositions(anPositions, " ")

		def InsertBeforeEveryNCharsQ(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)
			return This

		def InsertEveryNChars(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)

			def InsertEveryNCharsQ(n, pcSubStr)
				This.InsertAfterEveryNChars(n, pcSubStr)
				return This
	
		def InsertSubStringEveryNChars(n, pcSubStr)
			This.InsertEveryNChars(n, pcSubStr)

			def InsertSubStringEveryNCharsQ(n, pcSubStr)
				This.InsertEveryNChars(n, pcSubStr)
				return This

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (AFTER) EVERY N CHARS    #
	#---------------------------------------------------#

	def InsertAfterEveryNChars(n, pcSubStr)

		if NOT isNumber(n)
			stzRaise("Incorrect param! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPositions = []

		if n > 1
			for i = 1 to This.NumberOfChars() - 1 step n
				anPositions + ( i + 1 )
			next
		ok

		This.InsertAfterThesePositions(anPositions, " ")

		def InsertAfterEveryNCharsQ(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)
			return This

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER A POSITION DEFINED      #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#--------------------------------------------------------#

	def InsertAfterW( pcCondition, pcSubStr )
		anPositions = This.FindCharsW(pcCondition)
		This.InsertAfterManyPositions( anPositions, pcSubStr )


		def InsertAfterWQ( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )
			return This

		def InsertAfterWhere( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )

			def InsertAfterWhereQ( pcCondition, pcSubStr )
				This.InsertAfterWhere( pcCondition, pcSubStr )
				return This

		def InserAfterEachCharW( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )

			def InserAfterEachCharWQ( pcCondition, pcSubStr )
				This.InserAfterEachCharW( pcCondition, pcSubStr )
				return This

	  #------------------------------------------------#
	 #   INSERTING A SUBSTRING AFTER MANY POSITIONS   #
	#------------------------------------------------#

	 def InsertAfterThesePositions(panPositions, pcSubStr)
		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! paPositions must be a list of numbers.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPos = ring_sort(panPositions)
		nLen = len(anPos)

		for i = nLen to 1 step -1
			This.InsertAfter(anPos[i], pcSubStr)
		next

		def InsertAfterManyPositions(panPositions, pcSubstr)
			This.InsertAfterThesePositions(panPositions, pcSubStr)

		def InsertAfterPositions(panPositions, pcSubstr)
			This.InsertAfterThesePositions(panPositions, pcSubStr)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BEFORE MANY POSITIONS   #
	#-------------------------------------------------#

	 def InsertBeforeThesePositions(panPositions, pcSubStr)

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		anPositions = StzListOfNumbersQ(panPositions).SubstractFromEachQ(1).Content()
		This.InsertAfterThesePositions(anPositions, pcSubStr)

		def InsertBeforeManyPositions(panPositions, pcSubStr)
			This.InsertBeforeThesePositions(panPositions, pcSubStr)

		def InsertBeforePositions(panPositions, pcSubStr)
			This.InsertBeforeThesePositions(panPositions, pcSubStr)

	  #-------------------------------------#
	 #    INSERTING A LIST OF SUBSTRINGS   #
	#-------------------------------------#

	// Inserts many substrings in a given position of the main string
	// by concatenating them according to a specific format
	def InsertListOfSubstringsXT( nPos, aSubStr, paOptions)
		/*
		Example:
	
		o1 = new stzString("All our software versions must be updated!")
		# Defining the position of insertion
		nPosition = o1.PositionAfterSubstring("versions") + 1
			
		# Inserting the list of string using extended configuration
		? o1.InsertListOfSubstringsXT(
			nPosition, [ "V1", "V2", "V3", "V4", "V5" ],
			
			[
			:cInsertBeforOrAfter = :Before,
			:OpeningChar = "(",
			:ClosingChar = ")", 
		
			:MainSeparator = ",",
			:AddSpaceAfterSeparator = TRUE,
			
			:LastSeparator = "and",
			:AddLastToMainSeparator = TRUE,
			
			:SpaceOption = :optEnsureLeadingSpace + :optEnsureTrailingSpace
			])
	
		Gives :
		All our software versions (V1, V2, V3, V4, and V5) must be updated!
		*/
	
		# Setting the default options
			
		cInsertBeforeOrAfter = :Before
		cOpeningChar = "("
		cClosingChar = ")"
			
		cMainSeparator = ","
		bAddSpaceAfterSeparator = TRUE
					
		cLastSeparator = NULL
		bAddLastToMainSeparator = FALSE
			
		cSpaceOption = :AddLeadingSpace + :AddTrailingSpace
	
		# Verifying the syntax of the options provided
		if NOT ( len(paOptions) = 0 or
			 ( len(paOptions) = 1 and paOptions[1] = :Default) )
	
			aPossibleOptions = [ :InsertBeforeOrAfter, :OpeningChar, :ClosingChar, :MainSeparator,
				  :AddSpaceAfterSeparator, :LastSeparator, :AddLastToMainSeparator,
				  :SpaceOption ]
		
			oHash = new stzHashList(paOptions)
			aListOfProvidedOptions = oHash.Keys()
		
			oListOfProvidedOptions = new stzList(aListOfProvidedOptions)
		
			if NOT oListOfProvidedOptions.IsMadeOfSome(aPossibleOptions)
				stzRaise(stzStringError(:UnsupportedOptionsWhileInsertingListOfStrings))
			ok
		
			# If some options are provided then we take them
			# Note : if len(paOptions) = 0 or paOptions = [ :Default ] then we preserve
			# the default options already defined
				
			cInsertBeforeOrAfter = paOptions[ :InsertBeforeOrAfter ]	
			cOpeningChar = paOptions[ :OpeningChar ]
			cClosingChar = paOptions[ :ClosingChar ]
					
			cMainSeparator = paOptions[ :MainSeparator ]
			bAddSpaceAfterSeparator = paOptions[ :AddSpaceAfterSeparator ]
		
			cLastSeparator = paOptions[ :LastSeparator ]
			bAddLastToMainSeparator = paOptions[ :AddLastToMainSeparator ]
		
			cSpaceOption = paOptions[ :SpaceOption ]
		ok
	
		# At this level, all the options are defined
		# Beginning the substring construction but the opening char
	
		cSubStr = cOpeningChar
			
		# Checking the behavior of the first inserted substring in regard of adjacent left space

		if NOT cSpaceOption = :DoNothing
			if cSpaceOption = :AddLeadingSpace or
			   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
			   cSpaceOption = :AddTrailingSpace + :AddLeadingSpace
	
				if nPos > 1 and This.NthChar(nPos - 1) != " "
					cSubStr = " " + cOpeningChar
				ok
			ok
		ok
	
		# Looping over the list of strings to concatenate them
		# depending on the logic defined by the options
	
		for i = 1 to len(aSubStr)
			# we add the string itslef
			cSubStr += aSubStr[i]
	
			# while we are not on the last item, or
			# we are on the last item but we are not asked
			# to use an alternative separator at the end
	
			if i < len(aSubStr) - 1 OR
			   (i = len(aSubStr)-1 and cLastSeparator = NULL)
	
				# Add the main separator after each string
				cSubStr += cMainSeparator
	
				# Add space after separator if required
				if bAddSpaceAfterSeparator = TRUE
						cSubstr += " "
				ok	
	
			# When reaching the last string, and an alternative
			# separator must be used (it's not null), we check
			# if we should use this last separator alone or
			# in addition to the main separator
	
			but i = len(aSubStr) - 1
	
				if bAddLastToMainSeparator = TRUE
					cSubStr += cMainSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
	
				if cLastSeparator != NULL
					cSubStr += cLastSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
			ok		
		next
	
		# Add the closing char to get the final substring
	
		cSubStr += cClosingChar
	
		# Checking the option of leaving the trailing space
	
		if cSpaceOption = :AddTrailingSpace or
		   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
		   cSpaceOption = :AddTrailiningSpace + :AddLeadingSpace
	
			cSubStr += " "
		ok
	
		if cInsertBeforeOrAfter = :After
			nPos++
		ok

		# Doing the job!

		This.InsertBefore(nPos, cSubStr)
	
		#< @FunctionFluentForm
		
		def InsertListOfSubstringsXTQ( nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)
			return This
		
		#>

	// Inserts many substrings in a given position of the main string
	def InsertListOfSubstrings(nPos, aSubStr)
		return This.InsertListOfSubstringsXT( nPos, aSubStr, [:Default] )

		#< @FunctionFluentForm

		def InsertListOfSubstringsQ(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertListOfSubstringsBeforePositions(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertListOfSubstringsBeforePositionsQ(nPos, aSubStr)
				This.InsertListOfSubstringsBeforePositions(nPos, aSubStr)
				return This

		#>
			
	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE NTH       #
	 #    OCCURRENCEOF AN EXISTANT SUBSTRING         #
	#-----------------------------------------------#

	def InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertBeforePosition( This.FindNthOccurrence(n, pcSubStr), pcNewSubStr )

	def InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrence(1, pcSubStr, pcNewSubStr)

	def InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrence(This.NumberOfOccurrence(pcSubStr), pcSubStr, pcNewSubStr)

	def InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAll(cSubStr)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ( anPos ).AddToEachQ(nLenSubStr).Content()
			aParts = This.SplitBeforePositions(anPos)
	
			cResult = StzPairOfListsQ( aParts, ListOfNTimes(len(aParts)-1, pcNewSubStr) ).AlternateQ().ToStzListOfStrings().Concatenate()
		
			This.Update( cResult )
		ok

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		def InsertBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		#>

		#< @FunctionFluentForm

		def InsertBeforeSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)
			return This
	
		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER NTH        #
	 #    OCCURRENCEOF AN EXISTANT SUBSTRING         #
	#-----------------------------------------------#

	def InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertAfterPosition( This.FindNthOccurrence(n, pcSubStr) )

	def InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterNthOccurrence(1, pcSubStr, pcNewSubStr)

	def InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrence(This.NumberOfChars(), pcSubStr, pcNewSubStr)

	def InsertAfterSubstring(pcSubStr, pcNewSubStr)
		acParts = This.Split(pcSubStr)
		cResult = ""

		for i = 1 to len(acParts)-1
			cResult += (acParts[i] + pcSubStr + pcNewSubStr)
		next

		This.Update( cResult + acParts[ len(acParts) ] )

		#< @FunctionFluentForm

		def InsertAfterSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)
			return This	
	
		#>
	
	  #=================================================#
	 #     REPLACING ALL OCCURRENCES OF A SUBSTRING    #
	#=================================================#
	
	def ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = YES | @QtBased #>

		/* Example:
	
		StzStringQ("Tunis is the town of my memories.") {
			ReplaceAll("Tunis", "Niamey" )
			? Content()
		}
		#--> Niamey is the town of my memories.
	
		*/

		# Checking the correctness of pcSubStr param

		if isList(pcSubStr) and Q(pcSubStr).IsEachNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubstr)
			stzRaise("Incorrect param typs! pcSubstr must be a string.")
		ok

		# Checking the correctness of pcNewSubStr param

		bWellFormed = FALSE

		if isString(pcNewSubStr)
			bWellFormed = TRUE

		but isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
			
			if isString(pcNewSubStr[2])
				bWellFormed = TRUE
				# Detecting the case where a conditonal value is provided
				# via the :With@ or :By@ keywords

				if Q(pcNewSubStr[1]).IsOneOfThese([ :With@, :By@ ])
					pcNewSubStr = pcNewSubStr[2]
	
					This.ReplaceSubStringCS@(pcSubStr, pcNewSubStr, pCaseSensitive)
					return
	
				else
					pcNewSubStr = pcNewSubStr[2]
				ok

			ok

		ok

		# Checking the correctness of pCaseSensitive param

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSe).")
		ok

		# Doing the job

		@oQString.replace_2(pcSubStr, pcNewSubStr, pCaseSensitive)

	
		#< @FunctionFluentForm
		
		def ReplaceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	#-- WITHOUT CASESENSITIVITY

	def Replace(pcSubStr, pcNewSubStr)
		This.ReplaceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm
		
		def ReplaceQ(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceSubStringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	  #---------------------------------#
	 #     REPLACING FIRST N CHARS     #
	#---------------------------------#

	def ReplaceFirstNChars(n, pcNewSubStr)
		This.ReplaceSection(1, n, pcNewSubStr)

		def ReplaceFirstNCharsQ(n, pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)
			return This

		def ReplaceNFirstChars(pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)

			def ReplaceNFirstCharsQ(pcNewSubStr)
				This.ReplaceNFirstChars(pcNewSubStr)
				return This

	def FirstNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceFirstNCharsQ(n, pcNewSubStr).Content()

		def NFirstCharsReplaced(pcNewSubStr)
			return This.FirstNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LAST N CHARS     #
	#--------------------------------#

	def ReplaceLastNChars(n, pcNewSubStr)
		This.ReplaceSection(This.NumberOfChars() - n + 1, :LastChar, pcNewSubStr)

		def ReplaceLastNCharsQ(n, pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)
			return This

		def ReplaceNLastChars(pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)

			def ReplaceNLastCharsQ(pcNewSubStr)
				This.ReplaceNLastChars(pcNewSubStr)
				return This

	def LastNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLastNCharsQ(n, pcNewSubStr).Content()

		def NLastCharsReplaced(pcNewSubStr)
			return This.LastNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LEFT N CHARS     #
	#--------------------------------#

	def ReplaceLeftNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceFirstNChars(n, pcNewSubStr)

		else
			This.ReplaceLastNChars(n, pcNewSubStr)
		ok

		def ReplaceLeftNCharsQ(n, pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)
			return This

		def ReplaceNLeftChars(pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)

			def ReplaceNLeftCharsQ(pcNewSubStr)
				This.ReplaceNLeftChars(pcNewSubStr)
				return This

	def LeftNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLeftNCharsQ(n, pcNewSubStr).Content()

		def NLeftCharsReplaced(pcNewSubStr)
			return This.LeftNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING RIGHT N CHARS    #
	#--------------------------------#

	def ReplaceRightNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceLastNChars(n, pcNewSubStr)

		else
			This.ReplaceFirstNChars(n, pcNewSubStr)
		ok

		def ReplaceRightNCharsQ(n, pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)
			return This

		def ReplaceNRightChars(pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)

			def ReplaceNRightCharsQ(pcNewSubStr)
				This.ReplaceNRightChars(pcNewSubStr)
				return This

	def RightNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceRightNCharsQ(n, pcNewSubStr).Content()

		def NRightCharsReplaced(pcNewSubStr)
			return This.RightNCharsReplaced(pcNewSubStr)

	  #-------------------------------#
	 #     REPLACING MIDDLE CHAR     #
	#-------------------------------#

	def ReplaceMiddleChar(pcNewSubStr)
		nPos = This.FindMiddleChar()
		This.ReplaceSection(nPos, nPos, pcNewSubStr)

		def ReplaceMiddleCharQ(pcNewSubStr)
			This.ReplaceMiddleChar(pcNewSubStr)
			return This

	def MiddleCharReplaced(pcNewSubStr)
		cResult = This.Copy().ReplaceMiddleCharQ(pcNewSubStr).Content()
		return cResult

	  #-------------------------------------------#
	 #     REPLACING MANY SUBSTRINGS AT ONCE     #
	#-------------------------------------------#

	def ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzString( "a + b - c / d = 0")
		 o1.ReplaceManyCS( ["+", "-", "=", "/" ], "*", :CaseSensitive = FALSE )
		 ? o1.Content()
	
		--> Gives: "a * b * c * d = 0"
	
		Example 2:
	
		o1 = new stzString( "Tunis is my town. Tunisa is my nation!")
		o1.ReplaceManyCS( [ "Tunis", "Tunisia" ], :EachChar = "*" )
		? o1.Content()
	
		*/

		if NOT ( isList(pacSubStr) and
			 Q(pacSubStr).IsListOfStrings() )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if isList(pNewSubStr) and Q(pNewSubStr).IsWithOrByNamedParam()
			pNewSubStr = pNewSubStr[2]
		ok

		if isList(pNewSubStr)
			return This.ReplaceManyByManyCS(pacSubStr, pNewSubStr, pCaseSensitive)
		ok

		if NOT isString(pNewSubStr)
			stzRaise("Incorrect param type! pNewSubStr must be a string.")
		ok

		for str in pacSubstr
			This.ReplaceCS( str, pNewSubStr, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This
		
		#>

		def ReplaceAllOfTheseCS(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
				This.ReplaceAllOfTheseCS(pacSubstr, pNewSubstr, pCaseSensitive)
				return This

		def ReplaceManySubstringsCS(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)

			def ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
				This.ReplaceManySubstringsCS(pacSubstr, pNewSubstr, pCaseSensitive)
				return This
		#>

	def ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
		acResult = This.Copy().ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive).Content()
		return acResult

		def ManyReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def SubStringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(pacSubstr, pcNewSubstr)
		This.ReplaceManyCS( pacSubstr, pcNewSubstr, :CaseSensitive = TRUE )

		#< @FunctionFluentFormn

		def ReplaceManyQ(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)
			return This
		#>

		#< @FunctionAlternativeForm
	
		def ReplaceAllOfThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceAllOfTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceManySubstrings(pacSubstr, pNewSubstr)
			This.ReplaceMany(pacSubstr, pNewSubstr)

			def ReplaceManySubstringsQ(pacSubstr, pNewSubstr)
				This.ReplaceManySubstrings(pacSubstr, pNewSubstr)
				return This

		#>

	def ManySubstringsReplaced(pacSubstr, pNewSubstr)
		acResult = This.Copy().ReplaceManySubstringsQ(pacSubstr, pNewSubstr).Content()
		return acResult

		def ManyReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def SubStringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

	  #--------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS  #
	#--------------------------------------------#

	def ReplaceByManyCS(pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ruby ring python ring")
		o1.ReplaceByMany("ring", :By = [ "♥", "♥♥", "♥♥♥" ])
	
		? o1.Content() #--> "♥ php ruby ♥♥ python ♥♥♥"

		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok

		anPositions = This.FindCS(pcSubStr, pCaseSensitive)
		nMin = Min([ len(anPositions), len(pacNewSubStrings) ])
	
		for i = nMin to 1 step -1
			n = anPositions[i]
			cNewSubStr = pacNewSubStrings[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pcSubStr, pacNewSubStrings)
		This.ReplaceByManyCS(pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS -- EXTENDED (RETURN TO FIRST)  #
	#--------------------------------------------------------------------------#

	def ReplaceByManyXTCS(pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> "#1 php #2 ruby #1 python #2"

		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok

		anPositions = This.FindCSQ(pcSubStr, pCaseSensitive).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SortedInDescending()
		
		i = 0
		for n in anPositions
			i++
			if i > len(acNewSubStrings)
				i = 1
			ok

			cNewSubStr = acNewSubStrings[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pcSubStr, pacNewSubStrings)
		This.ReplaceByManyXTCS(pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

	  #------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS  #
	#------------------------------------------------------#

	def ReplaceManyByManyCS(pacSubStrings, pacNewSubStrings, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp ring")
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "♥", "♥♥", "♥♥♥" ])

		? o1.Content() #--> "♥ qt ♥♥ pyhton ♥♥♥ csharp ♥"
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		i = 0
		for cSubStr in pacSubStrings
			cNewSubStr = NULL
			i++
			if i <= len(pacNewSubStrings)
				cNewSubStr = pacNewSubStrings[i]
			ok

			if cNewSubStr != NULL
				This.ReplaceCS(cSubStr, cNewSubStr, pCaseSensitive)
			ok

		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(pacSubStrings, pacNewSubStrings)
		This.ReplaceManyByManyCS(pacSubStrings, pacNewSubStrings, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #  REPLACING SOME OCCURRENCES OF A SUBSTRING BY AN OTHER SUBSTRING  #
	#-------------------------------------------------------------------#

	def ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrences([ 1, 5], "ring", :By = "♥♥♥")
	
		? o1.Content() #--> "♥♥♥ php ring ruby ring python ring csharp ♥♥♥"
		*/

		anAllPositions = This.FindAllCS(pcSubStr, pCaseSensitive)

		anPositions = []

		for n in panOccurrences
			anPositions + anAllPositions[n]
		next

		anPositions = StzListQ(anPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		next

		#< @FuntionFluentForm

		def ReplaceOccurrencesCSQ(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceOccurrrencesOfSubStringCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSomeOccurrencesOfSubStringCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSomeCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurrencess, pcSubStr, pcNewSubStr)
		This.ReplaceSomeOccurrencesCS(panOccurrencess, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def ReplaceOccurrencesQ(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrences(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceOccurrrencesOfSubString(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceSomeOccurrencesOfSubString(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceSome(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		#>

	  #----------------------------------------------------------------------#
	 #  REPLACING SOME OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#----------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrencesByMany([ 1, 3, 5], "ring", :By = [ "#1", "#3", "#5" ])
	
		? o1.Content() #--> "#1 php ring ruby #3 python ring csharp #5"
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		nMin = Min([ len(panOccurrences), len(pacNewSubStrings) ])
		anOccurrences = StzListQ(panOccurrences).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SortedInDescending()

		for i = 1 to nMin
			n = anOccurrences[i]
			cNewSubStr = acNewSubStrings[i]

			This.ReplaceNthOccurrenceCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

		#< @FuntionFluentForm

		def ReplaceOccurrencesByManyCSQ(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesByMznyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceOccurrrencesOfSubStringByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceSomeOccurrencesOfSubStringByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceSomeByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		#>
			
	#-- WITHOUT CASESENSITIVITY

	def ReplaceOcuurencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)
		This.ReplaceOccurrencedByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def ReplaceOccurrencesByManyQ(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesByMzny(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceOccurrrencesOfSubStringByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceSomeOccurrencesOfSubStringByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceSomeByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		#>

	  #------------------------------------------#
	 #     REPLACING SUBSTRING AT POSITION N    #
	#------------------------------------------#

	def ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()

		if This.RangeQ(n, nLen ).IsEqualToCS(pcSubStr, pCaseSensitive)
			This.ReplaceRange(n, nLen, pcNewSubStr)
		ok

		def ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringAtPositionReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceSubStringAtPositionNQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
				return This

	def SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionNQ(n, pcSubStr, pcNewSubStr)
		return cResult

	  #----------------------------------------------------------------------------#
	 #   REPALCING A SUBSTRING AT A SOME GIVEN POSITIONS BY AN OTHER SUBSTRING    #
	#----------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsCS(panPositions, pcSubStr, pcNewSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring ruby ring php ring")
		o1.ReplaceSubstringAtPositions([ 1, 20], "ring", :By = "♥♥♥")

		? o1.Content() #--> "♥♥♥ ruby ring php ♥♥♥"
		*/

		anPositions = StzListQ(panPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositions(panPositions, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionsCS(panPositions, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #   REPALCING A SUBSTRING AT A SOME GIVEN POSITIONS BY MANY OTHER SUBSTRINGS    #
	#-------------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceSubstringAtPositionsByMany([ 10, 20, 32], "ring", :By = [ "♥", "♥♥", "♥♥♥" ])

		? o1.Content() #--> "ring php ♥ ruby ♥♥ python ♥♥♥ csharp ring"
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT (isList(pacNewSubStrings) and Q(pacNewSubStrings).IsListOfStrings() )
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		# Keeping only the adequate number of positsions and new substrings
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new substrings

		nMin = Min([ len(panPositions), len(pacNewSubStrings) ])

		anPositions 	= Q(panPositions).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings	= Q(pacNewSubStrings).SectionQ(1, nMin).SortedInDescending()

		# Doing the job

		for i = 1 to nMin
			n = anPositions[i]
			cNewSubStr = acNewSubStrings[i]

			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringAtPositionsByManyCSQ(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
			return This

	def SubStringAtThesePositionsReplacedByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyCSQ(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionsByMany(panPositions, pcSubStr, pacNewSubStrings)
		This.ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

		def ReplaceSubStringAtPositionsByManyQ(panPositions, pcSubStr, pacNewSubStrings)
			This.ReplaceSubStringAtPositionsByMany(panPositions, pcSubStr, pacNewSubStrings)
			return This

	def SubStringAtThesePositionsReplacedByMany(panPositions, pcSubStr, pacNewSubStrings)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyQ(panPositions, pcSubStr, pacNewSubStrings).Content()
		return cResult

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubString@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content() #--> "#1 php #2 ruby #3 pyhton #4"

		*/

		if isList(pcDynamicStr) and Q(pcDynamicStr).IsWithOrByNamedParam()
			pcDynamicStr = pcDynamicStr[2]
		ok

		if NOT isString(pcDynamicStr)
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		anPositions = This.FindAllCSQ(pcSubStr, pCaseSensitive).SortedInDescending()


		@SubString = pcSubStr

		@NumberOfOccurrences = len(anPositions)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		acNewSubStr = []

		for @Position in anPositions

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPositions[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPositions[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicStr = StzStringQ(pcDynamicStr).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempStr = ( ' + cDynamicStr + ' )'
			eval(cCode)

			acNewSubStr + cTempStr

		next

		acNewSubStr = StzListQ(acNewSubStr).SortedInDescending()
	
		i = 0
		for @Position in anPositions
			i++
			cNewSubStr = acNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(@Position, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringCS@Q(pcSubStr, pcDynamicStr, pCaseSensitive)
			This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubString@(pcSubStr, pcDynamicStr)
		This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, :CaseSensitive = TRUE)

		def ReplaceSubString@Q(pcSubStr, pcDynamicStr)
			This.ReplaceSubString@(pcSubStr, pcDynamicStr)
			return This

	  #---------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION   #
	#---------------------------------------------------#

	def ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringW("ring", :Where = '{ Q(@Position).IsMultipleOf(10) }', :With = "♥♥♥")

		? o1.Content() #--> "ring php ♥♥♥ ruby ♥♥♥ pyhton ring"

		*/

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param! pcCondition must be a string.")
		ok

		anPositions = This.FindAllCS(pcSubStr, pCaseSensitive)

		@SubString = pcSubStr

		@NumberOfOccurrences = ringlen(anPositions)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		cCondition = StzStringQ(pcCondition).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				Content()

		anPositionsW = []

		
		i = 0
		for @Position in anPositions # TODO: replace for/in with for loop

			i++
			@CurrentPosition = @Position

			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPositions[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPositions[i + 1]
				@NextOccurrence = i + 1
			ok

			cCode = "bOk = ( " + cCondition + " )"
			eval(cCode)

			if bOk
				anPositionsW + @Position
			ok

		next

		This.ReplaceSubStringAtPositionsCS(anPositionsW, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
			return This
		
	  #-------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------#

	def ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm # (look to other in bottom of file)

		def ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

			def ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			This.ReplaceSections(aSections, pcNewSubStr)

			def ReplaceBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubstringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubstringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubstringBoundedByCSCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This
	
		#>

	def SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		cResult = This.ReplaceBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive).Content()
		return cResult

		def InBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This.SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def SubstringBoundedByReplacedCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This.SubStringInBetweenReplacedCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)

	#--- WITHOUT CASESENSITIVITY

	def ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm # (look to other in bottom of file)

		def ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

			def ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubStr)

		def ReplaceBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			aSections = This.FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			This.ReplaceSections(aSections, pcNewSubStr)

			def ReplaceBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
				return This

		def ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubstringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

			def ReplaceSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
				return This


		#>

	def SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, :CaseSensitive = TRUE)

		def InBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This.SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def SubstringBoundedByReplaced(pcSubStr, pacBounds, pcNewSubstr)
			return This.SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

	  #-------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------#

"todo"

def ReplaceBetweenS()
def ReplaceIBS()
	
	def ReplaceBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		aSections = This.FindSubStringBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceBetweenIBCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringBetweenIBCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			aSections = This.FindSubStringBoundedByAsSectionsIBCS(pcSubStr, pacBounds, pCaseSensitive)
			This.ReplaceSections(aSections, pcNewSubStr)
	
			def ReplaceBoundedByIBCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubStringBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
	
			def ReplaceSubStringBoundedByIBCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBetweenReplacedIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceBetweenIBCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			cResult = This.Copy().SubStringBoundedByIBCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive).Content()
			return cResult
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceBetweenIBCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)

			def ReplaceSubStringBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				This.ReplaceSubStringBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				return This

		def ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

			def ReplaceBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
				return This

		def ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
	
			def ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
				return This

		#>

	def SubStringBetweenReplacedIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
		cResult = This.Copy().ReplaceBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			return This.SubStringBoundedByIBCS(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

		#>	

	  #==============================================================#
	 #  REPLACING A SUBSTRING -- EXTENDED (NNC : NEAR-NATURAL CODE  #
	#==============================================================#

	def ReplaceXTCS(p1, p2, p3, pCaseSensitive)

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").ReplaceXT("♥", [], :With = "*")
		if ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		   ( ( (isList(p2)   and len(p2) = 0) or
		     ( isString(p2) and p2 = "") or
		     (isNumber(p2) and p2 = 0) ) ) AND

		   ( isString(p3) or (isList(p3)   and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCS(p1, p3, pCaseSensitive)
			return

		#  Q("*** rin* ***").ReplaceXT("*", :In = "rin*", :With = "g")
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and
		    ( isList(p2) and Q(p2).IsInOrInSideNamedParam() )
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1)
				p1 = p1[2] // "*"
			ok

		 	p2 = p2[2] // "rin*"

			if isList(p3)
				p3 = p3[2] // "g"
			ok

			cNewSubStr = Q(p2).ReplaceCSQ(p1, p3, pCaseSensitive).Content() // "ring"

			aSections = This.FindAsSectionsCS(p2, pCaseSensitive)
			This.ReplaceSections(aSections, cNewsubStr)


		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").ReplaceXT("♥", :With = "*", [])
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		    ( isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam() ) ) AND

		    ( ( (isList(p3)   and len(p3) = 0) or
		      (isString(p3) and p3 = "") or
		      (isNumber(p3) and p3 = 0) ) )

			This.ReplaceCS(p1, p2, pCaseSensitive)
			return

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:Nth = 4, "♥", :With = "\")
		but ( isNumber(p1) or
		    ( isList(p1) and Q(p1).IsNthNamedParam() ) ) and

		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and

		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1) and Q(p1).IsNthNamedParam()
				p1 = p1[2]
			ok

			This.ReplaceNthCS(p1, p2, p3, pCaseSensitive)

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:First, "♥", :With = "\")
		but ( isString(p1) and p1 = :First) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceXTCS(1, p2, p3, pCaseSensitive)

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:Last, "♥", :With = "\")
		but ( isString(p1) and p1 = :Last) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
			This.ReplaceXTCS(n, p2, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :AtPosition = 2, :With = "_")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtPositionNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionNamedParam()
				p2 = p2[2]
			ok
			
			This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :AtPositions = [2, 7], :With = "~")
		but ( isString(p1) ) and

		    ( (isList(p2) and Q(p2).IsListOfNumbers() ) or
		      (isList(p2) and Q(p2).IsAtPositionsNamedParam()) ) and

		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionsNamedParam()
				p2 = p2[2]
			ok

			This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :At = [2, 7], :With = "~")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtNamedParam()
				p2 = p2[2]
			ok

			if isNumber(p2)
				This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

			but isList(p2) and Q(p2).isListOfNumbers()
				This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)
			ok

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :Between = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok
			
		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedBy = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCS(p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenIBCS(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok

		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByIBCS(p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT("♥♥♥", :Between = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCS(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok
			
		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT("♥♥♥", :BoundedBy = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCS(p1, p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenIBCS(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok

		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByIBCS(p1, p2, p3, pCaseSensitive)

		#--
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		#-- Allowing :BoundedBy along with :Between

		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			but isString(p2)

				This.ReplaceAnyBetweenCS(p2, p2, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a string, or a pair of strings or numbers.")
			ok
			
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok

		ok

	#-- WITHOUT CASESENSITIVITY

	def ReplaceXT(p1, p2, p3)
		This.ReplaceXTCS(p1, p2, p3, :CaseSensitive = TRUE)

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
	
		o1 = new stzString("...12...1212...121212...")
		? o1.SubStringsMadeOf("12")
		#--> [ "12", "1212", "121212" ]
	
		*/
	
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)
		
		return acResult
		
		def MadeOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOf(pcSubStr)
		return This.SubStringsMadeOfCS(pcSubStr, :CaseSensitive = TRUE)
	
		def MadeOf(pcSubStr)
			return This.SubStringsMadeOf(pcSubStr)

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfXTCS(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = This.SectionsXT(aSections)
		return aResult

		def MadeOfCSXT(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfXTCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOfXT(pcSubStr)
		return This.SubStringsMadeOfXTCS(pcSubStr, :CaseSensitive = TRUE)
	
		def MadeOfXT(pcSubStr)
			return This.SubStringsMadeOfXT(pcSubStr)

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anResult = [ anPos[1] ]
		for i = 2 to nLen
			if anPos[i] - anPos[i-1] = nLenSubStr
				loop
			ok

			anResult + anPos[i]
		next

		return anResult


		def FindSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindMadeOf(pcSubStr)
		return This.FindMadeOfCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		#                      4   8 1   4 6 8   2
		o1 = new stzString("...12..1212..121212..12.")
		? @@( o1.FindMadeOf("12") )
		#--> [ 4, 8, 10, 14, 16, 18 ]

		*/

		# Preparing some values we need

		nLenStr = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		cFirstChar = Q(pcSubStr).FirstChar()

		# Finding the positions of pcSubStr in the string

		anPos = This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenPos = len(anPos)

		aResult = []
		
		# For each postion
		for i = 1 to nLenPos

			# we start parsing the string from that position
			n = anPos[i]
			nNext = 0
			if i < nLenPos
				nNext = anPos[i+1]
			ok

			# if the char we are parsing does not belong to
			# pcSubStr, then we stop the parsing and return
			# the section (done for each position)

			while TRUE
				n += nLenSubStr
				if n > nLenStr or
				   (nNext != 0 and n >= nNext)
					exit
				ok
		
				if NOT This.CharQ(n).IsEqualToCS(cFirstChar, pCaseSensitive)
					aTempSection = [ anPos[i], (n-1) ]

					if len(aResult) > 0 and
					   anPos[i] = aResult[len(aResult)][1]

						aResult[len(aResult)][2] = (n-1)

					else
						aResult + [ anPos[i], (n-1) ]
					ok
				ok

				
			end
		next
		
		return aResult

		def FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

	#--  WITHOUT CASESENSITIVITY

	def FindMadeOfAsSections(pcSubStr)
		return This.FindMadeOfAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

	  #=============================================================================#
	 #  YIELDING CHARS STARTING AT A GIVEN POSITION UNTIL A CONDITION IS VERIFIED  #
	#=============================================================================#

	def YieldXT(pcAction, pnStartingAt, pUptoOrUntil)
		/* EXAMPLE
	
		See examples in the same function in stzList
	
		*/
	
		if NOT isString(pcAction)
			StzRaise("Incorrect param type! pcAction must be a string.")
		ok

		if isString(pnStartingAt)
			pnStartingAt =  Q(pnStartingAt).
					SubStringsReplacedCS( [ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsAPairOfStrings()
			pnStartingAt[2] = Q(pnStartingAt[2]).
					  SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isString(pUptoOrUntil)
			pUptoOrUntil =  Q(pUptoOrUntil).
					SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isList(pUptoOrUntil) and Q(pUptoOrUntil).IsAPairOfStrings()
			pUptoOrUntil[2] = Q(pUptoOrUntil[2]).
					  SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		cAction  = StzCCodeQ(pcAction).Transpiled()
		acResult = This.CharsQ().YieldXT(cAction, pnStartingAt, pUpToOrUntil)
		return acResult

		#< @FunctionFluentForm

		def YieldXTQ(pcAction, pnStartingAt, pUptoOrUntil)
			return This.YieldXTQR(pcAction, pnStartingAt, pUptoOrUntil, :stzList)

		def YieldXTQR(pcAction, pnStartingAt, pUptoOrUntil, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isSting(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfStrings
				return new stzListOfStrings( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfChars
				return new stzListOfChars( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfPairs
				return new stzListOfPairs( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #========================================================#
	 #  REPLACING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================#

	def ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceanyBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm: SeeBottomOfFile >

	def SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		acResult = This.Copy().ReplaceBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive).Content()
		return acResult

		def SubStringsBoundedByReplacedCS(pacBounds, pcNewSubStr, pCaseSensitive)
			acResult = This.Copy().ReplaceBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			return acResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)
		return This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceAnyBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		acResult = This.Copy().ReplaceAnyBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

	  #--------------------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#--------------------------------------------------------------------#
	#--> Bounds are also replaced (TODO: Generalise this feature)

	def ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnyBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		acResult = This.Copy().ReplaceBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		return This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		acResult = This.Copy().ReplaceBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	  #==========================================#
	 #   REPLACING A CHAR AT A GIVEN POSITION   #
	#==========================================#

	def ReplaceCharAtPosition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		This.ReplaceSection(n, n, pcNewSubStr)

		def ReplaceCharAtPositionQ(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)
			return This

		#< @FunctionAlternativeForms

		def ReplaceCharAt(n, pcNewSubStr)
			if isList(n) and Q(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtQ(n, pcNewSubStr)
				This.ReplaceCharAt(n, pcNewSubStr)
				return This

		def ReplaceCharAtPositionN(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceCharAtThisPosition(n, pcNewSubStr)
				return This

		#>

	def CharReplacedAtPsoition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		cResult = This.Copy().ReplaceCharAtPositionQ(n, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharReplacedAtThisPsoition(n, pcNewSubStr)
			return This.CharReplacedAtPsoition(n, pcNewSubStr)

		def CharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPsoition(n, pcNewSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def ReplaceCharsAtPositions(panPositions, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(panPositions) and len(panPositions) = 0
			return
		ok

		# Checking the correctness of panPositions param

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! panPositions must be list of numbers.")
		ok

		anPositions = Q(panPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceCharAtPositionN(n, pcNewSubStr)
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsQ(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAt(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)

		def ReplaceCharsAtThesePositions(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)

		#>

	def CharsReplacedAtPsoitions(panPositions, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsQ(panPositions, pcNewSubStr).Content()
		return cResult

		def CharsReplacedAtThesePsoitions(panPositions, pcNewSubStr)
			return This.CharsReplacedAtPsoitions(panPositions, pcNewSubStr)

		def CharsAtThesePositionsReplaced(panPositions, pcNewSubStr)
			return This.CharsReplacedAtPsoitions(panPositions, pcNewSubStr)

	  #-----------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)
		/* EXAMPLE
		o1 = new stzString("ab3de6gh9")
		o1.ReplaceCharsAtPositionsByMany([3, 6, 9], [ "c", "f", "i" ])

		? o1.Content() #--> "abcdefghi"
		*/

		anPositions = StzListOfNumbersQ(panPositions).SortedInDescending()

		nMin = Min([ len(anPositions), len(pacNewSubStrings) ])
		anPositions = StzListQ(anPositions).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SectionQ(1, nMin).SortedInDescending()

		i = 0
		for n in anPositions
			i++
			This.ReplaceCharAtPosition(n, acNewSubStrings[i])
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsByManyQ(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAtByMany(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)

		def ReplaceCharsAtThesePositionsByMany(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)

		#>

	def CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)
		cResult = This.Copy().ReplaceCharsAtPositionsByManyQ(panPositions, pacNewSubStrings).Content()
		return cResult

		def CharsReplacedAtThesePsoitionsByMany(panPositions, pacNewSubStrings)
			return This.CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)

		def CharsAtThesePositionsReplacedByMany(panPositions, pacNewSubStrings)
			return This.CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)

	  #-------------------------------------------------------------------------#
	 #   REPLACING CHARS/SUBSTRINGS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#-------------------------------------------------------------------------#

	def ReplaceW(pcCondition, pcCharOrSubStr)
	
		# Checking params

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pcCharOrSubStr) and Q(pcCharOrSubStr).IsWithOrByNamedParam()
			pcCharOrSubStr = pcCharOrSubStr[2]
		ok

		if NOT isString(pcCharOrSubStr)
			StzRaise("Incorrect param type! pcCharOrSubStr must be a string.")
		ok

		# Doing the job

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsNeitherCS("@char", :Nor = "@substring", :CS = FALSE) or
		   oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Incorrect syntax ! pcCondition must contains either @char or @substring keywords (but not both).")
		ok

		if oCondition.ContainsCS("@char", pCaseSensitive)
			anPos = FindCharsW(pcCondition)
			This.ReplaceCharsAtPositions(anPos, pcCharOrSubStr)

		else # contains @substring
			anPos = Thid.FindSubStringsW(pcCondition)
			This.ReplaceSubStringsAtPositions(anPos, pcCharOrSubStr)
		ok

	  #--------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#--------------------------------------------------------------------#

	def ReplaceAllCharsW(pcCondition, pcNewSubStr)
		#< @MotherFunctions:
		#	This.FindAllCharsW()  > @RingBased
		#	This.ReplaceSection() > @QtBased
		#>

		/*
		Example:

		StzStringQ( "Text processing with Ring" ) {

			ReplaceAllCharsW(
				:Where = '{ @char = "i" }',
				:With = "*"
			)

			? Content()
		}

		--> Returns: "Text process*ng w*th R*ng"
		*/

		# Checking the correctness of the pcCondition param
			#--> Not necessary! It will be done by the
			# mother function FindAllCharsW()

		# Checking the correctness of the pcNewSubStr param
			#--> Not necceary! It will be done by the
			# called function ReplaceCharsAtPositions()

		# Doing the job

		anPositions = This.FindCharsW(pcCondition)

		This.ReplaceCharsAtPositions(anPositions, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceAllCharsWQ(pCondition, pcNewSubStr)
			This.ReplaceAllCharsWhere(pCondition, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAllWhere(pCondition, pcNewSubStr)
			This.ReplaceAllCharsW(pCondition, pcNewSubStr)

			def ReplaceAllWhereQ(pCondition, pcNewSubStr)
				This.ReplaceAllWhere(pCondition, pcNewSubStr)
				return This

		def ReplaceAllCharsWhere(pCondition, pcNewSubStr)
			This.ReplaceAllCharsW(pCondition, pcNewSubStr)

			def ReplaceAllCharsWhereQ(pCondition, pcNewSubStr)
				This.ReplaceAllCharsWhere(pCondition, pcNewSubStr)
				return This

		def ReplaceCharsW(pCondition, pcNewSubStr)
			This.ReplaceAllCharsW(pCondition, pcNewSubStr)

			def ReplaceCharsWQ(pCondition, pcNewSubStr)
				This.ReplaceCharsW(pCondition, pcNewSubStr)
				return This

		def ReplaceCharsWhere(pCondition, pcNewSubStr)
			This.ReplaceAllCharsW(pCondition, pcNewSubStr)

			def ReplaceCharsWhereQ(pCondition, pcNewSubStr)
				This.ReplaceCharsWhere(pCondition, pcNewSubStr)
				return This

		#>

	  #----------------------------------------------------#
	 #     REPLACING THE NTH OCCURRENCE OF A SUBSTRING    #
	#----------------------------------------------------#

	def ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok
	
		if n = :First
			n = 1
	
		but n = :Last
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
		ok
	
		n = This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
	
		if n > 0
			oSubStr = new stzString(pcSubStr)
			This.ReplaceSection( n, n + oSubStr.NumberOfChars()-1, pcNewSubStr)
		ok
	
		#< @FunctionFluentForm
	
		def ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		def ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def NthOccurrenceReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()


	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This
	
		#>

		def ReplaceNth(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)

			def ReplaceNthQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNth(n, pcSubStr, pcNewSubStr)
				return This

	def NthOccurrenceReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr).Content()

	  #-------------------------------------------------#
	 #    REPLACING FIRST OCCURRENCE OF A SUBSTRING    #
	#-------------------------------------------------#

	def ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def FirtOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternative

		def ReplaceFirst(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceFirstQ(pcSubStr, pcNewSubStr)
				This.ReplaceFirst(pcSubStr, pcNewSubStr)
				return This

		#>

	def FirtOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	  #--------------------------------------------------#
	 #     REPLACING LAST OCCURRENCE OF A SUBSTRING     #
	#--------------------------------------------------#

	def ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def ReplaceLast(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceLastQ(pcSubStr, pcNewSubStr)
				This.ReplaceLast()
				return This

		#>

	def LastOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2] + 1, pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :First or :FirstOccurrence
				nStart = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			on :FirstPosition or :FirstChar
				nStart = 1

			off
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def NextNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

	def NextNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def NextOccurenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	   #--------------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                        #
	#--------------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplacePreviousNthOccurrence(2, :Of = "ring", :StartingAtOccurrence = 3, :By = "♥♥♥")
		
		? o1.Content() #--> ♥♥♥ php ring ruby ring python ring
		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2], pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :Last or :LastOccurrence
				nStart = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

			on :LastPosition or :LastChar
				nStart = This.NumberOfChars()

			off
		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def PreviousNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

	def PreviousNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def PreviousOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	  #----------------------------------------------------#
	 #  REPLACING THE FIRST N OCCURRENCES OF A SUBSTRING  #
	#----------------------------------------------------#

	def ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(anPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceFirstNOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNFirstOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstNOccurrencesCSQ(n, pcNewSubStr, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
		This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)

			def ReplaceNFirstOccurrencesQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
				return This

	def FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr).Content()

		def NFirstOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
			return This.FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)

	  #========================#
	 #   REPLACING NTH CHAR   # 
	#========================#

	def ReplaceNthChar(n, pSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if n = :LastChar or n = :EndOfString or n = :Last
			n = This.NumberOfChars()

		but n = :FirstChar or n = :StartOfString or n = :First
			n = 1
		ok

		if isList(pSubStr) and
		   len(pSubStr) = 2 and
		   StzListQ(pSubStr).IsPairOfStrings()

			if pSubStr[1] = :With
				pSubStr = pSubStr[2]

			but pSubStr[1] = :With@

				cCode = 'pSubStr = ' +
				StzStringQ(pSubStr[2]).
				TrimQ().RemoveTheseBoundsQ(["{","}"]).Content()

				eval(cCode)
			ok
		ok

		This.ReplaceSection(n, n , pSubStr)

		#< @FunctionFluentForm

		def ReplaceNthCharQ(n, pcSubStr)
			This.ReplaceNthChar(n, pcSubStr)
			return This

		#>

	def NthCharReplaced(n, pValue)
		cResult = This.Copy().ReplaceNthCharQ(n, pValue).Content()
		return cResult

	  #-----------------------------------------------#
	 #  REPLACING FIRST CHAR WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def ReplaceFirstChar(pcSubStr)
		This.ReplaceNthChar(1, pcSubStr)

		def ReplaceFirstCharQ(pcSubStr)
			This.ReplaceFirstChar(pcSubStr)
			return This

	def FirstCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #----------------------------------------------#
	 #  REPLACING LAST CHAR WITH A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def ReplaceLastChar(pcSubStr)
		This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)

		def ReplaceLastCharQ(pcSubStr)
			This.ReplaceLastChar(pcSubStr)
			return This

	def LastCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Contenr()

	  #------------------------------------------------------------#
	 #  REPLACING NTH GIVEN CHAR (IF ANY) WITH A GIVEN SUBSTRING  #
	#------------------------------------------------------------#

	def ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)

		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.ReplaceNthChar(n, pcSubStr)
		ok

		def ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive)
			This.ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)
			return This

	def ThisNthCharReplacedCS(n, cChar, pcSubStr, pCaseSensitive)
		return This.Copy().ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisNthChar(n, cChar, pcSubStr)
		This.ReplaceThisNthCharCS(n, cChar, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisNthCharQ(n, cChar, pcSubStr)
			This.ReplaceThisNthChar(n, cChar, pcSubStr)
			return This

	def ThisNthCharReplaced(n, cChar, pcSubStr)
		return This.Copy().ReplaceThisNthCharQ(n, cChar, pcSubStr).Content()

	  #-----------------------------------------------------------------#
	 #  REPLACING A GIVEN FIRST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#-----------------------------------------------------------------#

	def ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.FirstCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(1, pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisFirstCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisFirstChar(c, pcSubStr)
		This.ReplaceThisFirstCharCSQ(c, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisFirstCharQ(c, pcSubStr)
			This.ReplaceThisFirstChar(c, pcSubStr)
			return This

	def ThisFirstCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisFirstCharQ(c, pcSubStr).Content()

	  #----------------------------------------------------------------#
	 #  REPLACING A GIVEN LAST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#----------------------------------------------------------------#

	def ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.LastCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisLastCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisLastChar(c, pcSubStr)
		This.ReplaceThisLastCharCSQ(c, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisLastCharQ(c, pcSubStr)
			This.ReplaceThisLastChar(c, pcSubStr)
			return This

	def ThisLastCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisLastCharQ(c, pcSubStr).Content()

	  #--------------------------#
	 #    REPLACING ALL CHARS   # 
	#--------------------------#

	def ReplaceAllChars(pcSubStr)

		if isList(pcSubStr) and Q(pcSubStr).IsWithNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		cResult = ""
		for i = 1 to This.NumberOfChars()
			cResult += pcSubStr
		next

		This.Update( cResult )

		#< @FunctionFluentForm

		def ReplaceAllCharsQ(pcSubStr)
			This.ReplaceAllChars(pcSubStr)
			return This

		#>

	def AllCharsReplaced(pcSubStr)
		cResult = This.Copy().ReplaceAllCharsQ(pcSubStr).Content()
		return cResult

	  #================================#
	 #    INTERPOLATING THE STRING    # 
	#================================#

	def Interpolate()
		/* EXAMPLE

		max = RingMaxIntegerXT()
		min = RingMinIntegerXT()

		? Q("The range of integers is {min} to {max}").Interpolated();
		
		#--> The range of integers is '-999_999_999_999_999' to
		     '999_999_999_999_999'

		NOTE the use of the XT() extension to return the number
		spacified by "_"

		*/

		aSectionsXT = This.SubStringsBetweenZZ("{", "}")
		#--> [ [ "min", [ 27, 29 ] ], [ "max", [ 36, 38 ] ] ]

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
		
			cVar	 = aSectionsXT[i][1]
			cCode	 = 'cValue	 = (' + cVar + ' )'
			eval(cCode)
		
			n1 = aSectionsXT[i][2][1] - 1
			n2 = aSectionsXT[i][2][2] + 1
			
			This.ReplaceSection(n1, n2, cValue)

		next

		#< @FunctionFluentForm

		def InterpolateQ()
			This.Interpolate()
			return This

		#>

		#< @FunctionMisspelledForms

		def Interpoltate()
			return This.Interpolate()

			def InterpoltateQ()
				This.Interpoltate()
				return This

		def Intrepolate()
			return This.Interpolate()

			def IntrepolateQ()
				This.Interpoltate()
				return This
		#>
			
	def Interpolated()
		return This.Copy().InterpolateQ().Content()

		#< @FunctionMisspelledForm

		def Interpoltated()
			return This.Interpolated()

		def Intrepolatef()
			return This.Interpolated()

		#>
		
	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS MARKERS  #
	#===========================================#

	def ContainsMarkers()
		/*
		? StzString('My kids are #1, #2, and #3!').ContainsMarkers() --> TRUE
		*/

		if This.NumberOfMarkers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #=============================================#
	 #    CHECKING IF THE STRING IS A RING CODE    # 
	#=============================================#

	def IsValidRingCode()

		try
			eval(This.Copy().Content())
			return TRUE
		catch
			return FALSE
		done

		def IsEvaluableRingCode()
			return This.IsValidRingCode()

		def IsRingCode()
			return This.IsValidRingCode()

	  #------------------------------------------------#
	 #    EXECUTING RING CODE HOSTED IN THE STRING    # 
	#------------------------------------------------#

	def Execute()
		if This.IsValidRingCode()
			eval(This.String())
		ok

		def Run()
			This.Execute()

	def ExecuteAndReturn()
		if This.StartsWithCS("return ", :CS = FALSE)
			eval(This.String())
		else
			cCode = "return " + This.String()
			eval(cCode)
		ok

		def RunAndReturn()
			This.ExecuteAndReturn()

	  #----------------------------#
	 #     CLEARING THE STRING    #
	#----------------------------#

	def Clear()
		This.UpdateWith("")

		#< @FunctionFluentForm

		// Clears the string and return it as a StzObject
		// to take other actions on it
		def ClearQ()
			This.Clear()
			return This

		#>

	  #---------------------------------------------------------#
	 #  VERIFYING IF THE STRING IS EMPTY (NULL IN RING TERMS)  #
	#---------------------------------------------------------#

	def IsEmpty()
		return This.Content() = ""

	  #-----------------------------------------------------------#
	 #  FILLING THE STRING WITH N COPIES OF THE GIVEN SUBSTRING  #
	#-----------------------------------------------------------#

	def FillWith(n, cSubStr)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(cSubStr)
			StzRaise("Incorrect param type! cSubStr must be a string.")
		ok

		cStr = Q(cSubStr).RepeatedNTimes(n)
		This.UpdateWith(cStr)

		#< @FunctionFluentForm

		def FillWillQ(n, cChar)
			This.FillWith(n, cChar)
			return This

		#>
		
	  #-----------------------#
	 #  RESIZING THE STRING  #
	#-----------------------#

	def Resize(n)
		cResult = NULL

		if n <= NumberOfChars()
			cResult = This.FirstNChars(n)
		else
			cResult = This.ExtendToNChars(n, :Using = " ")
		ok

		This.Update(cResult)
		
		#< @FunctionFluentForm

		def ResizeQ(n)
			This.Resize(n)
			return This
	
		#>

	  #-----------------------------------------------#
	 #  ADDING A SUBSTRING AT THE END OF THE STRING  #
	#-----------------------------------------------#

	def AddSubString(pcSubStr)
		This.Update( :With = This.Content() + pcSubStr )

	  #------------------------------------------#
	 #  ADDING A CHAR AT THE END OF THE STRING  #
	#------------------------------------------#

	def AddChar(c)
		if isString(c) and Q(c).IsChar()
			This.AddSubString(c)
		else
			stzRaise("Incorrect param type! c must be a char.")
		ok


	  #-----------------------#
	 #  UPDATING THE STRING  #
	#-----------------------#

	def Update(pcNewStr)
		#< QtBased | Uses QString.clear() and QString.append() >

		if isList(pcNewStr) and Q(pcNewStr).IsWithOrByOrUsingNamedParam()
			pcNewStr = pcNewStr[2]
		ok
	
		@oQString.clear()
		@oQString.append(pcNewStr)

		//This.VerifyConstraints()

		#< @FunctionFluentForm

		def UpdateQ(pcNewStr)
			This.Update(pcNewStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(pcNewStr)
			This.Update(pcNewStr)

			def UpdateWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def UpdateBy(pcNewStr)
			This.Update(pcNewStr)

			def UpdateByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def UpdateUsing(pcNewStr)
			This.Update(pcNewStr)

			def UpdateUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		#>

	def Updated(pcNewStr)
		return pcNewStr

		#< @FunctionAlternativeForms

		def UpdatedWith(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedBy(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#>

	  #----------------------------------------#
	 #     CONTAINING ONLY SPACES & LETTERS   #
	#----------------------------------------#

	// Verifies if the string contains only spaces
	def ContainsOnlySpaces()
		if This.content() = ""
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if c != " "
				bResult = FALSE
				exit
			ok
		next

		return bResult

	def ContainsOnlyLetters()
		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			if NOT This.CharAtQ(i).IsLetter()
				bResult = FALSE
				exit
			ok
		next

		return bResult

	  #---------------------------------------------------------#
	 #  CHEHCKING IF THE STRING STARTS WITH A GIVEN SUBSTRING  #
	#---------------------------------------------------------#

	def StartsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.startsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.startsWith(pcSubStr, pCaseSensitive)
		return bResult


		def BeginsWithCS(pcSubStr, pCaseSensitive)
			return This.StartsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(pcSubStr)
		return This.StartsWithCS(pcSubStr, :CaseSensitive = TRUE)

		def BeginsWith(pcSubStr)
			return This.StartsWith(pcSubStr)

	  #----------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.BeginsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESNESITIVITY

	def BeginsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, :CaseSensitive = TRUE)

		def StartsWithOneOfThese(paSubStr)
			return This.BeginsWithOneOfThese(paSubStr)

	  #--------------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#--------------------------------------------------------------------#

	def StartsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		if NOT BothAreStrings(pSubStr1, pSubStr2)
			stzRaise("Incorrect params types! Both pSubStr1 and pSubStr2 must be strings.")
		ok

		return This.StartsWithOneOfTheseCS([pSubStr1, pSubStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWithEither(pSubStr1, pSubStr2)
		return This.StartsWithEitherCS(pSubStr1, pSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH A GIVEN GIVEN SUBSTRING  #
	#----------------------------------------------------------#

	def EndsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses oQString.endsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.endsWith(pcSubStr, pCaseSensitive)
		return bResult


		def FinishsWithCS(pcSubStr, pCaseSensitive)
				return This.EndsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(pcSubStr)
		return @oQString.endsWith(pcSubStr, 0)

		def FinishsWith(pcSubStr)
			return This.EndsWith()

	  #--------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------#

	def EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.EndsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def FinishsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, :CaseSensitive = TRUE)

		def FinsihsWithOneOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

	  #------------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#------------------------------------------------------------------#

	def EndsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		return This.EndsWithOneOfTheseCS([ pSubStr1, pSubStr2], pCaseSenitive)

	#-- WTHOUT CASESENSITIVITY

	def EndsWithEither(pSubStr1, pSubStr2)
		return This.EndsWithEitherCS(pSubStr1, pSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  GETTING THE SUBSTRING OCCURRENCE BY ITS POSITION  #
	#----------------------------------------------------#

	def SubStringOccurrenceByPositionCS(nPos, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.SubStringOccurrenceByPosition(9, "ring") #--> 2
		*/

		nResult = 0

		anPositions = This.FindSubStringCS(pcSubStr, pCaseSensitive)
		i = 0
		for n in anPositions
			i++
			if n = nPos
				nResult = i
				exit
			ok
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringOccurrenceByPosition(nPos, pcSubStr)
		return This.SubStringOccurrenceByPositionCS(nPos, pcSubStr, :CaseSensitive = TRUE)

	  #---------------------------------------------#
	 #   FINDING THE NTH OCCURRENCE OF SUBSTRING   #
	#---------------------------------------------#

	def FindNthCS(n, pcSubstr, pCaseSensitive) #--> Returns 0 if nothing found

		# Resolving the pcSubStr param

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be as a string.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Early-checking for better performance (in case of!)

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		# Resolving the n param

		if isString(n)
			cNLowercased = Q(n).Lowercased()
			if cNLowercased = :First or cNLowercased = :FirstOccurrence
				n = 1

			but cNLowercased = :Last or cNLowercased = :LastOccurrence
				n = This.NumberOfOccurrenceCs(pcSubStr, pCaseSensitive)

			else
				n = 0
			ok
		ok

		# Doing the job

		nResult = 0

		nPos = 1
		for i = 1 to n

			nResult = This.QStringObject().indexOf(pcSubStr, nPos - 1, pCaseSensitive) + 1

			if nResult = 0
				exit
			ok

			nPos = nResult + 1
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNth(n, pcSubstr)
		return This.FindNthCS(n, pcSubstr, :CaseSensitive = TRUE)

	  #===============================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING AND RETURNING THE POSITION AS SECTION  #
	#===============================================================================#

	def FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)

		anResult = [ nPos, (nPos + Q(pcSubStr).NumberOfChars() - 1) ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSection(n, pcSubStr)
		return This.FindNthAsSectionCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSection(pcSubStr)
		return This.FindFirstAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionMisspelledForm

		def FindLasteAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSection(pcSubStr)
		return This.FindLasteAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionMisspelledForm

		def FindLasteAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

	  #============================================#
	 #  FINDING THE ANTI-SECTIONS OF A SUBSTRING  #
	#============================================#

	def AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		return Q(1:This.NumberOfChars()).
			FindAntiSections( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSections(pcSubStr)
		return This.AntiFindAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

	  #---------------------------------------------------------#
	 #  FINDING THE ONLY ANTI-SECTION (IF ANY) OF A SUBSTRING  #
	#---------------------------------------------------------#

	def AntiFindAsSectionCS(pcSubStr, pCaseSensitive)
		aSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult = []
		if len(aSections) > 0
			aResult = aSections[1]
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSection(pcSubStr)
		return This.AntiFindAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- D/Extented  #
	#===================================================#

	def FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		# Checking prams

		if isString(n)
			if n = :Default or n = :First or n = :FirstOccurrence
				n = 1

			but n = :Last or n = :LastOccurrence
				n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Default, :Forward, and :Backward.")
		ok

		# Doing the job

		nPos = This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionD(n, pcSubStr, pcDirection)
		return This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- D/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionDCS(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionD(pcSubStr, pcDirection)
		return This.FindFirstAsSectionDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- D/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionDCS(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionD(pcSubStr, pcDirection)
		return This.FindLastAsSectionDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #====================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- SD/Extented  #
	#====================================================#

	def FindNthAsSectionSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])

			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, :Backward.")
		ok

		# Doing the job

		aResult = This.FindNthAsSectionSCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionSD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- SD/Extented  #
	#------------------------------------------------------#

	def FindFirstAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionSDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- SD/Extented  #
	#-----------------------------------------------------#

	def FindLastAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionSDCS(:LastOccurrence, pnStartingAt, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- S/Extented  #
	#===================================================#

	def FindNthAsSectionSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- S/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionS(pcSubStr, pnStartingAt)
		return This.FindFirstAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- S/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionS(pcSubStr, pnStartingAt)
		return This.FindLastAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #=======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#=======================================================#

	def FindNthZCS(n, pcSubStr, pCaseSensitive)
		anPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def FindNthCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthZCS(n, pcSubStr, pCaseSensitive)

		def NthZCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthZCS(n, pcSubStr, pCaseSensitive)

		def NthCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthZCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthZ(n, pcSubStr)
		return This.FindNthZCS(n, pcSubStr, :CaseSensitive = TRUE)

		def NthZ(n, pcSubStr)
			return This.FindNthZ(n, pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#

	def FindNthZZCS(n, pcSubStr, pCaseSensitive)
		aSection = This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		def FindNthCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthZZCS(n, pcSubStr, pCaseSensitive)

		def NthCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthZZCS(n, pcSubStr, pCaseSensitive)

		def NthZZCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthZZCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthZZ(n, pcSubStr)
		return This.FindNthZZCS(n, pcSubStr, :CaseSensitive = TRUE)

		def NthZZ(n, pcSubStr)
			return This.FindNthZZ(n, pcSubStr)

	  #=======================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION   #
	#=======================================================================#

	def FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("12♥45♥78♥")
		? o1.FindNthS(2, "♥", :StartingAt = 3)
		#--> 6

		*/

		return This.FindNthSDCS(n, pcSubStr, pnstartingAt, :Forward, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindNthS(n, pcsubStr, pnStartingAt)
		return This.FindNthSCS(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def FindFirstSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		# Resolving params

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok
		
		# Doing the job
		
		nResult = This.QStringObject().indexOf(pcSubStr, pnStartingAt - 1, pCaseSensitive) + 1
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstS(pcSubStr, pnStartingAt)
		return This.FindFirstSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------#

	def FindLastSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastS(pcSubStr, pnStartingAt)
		return This.FindLastSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #==========================================================================#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                           #
	#==========================================================================#

	def FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Forward, :Default, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Forward, :Backward, and :Default.")

		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsEither(:Forward, :Or = :Backward) )

			StzRaise("Incorrect param! pcDirection must be a string. Allowed values are :Forward and :Backward.")

		ok

		if isString(n)

			if NOT ( isNumber(n) or
				 isString(n) and Q(n).IsOneOfThese([
					:First, :FirstOccurrence, :Last, :LastOccurrence ]) )

				StzRaise("Incorrect param! n must be a number or one of these " +
					 "two strings (:First or :Last).")
			ok

			if pcDirection = :Forward or pcDirection = :Default

				if n = :First or n = :FirstOccurrence
					n = 1
	
				but n = :Last or n = :LastOccurrence
	
					n = This.SectionQ(pnStartingAt, :LastChar).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

				ok

			else // Backward

				if n = :First or n = :FirstOccurrence

					n = This.SectionQ(pnStartingAt, :LastChar).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
				but n = :Last or n = :LastOccurrence
					n = This.SectionQ(1, pnStartingAt).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

				ok		

			ok
	
	
		ok

		# doing the job

		nResult = 0

		if pcDirection = :Forward

			nPos  = This.SectionQ(pnStartingAt, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

			if nPos > 0
				nResult = nPos + pnStartingAt - 1
			ok

		else // :Backward

			nResult  = This.FindNthPreviousCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthSD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

	   #----------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                             #
	#----------------------------------------------------------------------------#

	def FindFirstSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                            #
	#---------------------------------------------------------------------------#

	def FindLastSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #===================================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#===================================================================================#

	def FindNthSZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("12♥45♥78♥")
		? o1.FindNthSZ(2, "♥", :StartingAt = 3)
		#--> [ "♥", 6 ]
		*/

		aResult = [ pcSubStr, This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult

		def FindNthSCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSZ(n, pcsubStr, pnStartingAt)
		return This.FindNthSZCS(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def NthSZ(n, pcsubStr, pnStartingAt)
			return This.FindNthSZ(n, pcsubStr, pnStartingAt)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FindFirstSZCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSZCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSZCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSZ(pcSubStr, pnStartingAt)
		return This.FindFirstSZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def FirstSZ(pcSubStr, pnStartingAt)
			return This.FindFirstSZ(pcSubStr, pnStartingAt)

	  #------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#------------------------------------------------------------------------------------#

	def FindLastSZCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSZCS(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSZCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSZ(pcSubStr, pnStartingAt)
		return This.FindLastSZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def LastSZ(pcSubStr, pnStartingAt)
			return This.FindLastSZ(pcSubStr, pnStartingAt)

	  #====================================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ًZEXTENDED  #
	#====================================================================================#

	def FindNthSZZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("12♥45♥78♥")
		? o1.FindNthSZ(2, "♥", :StartingAt = 3)
		#--> [ "♥", 6 ]
		*/
		nPos = This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()
		aSection = [ nPos, nPos + nLen - 1 ]

		aResult = [ pcSubStr, aSection ]
		return aResult

		def FindNthSCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSZZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSZZCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSZZ(n, pcsubStr, pnStartingAt)
		return This.FindNthSZZCS(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def NthSZZ(n, pcsubStr, pnStartingAt)
			return This.FindNthSZZ(n, pcsubStr, pnStartingAt)

	  #--------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#--------------------------------------------------------------------------------------#

	def FindFirstSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSZZCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSZZ(pcSubStr, pnStartingAt)
		return This.FindFirstSZZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def FirstSZZ(pcSubStr, pnStartingAt)
			return This.FindFirstSZZ(pcSubStr, pnStartingAt)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FindLastSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSZZCS(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSZZ(pcSubStr, pnStartingAt)
		return This.FindLastSZZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def LastSZZ(pcSubStr, pnStartingAt)
			return This.FindLastSZZ(pcSubStr, pnStartingAt)

	    #===========================================================================#
	   #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #
	#===========================================================================#

	def FindNthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		
		aResult = [ pcSubStr, This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def FindNthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSDZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDZCS(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

		def NthSDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSDZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION                                                     #                           #
	#------------------------------------------------------------------------------#

	def FindFirstSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDZCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FirstSDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSDZ(pcSubStr, pnStartingAt, pcDirection)

	    #---------------------------------------------------------------------------#
	   #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #                          #
	#---------------------------------------------------------------------------#

	def FindLastSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDZCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def LastSDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSDZ(pcSubStr, pnStartingAt, pcDirection)

	    #===========================================================================#
	   #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                     #
	#===========================================================================#

	def FindNthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n1 = This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n2 = n1 + Q(pcSubStr).NumberOfChars() - 1
		aResult = [ pcSubStr, [n1, n2] ]
		return aResult

		def FindNthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDZZCS(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

		def NthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                        #                           #
	#------------------------------------------------------------------------------#

	def FindFirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return FindNthSDZZCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDZZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FirstSDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSDZZ(pcSubStr, pnStartingAt, pcDirection)

	    #----------------------------------------------------------------------------#
	   #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING  #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                      #                          #
	#----------------------------------------------------------------------------#

	def FindLastSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return FindNthSDZZCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDZZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def LastSDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSDZZ(pcSubStr, pnStartingAt, pcDirection)

	  #======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- EXTENDED   #
	#======================================================#

	def FindNthXTCS(n, pcSubStr, paOption, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthXT(2, "word", :ReturnSection)
		#--> [30, 33]
		
		? o1.NthXT(2, "word", :Between = ["<<", ">>"])
		#--> 43
		
		? o1.NthXTCS(2, "WORD", :Between = ["<<", ">>"], :CS = FALSE)
		#--> 43

		? o1.FindNthXT(2, "word", :StartingAt = 5)

		
		*/

		# Enabling the syntax :BoundedBy = "*"

		if isList(paOption) and
		   Q(paOption).IsBoundedByNamedParam() and
		   isString(paOption[2])
			aTemp = [paOption[2], paOption[2]]
			paOption[2] = aTemp
		ok

		# CASE 1: ? o1.NthXT(2, "word", :ReturnSection)
		if isString(paOption) and paOption = :ReturnSection
			return This.NthSectionCS(n, pcSubStr, pCaseSensitive)

		# CASE 2: ? o1.NthXT(2, "word", :Between = ["<<",">>"])
		but isList(paOption) and
		    ( Q(paOption).IsBetweenNamedParam() or
		      Q(paOption).IsBoundedByNamedParam()
		    )

			cSubStr1 = ""
			cSubStr2 = ""

			paOption = paOption[2]
			if isList(paOption)
				if Q(paOption).IsPairOfStrings()

					cSubStr1 = paOption[1]
					cSubStr2 = paOption[2]

				but Q(paOption).IsPair() and
				    Q(paOption[1]).IsAString() and
				    Q(paOption[2]).IsAndNamedParam() and
				    Q(paOption[2][2]).IsAString()

					cSubStr1 = paOption[1]
					cSubStr2 = paOption[2][2]
				ok

				nResult = This.FindBetweenCS(
						pcSubStr,
						cSubStr1, cSubStr2,
						pCaseSensitive)[n]

				return nResult
			ok

		# CASE 3: ? o1.FindNthXT(2, "word", :StartingAt = 5)
		but isList(paOption) and Q(paOption).IsStartingAtNamedParam()
			nStartPos = paOption[2]
			if NOT isNumber(nStartPos)
				stzRaise("Incorrect param type! :StartingAt must be a number.")
			ok

			nResult = This.SectionQ(nStartPos, :LastChar).FindNthCS(n, pcSubStr, pCaseSensitive)
			return nResult

		else
			stzRaise("Incorrect format!")
		ok

		#< @FunctionAlternativeForms

		def NthXTCS(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthXTCS(n, pcSubStr, paOption, pCaseSensitive)

		def NthCSXT(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthXTCS(n, pcSubStr, paOption, pCaseSensitive)

		def FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindNthXT(n, pcSubStr, paOption)
		return This.FindNthXTCS(n, pcSubStr, paOption, :CaseSensitive = TRUE)

		def NthXT(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

	  #-------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#-------------------------------------------------------#

	def FirstXTCS(pcSubStr, paOption, pCaseSensitive)
		return This.NthXTCS(1, pcSubStr, paOption, pCaseSensitive)

		#< @FuntionAlternativeForm

		def FindFirstXTCS(pcSubStr, paOption, pCaseSensitive)
			return This.FirstXTCS(pcSubStr, paOption, pCaseSensitive)

		def FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FirstXTCS(pcSubStr, paOption, pCaseSensitive)

		def FirstCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FirstXTCS(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstXT(pcSubStr, paOption)
		return This.NthXTCS(1, pcSubStr, paOption, :CaseSensitive = TRUE)

		def FindFirstXT(pcSubStr, paOption)
			return This.FirstXT(pcSubStr, paOption)

	  #------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#------------------------------------------------------#

	def LastXTCS(pcSubStr, paOption, pCaseSensitive)
		return This.NthXT(:Last, pcSubStr, paOption, pCaseSensitive)

		#< @FuntionAlternativeForm

		def LastCSXT(pcSubStr, pOption, pCaseSensitive)
			return This.LastXTCS(pcSubStr, paOption, pCaseSensitive)

		def FindLastXTCS(pcSubStr, paOption, pCaseSensitive)
			return This.LastXTCS(pcSubStr, paOption, pCaseSensitive)

		def FindLastCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.LastXTCS(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastXT(pcSubStr, paOption)
		return This.LastXTCS(pcSubStr, paOption, :CaseSensitive = TRUE)

		def FindLastXT(pcSubStr, paOption)
			return This.LastXT(pcSubStr, paOption)

	  #============================================#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING   #
	#============================================#

	// Returns the position of the 1st occurrence of the substring inside the string
	// or returns 0 if nothing is found

	def FindFirstCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFirsteCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirst(pcSubstr)
		return This.FindFirstCS(pcSubstr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def FindFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def First(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def PositionOfFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirst(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)
	
		#>

		#< @FunctionMisspelledForms

		def FindFirste(pcSubStr)
			return This.FindFirst(pcSubStr)

		#>
		

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#---------------------------------------------------------#

	def FindFirstZCS(pcSubStr, pCaseSensitive)
		anPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternatives

		def FindFirstCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstZCS(pcSubStr, pCaseSensitive)

		def FirstCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstZCS(pcSubStr, pCaseSensitive)

		def FirstZCS(pcSubStr, pCaseSensitive)
			return This.FindFirstZCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstZ(pcSubStr)
		return This.FindFirstZCS(pcSubStr, :CaseSensitive = TRUE)

		def FirstZ(pcSubStr)
			return This.FindFirstZ(pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstZZCS(pcSubStr, pCaseSensitive)
		aSection = This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstZZCS(pcSubStr, pCaseSensitive)

		def FirstCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstZZCS(pcSubStr, pCaseSensitive)

		def FirstZZCS(pcSubStr, pCaseSensitive)
			return This.FindFirstZZCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstZZ(pcSubStr)
		return This.FindFirstZZCS(pcSubStr, :CaseSensitive = TRUE)

		def FirstZZ(pcSubStr)
			return This.FindFirstZZ(pcSubStr)

	  #-------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#-------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		nStart = 1
		if pcDirection = :Backward
			nStart = This.NumberOfChars()
		ok
			
		nResult = FindNthSDCS(n, pcSubStr, nStart, pcDirection, pCaseSensitive)
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNthD(n, pcSubStr, pcDirection)
		return This.FindNthDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(1, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstD(pcSubStr, pcDirection)
		return This.FindFirstDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#--------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(:Last, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastD(pcSubStr, pcDirection)
		return This.FindLastDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #--------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#--------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDZCS(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

		def FindNthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDZCS(n, pcSubStr, pcDirection, pCaseSensitive)

		def NthDZCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDZCS(n, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthDZ(n, pcSubStr, pcDirection)
		return This.FindNthDZCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def NthDZ(n, pcSubStr, pcDirection)
			return This.FindNthDZ(n, pcSubStr, pcDirection)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDZCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDZCS(1, pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDZCS(pcSubStr, pcDirection, pCaseSensitive)

		def FirstDZCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDZCS(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZ(pcSubStr, pcDirection)
		return This.FindFirstDZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def FirstDZ(pcSubStr, pcDirection)
			return This.FindFirstDZ(pcSubStr, pcDirection)

		#< @FunctionMisspelledForm

		def FindFirtDZ(n, pcSubStr, pcDirection)
			return This.FindFirstDZ(n, pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDZCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDZCS(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		def FindLastDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDZCS(pcSubStr, pcDirection, pCaseSensitive)

		def LastDZCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDZCS(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastDZ(pcSubStr, pcDirection)
		return This.FindLastDZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def LastDZ(pcSubStr, pcDirection)
			return This.FindLastDZ(pcSubStr, pcDirection)

	  #---------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDZZCS(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

		def FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDZZCS(n, pcSubStr, pcDirection, pCaseSensitive)

		def NthDZZCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDZZCS(n, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthDZZ(n, pcSubStr, pcDirection)
		return This.FindNthDZZCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def NthDZZ(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

	  #-----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#-----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDZZCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDZZCS(1, pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDZZCS(pcSubStr, pcDirection, pCaseSensitive)

		def FirstDZZCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDZZCS(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDZZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def FirstDZZ(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		#< @FunctionMisspelledForm

		def FindFirtDZZ(n, pcSubStr, pcDirection)
			return This.FindFirstDZZ(n, pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDZZCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDZZCS(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		def FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDZZCS(pcSubStr, pcDirection, pCaseSensitive)

		def LastDZZCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDZZCS(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastDZZ(pcSubStr, pcDirection)
		return This.FindLastDZZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def LastDZZ(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

	  #=================================================#
	 #      FINDING LAST OCCURRENCE OF A SUBSTRING     #
	#=================================================#

	def FindLastCS(pcSubStr, pCaseSensitive)
		#< TODO: @QtBased | Uses QString2.lastIndexOf()

		/* EXAMPLE

		#                      4     0     6    1
		o1 = new stzString("---***---***---***---")
		? o1.FindLast("***")
		#--> 16

		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT This.ContainsCS(pcSubstr, pCaseSensitive)
			return 0
		ok

		n = This.NumberOfOccurrenceCS(pcSubstr, pCaseSensitive)
		nResult = This.FindNthCS(n, pcsubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm
	
		def FindLastOccurrenceCS(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)
			
		def LastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#>

	def FindLast(pcSubStr)
		return This.FindLastCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def Last(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePosition(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLast(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPosition(pcSubStr)
			return This.FindLast(pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#--------------------------------------------------------#

	def FindLastZCS(pcSubStr, pCaseSensitive)
		anPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def FindLastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastZCS(pcSubStr, pCaseSensitive)

		def LastZCS(pcSubStr, pCaseSensitive)
			return This.FindLastZCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastZ(pcSubStr)
		return This.FindLastZCS(pcSubStr, :CaseSensitive = TRUE)

		def LastZ(pcSubStr)
			return This.FindLastZ(pcSubStr)

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#---------------------------------------------------------#

	def FindLastZZCS(pcSubStr, pCaseSensitive)
		aSection = This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		def FindLastCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastZZCS(pcSubStr, pCaseSensitive)

		def LastZZCS(pcSubStr, pCaseSensitive)
			return This.FindLastZZCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastZZ(pcSubStr)
		return This.FindLastZZCS(pcSubStr, :CaseSensitive = TRUE)

		def LastZZ(pcSubStr)
			return This.FindLastZZ(pcSubStr)

	  #====================================================================#
	 #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING   #
	#====================================================================#

	def FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.FindOccurrences([ 2, 3 ], "ring") #--> [ 9, 17 ]
		*/

		if NOT ( isList(panOccurr) and Q(panOccurr).IsListOfNumbers() )
			StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneTheseNamedParams([ :Of, :OfSubString ])
			# NOTE that IsOneTheseNamedParams() is a misspelled form of
			# IsOneOfTheseNamedParams(). I forgot "These" but hopefully
			# Softanza forgave it ;)

			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPositions = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLenOccurr = len(panOccurr)

		anResult = []
		for i = 1 to nLenOccurr
			anResult + anPositions[panOccurr[i]]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindOccurrencesXTCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		def FindOccurrencesCSXT(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesXT(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN OCCURRENCES OF A SUBSTRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#------------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsXTCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)

		def FindOccurrencesAsSectionsCSXT(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSections(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsXT(panOccurr, pcSubStr)
			return This.FindTheseOccurrencesAsSections(panOccurr, pcSubStr)

		#>

	   #=====================================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING,   #
	 #   STARTING AT A GIVEN POSITION, AND GOING IN A GIVEN DIRECTION      #
	#=====================================================================#

	def FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Resolving params

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfThese([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward
			anPos = This.SectionQ(pnStartingAt, :LastChar).FindCS(pcSubStr, pCaseSensitive)

			nLen = len(anPos)
			nLenSubStr = Q(pcSubStr).NumberOfChars()
	
			
			for i = 1 to nLen
				anResult + (pnStartingAt + anPos[i] - 1)
			next
	
		else // pcDirection = :Bacward
			anResult = This.SectionQ(1, pnStartingAt).
				 	FindCSQ(pcSubStr, pCaseSensitive).Reversed()

		ok

		return anResult


		#< @FunctionAlternativeForms

		def FindOccurrencesSDXTCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindOccurrencesCSSDXT(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindOccurrencesXTSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindOccurrencesSDCSXT(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesSDXT(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		def FindOccurrencesXTSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING AT A GIVEN   #
	 #   POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING THOSE POSITIONS AS SECTIONS      #
	#----------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsXTSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindOccurrencesAsSectionsSDXTCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindOccurrencesAsSectionsSDCSXT(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsXTSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesAsSectionsSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		def FindOccurrencesAsSectionsSDXT(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesAsSectionsSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING STARTING AT A GIVEN POSITION                 #
	#==========================================================#

	def FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesXTSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindOccurrencesSXTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindOccurrencesSCSXT(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesXTS(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)

		def FindOccurrencesSXT(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING   #
	 #   AT A GIVEN POSITION AND RETURNING THOSE POSITIONS AS SECTIONS             #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		aResult = This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsSXTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindOccurrencesAsSectionsSCSXT(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindOccurrencesAsSectionsSXTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsS(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesAsSectionsSCS(panOccurr, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsSXT(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesAsSectionsS(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING GOINING IN A GIVEN DIRECTION                 #
	#==========================================================#

	def FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		if NOT ( isList(panOccurr) and Q(panOccurr).IsListOfNumbers() )
			StzRaise("Incorrect param type! pabOccurr must be a list of numbers.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsDirectionNamedParam()
			pcDirection = pcDirection[2]
		ok

		nStartAt = 1

		if pcDirection = :Backward
			nStartAt = This.NumberOfChars()
		ok

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, nStartAt, pcDirection, pCaseSensitive)

		nLen = len(panOccurr)
		anResult = []
		for i = 1 to nLen
			anResult + anPos[panOccurr[i]]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindOccurrencesXTDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		def FindOccurrencesDXTCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		def FindOccurrencesDCSXT(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesXTD(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)

		def FindOccurrencesDXT(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)

		#>

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING GOING IN   #
	 #   A GIVEN DIRECTION AND RETURNING THOSE POSITIONS  AS SECTIONS              #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		nLen = len(anPos)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		anResult = []
		for i = 1 to nLen
			anResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsDXTCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		def FindOccurrencesAsSectionsDCSXT(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindOccurrencesAsSectionsDXTCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsDXT(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)

		#>

	   #=============================================#
	  #   FINDING NEXT OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION              #
	#=============================================#

	# TODO: Add FindAllNextAsSectionsCS()
	# 	    FindNextAsSectionCS()

	def FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(pnStartingAt, :LastChar)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		anResult = []

		if len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt).Content()
		ok

		return anResult
		
	#-- WITHOUT CASESENSITIVITY

	def FindAllNext(pcSubStr, pnStartingAt)
		aResult = This.FindAllNextCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)
		return aResult

	   #-------------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION                  #
	#-------------------------------------------------#

	# TODO:
	# 	def FindAllPreviousAsSection()
	# 	def FindAllNextAsSection()

	def FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(1, pnStartingAt)
		anPositions = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPositions

	#-- WITHOUT CASESENSITIVITY

	def FindAllPrevious(pcSubStr, pnStartingAt)
		aResult = This.FindAllPreviousCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)
		return aResult

	   #=====================================================#
	  #      FINDING NTH NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                   #
	#=====================================================#

	def FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if NOT BothAreNumbers(n, nStart)
			StzRaise("Incorrect param type! n and nStart must be numbers.")
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")

		ok

		# Early checks (gains performance for large strings)

		if pcSubStr = ""
			return 0
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		nLen = This.NumberOfChars()

		if nStart = nLen
			return 0
		ok

		if (NOT Q(n).IsBetween(1, nLen - nStart)) or
		   (NOT Q(nStart).IsBetween(1, nLen - n))

			return 0
		ok

		if n = nLen and
		   This.LastCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
			return nLen
		ok

		# Full check

		nResult  = This.SectionQ(nStart, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

		if nResult != 0
			nResult += nStart - 1
		ok

		return nResult

	def FindNthNext(n, pcSubStr, nStart)
		return This.FindNthNextCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------------------#
	 #  FINFING NTH NEXT OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#--------------------------------------------------------------------------------------#

	def FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY
	
	def FindNthNextAsSection(n, pcSubStr, nStart )
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)
	
	   #=========================================================#
	  #      FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                       #
	#=========================================================#

	# TODO: Add FindNthPreviousAsSectionsCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		# Resolving params

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isString(nStart) and Q(nStart).IsEither(:Last, :Or = :LastChar)
			nStart = This.NumberOfChars()
		ok

		if isString(n)
			oNString = Q(n)

			if oNString.IsEither(:First, :Or = :FirstOccurrence)
				n = 1

			but oNString.IsEither(:Last, :Or = :LastOccurrence)
				n = This.SectionQ(1, nStart).NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT BothAreNumbers(n, nStart)
			StzRaise("Incorrect param type! n and nStart must be numbers.")
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")

		ok

		# Early checks (gains performance for large strings)

		if pcSubStr = ""
			return 0
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		nLen = This.NumberOfChars()

		if nStart = 1
			return 0
		ok

		if (NOT Q(n).IsBetween(1, nLen - 1)) or
		   (NOT Q(nStart).IsBetween(n + 1, nLen))

			return 0
		ok

		if n = nLen and
		   This.FirstCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
			return nLen
		ok

		# Full check (only occurrences of pcSubStr are parsed, not every char)

		nPos = nStart + 1
		nFound = 0
		i = 0

		while TRUE
			i++
			if i > nLen
				exit
			ok

			nPos = This.FindPreviousCS(pcSubStr, :StartingAt = nPos, pCaseSensitive)

			if nPos = 0
				exit
			else
				nFound++
				if nFound = n
					return nPos
				ok
			ok
		end

		return 0

	def FindNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------------------------#
	 #  FINFING NTH PREVIOUS OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#------------------------------------------------------------------------------------------#

	def FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY
	
	def FindNthPreviousAsSection(n, pcSubStr, nStart )
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	   #-------------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION               #
	#-------------------------------------------------#

	# TODO: FindNextW() FindPreviousW()

	def FindNextCS(pcSubStr, nStart, pCaseSensitive)
		#< QTBased | Uses: QString.IndexOf() >

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if NOT isNumber(nStart)
			StzRaise("Incorrect param type! nStart must be a number.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = QStringObject().indexof(pcSubStr, nStart, pCaseSensitive) + 1

		return nResult
		

	#-- WITHOUT CASESENSITIVITY

	def FindNext(pcSubStr, nStart)
		return This.FindNextCS(pcSubStr, nStart, :CaseSensitive = TRUE)

	   #-----------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING FROM A GIVEN POSITION N               #
	#-----------------------------------------------------#

	def FindPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pcSubStr = "" or
		   NOT This.ContainsCS(pcSubStr, pCaseSensitive)

			return 0
		ok

		nResult = This.SectionQ(1, pnStartingAt - 1).FindLastCS(pcSubStr, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindPrevious(pcSubStr, nStart)
		return This.FindPreviousCS(pcSubStr, nStart, :CaseSensitive = TRUE)
	
	  #-------------------------------------------------#
	 #      FINDING ALL OCCURRENCES OF A SUBSTRING     #
	#=================================================#

	def FindCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		# Resolving the pcSubStr param

		if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
			return This.FindManyCS(pcSubStr, pCaseSensitive)
		ok

		if isList(pcSubStr) and
			( Q(pcSubStr).IsOfNamedParam() or
			  Q(pcSubStr).IsOfSubStringNamedParam() )

			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return []
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nLenString = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		if nLenString < nLenSubStr
			return []
		ok

		anResult = []

		bContinue = TRUE
		nPos = 0

		while bContinue
			
			nPos = This.QStringObject().indexOf(pcSubStr, nPos, pCaseSensitive) + 1

			if nPos = 0
				bContinue = FALSE
			else
				anResult + nPos
			ok
		end

		return anResult

		#< @FunctionFluentForm

		def FindCSQ(pcSubStr, pCaseSensitive)
				return This.FindCSQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms : See bottom of file #>

	#-- WITHOUT CASESENSITIVITY

	def Find(pcSubStr)
		return This.FindCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindQ(pcSubStr)
			return This.FindQR(pcSubStr, :stzList)
		
		def FindQR(pcSubStr, pcReturnType)
				return This.FindCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms : See bottom of file #>

	  #---------------------------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#=======================================================================================#

	def FindZCS(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyZCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindAllOccurrencesZCSQ(pcSubStr, pCaseSensitive)
				return This.FindAllOccurrencesZCSQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindAllOccurrencesZCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindZCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAZCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindZCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindZCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindCSZ(pcSubStr, pCaseSensitive)
			return This.FindZCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindZ(pcSubStr)
		return This.FindZCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindZQ(pcSubStr)
			return This.FindZQR(pcSubStr, :stzList)
		
		def FindZQR(pcSubStr, pcReturnType)
				return This.FindZCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #-------------------------------------------------------------------------------------#
	 # FINDING ALL OCCURRENCES OF A SUBSTRING -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindZZCS(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyZZCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindZZCSQ(pcSubStr, pCaseSensitive)
				return This.FindZZCSQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindZZCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindZZCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindZZCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindZZCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindZZCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindCSZZ(pcSubStr, pCaseSensitive)
			return This.FindZZCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindZZ(pcSubStr)
		return This.FindZZCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindZZQ(pcSubStr)
			return This.FindZZQR(pcSubStr, :stzList)
		
		def FindZZQR(pcSubStr, pcReturnType)
				return This.FindsZZCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #  FINDING POSITIONS OF ANTI-PARTS OF A SUBSTRING  #
	#--------------------------------------------------#

	def AntiFindCS(pcSubStr, pCaseSensitive)
		return QR( This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive), :stzListOfPairs ).FirstItems()

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pcsubStr)
		return This.AntiFindCS(pcSubStr, :CaseSensitive = TRUE)

	  #===============================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING IN A GIVEN DIRECTION  #
	#===============================================================#

	def FindDCS(pcSubStr, pcDirection, pCaseSensitive)
	
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		if pcDirection = :Forward or pcDirection = :Default
			return This.FindCS(pcSubStr, pCaseSensitive)

		but pcDirection = :Backward
			return This.FindAllCSQ(pcSubStr, pCaseSensitive).Reversed()

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok

		#< @FunctionFluentForm

		def FindDCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>
 
	#-- WITHOUT CASESENSITIVITY

	def FindD(pcSubStr, pcDirection)
		return This.FindDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDQ(pcSubStr, pcDirection)
			return This.FindDQR(pcSubStr, pcDirection, :stzList)
		
		def FindDQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#>

	   #-----------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                        #
	#-----------------------------------------------------------------------#

	def FindDZCS(pcSubStr, pcDirection, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindDZCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDZCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDZCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDZCS(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDZ(pcSubStr, pcDirection)
		return This.FindDZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDZQ(pcSubStr, pcDirection)
			return This.FindDZQR(pcSubStr, pcDirection, :stzList)
		
		def FindDZQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDZCSQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

	   #-----------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS            #
	#-----------------------------------------------------------------------#

	def FindDZZCS(pcSubStr, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		if pcDirection = :Forward or pcDirection = :Default
			return [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]

		but pcDirection = :Backward
			return [ pcSubStr, This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed() ]

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok
		

		#< @FunctionFluentForm

		def FindDZZCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDZZCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDZZCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDZZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDZZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDZZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDZZCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDZZCS(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDZZ(pcSubStr, pcDirection)
		return This.FindDZZCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDZZQ(pcSubStr, pcDirection)
			return This.FindDZZQR(pcSubStr, pcDirection, :stzList)
		
		def FindDZZQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDZZCSQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #=========================================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING STARTING FROM A GIVEN POSITION  #
	#=========================================================================#

	def FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Doing the job

		anPos = This.SectionQ(pnStartingAt, :LastChar).FindCS(pcSubStr, pCaseSensitive)

		aResult = []

		if Len(anPos) > 0
			aResult = StzListOfNumbersQ(anPos).AddedToEach(pnStartingAt - 1)
		ok

		return aResult


		#< @FunctionFluentForm

		def FindSCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindS(pcSubStr, pnStartingAt)
		return This.FindSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSQ(pcSubStr, pnStartingAt)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSQR(pcSubStr, pnStartingAt, pcReturnType)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                          #
	#-------------------------------------------------------------------------#

	def FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindSZCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.FindSZCSQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def FindSZCSQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindSZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSZ(pcSubStr, pnStartingAt)
		return This.FindSZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSZQ(pcSubStr, pnStartingAt)
			return This.FindSZQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.FindSZCSQR(pcSubStr, pnStartingAt, :CaseSensitive = TRUE, pcReturnType)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS              #
	#-------------------------------------------------------------------------#

	def FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindSZZCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.FindSZZCSQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def FindSZZCSQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindSZZCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSZZ(pcSubStr, pnStartingAt)
		return This.FindSZZCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSZZQ(pcSubStr, pnStartingAt)
			return This.FindSZZQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindsSZZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.FindSZZCSQR(pcSubStr, pnStartingAt, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #==========================================================#
	 #  FINDING OCCURRENCES OF A SIUBSTRING IN A GIVEN SECTION  #
	#==========================================================#

	def FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
			n1 = n1[2]
		ok

		if isString(n1)
			if Q(n1).IsOneOfThese([ :First, :FirstChar ])
				n1 = 1
			but Q(n1).IsOneOfThese([ :Last, :LastChar ])
				n1 = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(n1)
			StzRaise("Incorrect param type! n1 must be a number.")
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
			n2 = n2[2]
		ok

		if isString(n2)
			if Q(n2).IsOneOfThese([ :Last, :LastChar ])
				n2 = This.NumberOfChars()
			but Q(n1).IsOneOfThese([ :First, :FirstChar ])
				n2 = 1
			ok
		ok

		if NOT isNumber(n2)
			StzRaise("Incorrect param type! n2 must be a number.")
		ok

		# Doing the job

		anPos = This.SectionQ(n1, n2).FindCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		n1 = Min([ n1, n2 ])

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pcSubStr, n1, n2)
		return This.FindInSectionCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)
		
	   #----------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SIUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS               #
	#----------------------------------------------------------#

	def FindInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		anPos = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nLen = len(anPos)

		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult
	

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionAsSections(pcSubStr, n1, n2)
		return This.FindInSectionAsSectionsCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------#
	 #  FINDING OCCURRENCES OF A SUBSTRING IN SOME GIVEN SECTIONS  #
	#-------------------------------------------------------------#

	def FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		anResult = StzListOfPairsQ( This.FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive) ).FirstItems()
		return anResult

		def FindInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pcSubStr, paSections)
		return This.FindInSectionsCS(pcSubStr, paSections, :CaseSensitive = TRUE)

		def FindInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

	   #----------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN SOME GIVEN SECTION SECTIONS   #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                           #
	#----------------------------------------------------------------------#

	def FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
			next
		next

		return aResult

		def FindInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionsAsSections(pcSubStr, paSections)
		return This.FindInSectionsAsSectionsCS(pcSubStr, paSections, :CaseSensitive = TRUE)

		def FindInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInManySectionsAsSections(pcSubStr, paSections)

	   #===========================================================================#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                           #
	#===========================================================================#

	def FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward or pcDirection = :Default
			anResult = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		else // pcDirection = :Backward

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

			anResult = This.SectionQ(1, pnStartingAt).
					FindCSQ(pcSubStr, pCaseSensitive).
					Reversed()
		ok

		return anResult

	#-- WITHOUT CASESENSITIVIY

	def FindSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#-------------------------------------------------------------------------------#

	def FindSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		#< @FunctionAlternativeForm

		def FindSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVIY

	def FindSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------#

	def FindSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		#< @FunctionAlternativeForm

		def FindSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVIY

	def FindSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDZZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  FINDING OCCURRENCES OF CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------------------------#

	def FindW(pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCpndition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @char ir @substring but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			anPos = This.FindSubStringsW(pcCondition)
			return anPos

		else

			anPos = This.FindCharsW(pcCondition)
			return anPos
		ok

	  #------------------------------------------------------------#
	 #  FINDING OCCURRENCES OF CHARS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------------------#

	def FindCharsW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ')'
		nLen = This.NumberOfChars()
		anResult = []

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				anResult + @i
			ok
		next

		return anResult

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#------------------------------------------------------------------#

	def FindSubStringsAsSectionsW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		acSubStr = This.SubStringsU() # Or UniqueSubStrings()

		nLen = len(acSubStr)

		cCode = 'if (' + StzCCodeQ(pcCondition).Transpiled() + ') { bOk = TRUE }'

		aResult = []
		
		for i = 1 to nLen
			@substring = acSubStr[i]
			bOk = FALSE
			eval(cCode)

			if bOk
				aSections = This.FindAsSections(acSubStr[i])
				nLenSections = len(aSections)
				for j = 1 to nLenSections
					aResult + aSections[j]
				next
			ok
		next

		aResult = QR(aResult, :stzListOfPairs).Sorted()
		return aResult

		#< @FunctionAlternativeForm

		def FindSubStringAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#>

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#------------------------------------------------------------------#

	def FindSubStringsW(pcCondition)
		aSections = This.FindSubStringsAsSectionsW(pcCondition)
		anPos = QR(aSections, :stzListOfPairs).FirstItems()
		return anPos

		def FindSubStringW(pcCondition)
			return This.FindSubStringsW(pcCondition)

	  #--------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#--------------------------------------------------------------------------#

	def FindNthW(n, pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCpndition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @char ir @substring but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.FindNthSubStringW(n, pcCondition)

		else
			return This.FindNthCharW(n, pcCondition)
		ok

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------#

	def FindNthCharW(n, pcCondition)
		# TODO: Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextCharW() and use it instead.

		if isString(n)
			if n = :FirstChar or n = :First
				n = 1
			but n = :LastChar or n = :Last
				n = nLen
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anPos = This.FindCharsW(pcCondition)
		nResult = anPos[n]

		return nResult

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------#

	def FindNthSubStringW(n, pcCondition)
		# TODO: Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextSubStringW() and use it instead.

		if isString(n)
			if n = :FirstSubString or n = :First
				n = 1
			but n = :LastSubString or n = :Last
				n = nLen
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anPos = This.FindSubStringsW(pcCondition)
		nResult = anPos[n]

		return nResult

	  #----------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------------------#

	def FindFirstW(pcCondition)
		return This.FindNthW(1, pcCondition)

	def FindFirstCharW(pcCondition)
		return This.FindNthCharW(1, pcCondition)

	def FindFirstSubStringW(pcCondition)
		return This.FindNthSubStringW(1, pcCondition)

	  #---------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#---------------------------------------------------------------------------#

	def FindLastW(pcCondition)
		return This.FindNthW(:Last, pcCondition)

	def FindLastCharW(pcCondition)
		return This.FindNthCharW(:Last, pcCondition)

	def FindLastSubStringW(pcCondition)
		return This.FindNthSubStringW(:Last, pcCondition)

	  #-----------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- ZZ-EXTENDED  # 
	#-----------------------------------------------------------#

	def FindManyZZCS(pacSubStr, pCaseSensitive)
		aResult = []
		nLen = len(pacSubStr)

		for i = 1 to nLen
			cSubStr = pacSubStr[i]
			nLenStr = Q(cSubStr).NumberOfChars()

			anPos = This.FindCS(cSubStr, pCaseSensitive)
			nLenPos = len(anPos)
			aSections = []

			for j = 1 to nLenPos
				aSections + [ anPos[j], anPos[j] + nLenStr - 1 ]
			next

			aResult + [ cSubStr, aSections ]

		next

		return aResult

		#< @FunctionAlternativeForm

		def FindManyCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyZZCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindManyZZ(pacSubStr)
		return This.FindManyZZCS(pacSubStr, :CaseSensitive = TRUE)

	  #----------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- Z-EXTENDED  # 
	#----------------------------------------------------------#

	def FindManyZCS(pacSubStr, pCaseSensitive)
		aManyZZ = This.FindManyZZCS(pacSubStr, pCaseSensitive)
		nLen = len(aManyZZ)

		aResult = []

		for i = 1 to nLen
			
			aSections = aManyZZ[i][2]
			nLenSections = len(aSections)

			anPositions = []
			for j = 1 to nLenSections
				anPositions + aSections[j][1]
			next

			aResult + [ aManyZZ[i][1], anPositions ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindManyCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyZCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindManyZ(pacSubStr)
		return This.FindManyZCS(pacSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME  # 
	#--------------------------------------------#

	def FindManyCS(pacSubStr, pCaseSensitive)
		/*
		o1 = new stzString("My name is Mansour. What's your name please?")
		? o1.FindManyCS( [ "name", "your", "please" ], :CS = TRUE )

		#--> [ [ 4, 33 ], [ 28 ], [ 38 ] ]

		*/

		aResult = []

		for str in pacSubStr

			aResult + This.FindAllCS(str, pCaseSensitive)
		next

		aResult = Q(aResult).FlattenQ().Sorted()
		return aResult

		#< @FunctionFluentForm

		def FindManyCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, :stzList)
	
		def FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(pacSubStr)
		return This.FindManyCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindManyQ(pacSubStr)
			return This.FindManyQR(pacSubStr, :stzList)
	
		def FindManyQR(pacSubStr, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindMany(pacSubStr) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindMany(pacSubStr) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- RETURN POSITIONS AS SECTIONS  # 
	#----------------------------------------------------------------------------#

	def FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		nLenSubStr = len(pacSubStr)

		aResult = []

		for i = 1 to nLenSubStr
			aSections = This.FindAsSectionsCS(pacSubStr[i], pCaseSensitive)

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = Q(aResult).ToStzListOfPairs().Sorted()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindManyAsSections(pacSubStr)
		return This.FindManyAsSectionsCS(pacSubStr, :CaseSensitive = TRUE)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindXTCS(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :InBetween = [ "<<", :And = ">>" ])
			but  oP2.IsInBetweenNamedParam()
				p2 = p2[2]
				return This.FindInBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenIBCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSCS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindXTCS( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindXTCS( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindXTCS( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindXTCS( p1, :InSection = [nPos, :LastChar], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindXTCS( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

				ok

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindXTCS( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitve)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitve)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindXTCS( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindXTCS( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindXTCS( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					return This.FindXTCS( p1[2], :InSection = [n, :LastChar], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindXTCS( p1[2], :InSection = [p2[2], :LastChar], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindXTCS( p1[2], :InSection = [ p2[2], :LastChar ], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionAlternativeForm

		def FindCSXT(p1, p2, pCaseSensitive)
			return This.FindXTCS(p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindXTCS(p1, p2, :CaseSensitive = TRUE)

	  #=================================================#
	 #  FINDING THINGS AS SECTIONS, THE EXTENDED FORM  #
	#=================================================#

	def FindAsSectionsXTCS(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindAsSectionsXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByAsSectionsCS(p1, p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InBetween = [ "<<", :And = ">>" ])
			but  oP2.IsInBetweenNamedParam()
				p2 = p2[2]
				return This.FindInBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsIBCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				anPos = This.SectionQ(p2[2]).FindCS(p1, pCaseSensitive)
				if len(anPos) = 0
					return []
				ok

				anPos = QR(anPos, :stzListOfNumbers).AddedToEach(p2[2])
				nLen = Q(p1).NumberOfChars()

				aSections = []
				for i = 1 to nLen
					aSections + [ anPos[i], anPos[i] + nLen - 1 ]
				next

				return aSections

			# FindAsSectionsXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsXTCS( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsXTCS( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindAsSectionsXTCS( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindAsSectionsXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstAsSectionsCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsXTCS( p1, :InSection = [nPos, :LastChar], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsXTCS( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAsSectionsXTCS( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

			# FindAsSectionsXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenAsSectionCS(n, p1[2], p2[1], p2[2], pCaseSensitve)

			# FindAsSectionsXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedAsSectionByCS(n, p1[2], p2, pCaseSensitve)

			# FindAsSectionsXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthAsSectionCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindAsSectionsXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindAsSectionXTCS( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsXTCS( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindAsSectionsXTCS( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindAsSectionsXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					return This.FindAsSectionsXTCS( p1[2], :InSection = [n, :LastChar], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsXTCS( p1[2], :InSection = [p2[2], :LastChar], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAsSectionsXTCS( p1[2], :InSection = [ p2[2], :LastChar ], pCaseSensitive )

			# FindAsSectionsXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenAsSectionsCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindAsSectionsXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByAsSectionsCS(p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				aSections = This.SectionQ(p2[1], p2[2]).FindAsSectionsCS(p1, pCaseSensitive)
				nLen = len(aSections)
				nLenSubStr = Q(p2).NumberOfChars()

				aResult = []

				for i = 1 to nLen
					aResult + [ (aSections[i][1] + nLenSubStr - 1), (aSections[i][2] + nLenSubStr - 1) ]
				next

				return aResult
			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionAlternativeForm

		def FindAsSectionsCSXT(p1, p2, pCaseSensitive) # A misspelled form because CS should be always at the end!
			return This.FindAsSectionsXTCS(p1, p2, pCaseSensitive)

		def FindAsSectionXTCS(p1, p2, pCaseSensitive) # Without an (s) after Section
							      # We need it because some forms
							      # return definetly only one section
							      # like FindAsSectionXT( :3rd = "*"n :InSection = ...)

			return This.FindAsSectionsXTCS(p1, p2, pCaseSensitive)

		def FindAsSectionCSXT(p1, p2, pCaseSensitive)
			return This.FindAsSectionsXTCS(p1, p2, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVE

	def FindAsSectionsXT(p1, p2)
		return This.FindAsSectionsXTCS(p1, p2, :CaseSensitive = TRUE)

	   #=====================================================#
	  #   CHECKING IF STRING OCCURES BEFORE/AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST              #
	#=====================================================#

	def OccursCS( pcBeforeOrAfter, pIn, pCaseSensitive )
		# TODO: Generalise this fuction so pIn can also be a list
		# TODO: Implement the same function in all other types

		/* EXAMPLE

		o1 = new stzString("ONE")

		? o1.Occurs( :Before = "TWO", :In = "***ONE***TWO***")	#--> TRUE
		? o1.Occurs( :After = "TWO", :In = "***ONE***TWO***")	#--> FALSE

		? o1.Occurs( :Before = "two", :In = [ "***", "ONE", "***", "TWO", "***" ])
		#--> TRUE
		? o1.Occurs( :After = "TWO", :In = [ "***", "ONE", "***", "TWO", "***" ])
		#--> FALSE

		*/
		cBeforeOrAfter = ""

		if isList(pcBeforeOrAfter) and Q(pcBeforeOrAfter).IsBeforeOrAfterNamedParam()
			cTemp = pcBeforeOrAfter[1]

			pcBeforeOrAfter = pcBeforeOrAfter[2]
		ok

		if NOT isString(pcBeforeOrAfter)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok
	

		if isString(pIn)
			oStr = new stzString(pIn)
	
			nThis  = oStr.FindFirstCS( This.Content(), pCaseSensitive )
			nOther = oStr.FindFirstCS( pcBeforeOrAfter, pCaseSensitive )

		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)

				nThis  = oListStr.FindFirstCS( This.Content(), pCaseSensitive )
				nOther = oListStr.FindFirstCS( pcBeforeOrAfter, pCaseSensitive )
			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
	
					nThis  = oList.FindFirst( This.Content() )
					nOther = oList.FindFirst( pcBeforeOrAfter )
						
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nThis  = oList.FindFirst( This.ContentQ().Lowercased() )
					nOther = oList.FindFirst( pcBeforeOrAfter )

				ok
			ok

		ok

		bResult = FALSE

		if cTemp = :After
			bResult = nThis > nOther

		but cTemp = :Before
			bResult = nThis < nOther
		ok

		return bResult

	#-- WITHOUT CASESENSITIVTY

	def Occurs(pcBeforeOrAfter, pIn)
		return This.OccursCS(pcBeforeOrAfter, pIn, :CaseSensitive = TRUE)

	   #-----------------------------------------------#
	  #   CHECKING IF STRING OCCURES BEFORE A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST        #
	#-----------------------------------------------#

	def OccursBeforeCS( pcSubStr, pIn, pCaseSensitive )
		return This.OccursCS( :Before = pcSubStr, pIn, pCaseSensitive)

	#-- WITHOUT CASESENSITIVTY

	def OccursBefore(pcSubStr, pIn)
		return This.OccursBeforeCS( pcSubStr, pIn, :CaseSensitive = TRUE )

	   #----------------------------------------------#
	  #   CHECKING IF STRING OCCURES AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST       #
	#----------------------------------------------#

	def OccursAfterCS( pcSubStr, pIn, pCaseSensitive )
		return This.OccursCS( :After = pcSubStr, pIn, pCaseSensitive)

	#-- WITHOUT CASESENSITIVTY

	def OccursAfter(pcSubStr, pIn)
		return This.OccursAfterCS( pcSubStr, pIn, :CaseSensitive = TRUE )

	  #-------------------------------------------------------------------#
	 #   CHECKING IF STRING OCCURES N TIMES IN AN OTHER STRING OR LIST   #
	#-------------------------------------------------------------------#

	def OccursNTimesCS( n, pIn, pCaseSensitive )

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok
	
		nOccurrence = 0

		if isString(pIn)
			oStr = new stzString(pIn)
			nOccurrence  = oStr.NumberOfOccurrenceCS( This.Content(), pCaseSensitive )

		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)
				nOccurrence  = oListStr.NumberOfOccurrenceCS( This.Content(), pCaseSensitive )

			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
					nOccurrence  = oList.NumberOfOccurrence( This.Content() )
		
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nThis  = oList.FindFirst( This.ContentQ().Lowercased() )
					nOccurrence  = oList.NumberOfOccurrence( This.Content() )
		
				ok
			ok

		ok

		bResult = FALSE

		if nOccurrence = n
			bResult = TRUE
		ok

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def OccursNTimes( n, pIn )
		return This.OccursNTimesCS( n, pIn, :CaseSensitive = TRUE )

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE NTH TIME,       #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheNthTimeCS(n, pIn, pnAt, pCaseSensitive)
		/* EXAMPLE

		? Q("*").OccursForTheNthTime( 1, :In = "a*b*c*d", :AtPosition = 2 )
		#--> TRUE

		? Q("*").OccursForTheNthTime( 3, :In = "a*b*c*d", :AtPosition = 6 )
		#--> TRUE

		*/

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok

		if isList(pnAt) and Q(pnAt).IsAtOrAtPositionNamedParam()
			pnAt = pnAt[2]
		ok
	
		if NOT isNumber(pnAt)
			StzRaise("Incorrect param type! pAt must be a number.")
		ok

		nNthOccurrence = 0

		if isString(pIn)
			oStr = new stzString(pIn)
			nNthOccurrence = oStr.NthOccurrenceCS( n, This.String(), pCaseSensitive)
	
		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)
				nNthOccurrence  = oListStr.NthOccurrenceCS( n, This.String(), pCaseSensitive)

			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
					nNthOccurrence  = oList.NthOccurrence( n, This.String() )
		
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nNthOccurrence  = oList.NthOccurrence( n, This.String() )
		
				ok
			ok

		ok


		if nNthOccurrence = pnAt
			return TRUE

		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheNthTime(n, pIn, pnAt)
		return This.OccursForTheNthTimeCS(n, pIn, pnAt, :CaseSensitive = TRUE)

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE FIRST TIME,     #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheFirstTimeCS(pIn, pnAt, pCaseSensitive)
		return This.OccursForTheNthTimeCS(1, pIn, pnAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheFirstTime(pIn, pnAt)
		return This.OccursForTheFirstTimeCS(pIn, pnAt, :CaseSensitive = TRUE)

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE LAST TIME,      #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheLastTimeCS(pIn, pnAt, pCaseSensitive)
		return This.OccursForTheNthTimeCS(:Last, pIn, pnAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheLastTime(pIn, pnAt)
		return This.OccursForTheLastTimeCS(pIn, pnAt, :CaseSensitive = TRUE)

	  #===================================================#
	 #   FINDING BY PATTERN (AN ALTERNATIVE TO REGEXP)   # TODO (FUTURE)
	#===================================================#

	// Finds all the occurrences of a given substring in the string
	// depending on the provided format
	def FindPattern(paFormat) // TODO
		/* ... */

		StzRaise("FindPattern() function is not implemented yet!")

	def FindInside(pcTemplate) // TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInside("KLM", 'amc@bmi') #--> 10

		o1.FindInside("KLM", lower("AMC") + '@' + lower("BMI") #-->

		*/

		/* ... */

		StzRaise("FindInside() function is not implemented yet!")

	def FindInsideW(pcTemplate, pcCondition) # TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInsideW("KLM", :Where = [
			'{ @(3).CharsBefore = "amc" }',
			'{ @(3).CharsAfter = "bmi" }'
		])
		*/

		/* ... */

		StzRaise("FindInsideW() function is not implemented yet!")


	  #===============================================================#
	 #  FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS  #
	#===============================================================#

	def FindAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"
		? o1.FindAsSections( "ring" )
		#--> [ [7, 10], [24, 27] ]

		*/

		if isList(pcSubStr)
			return This.FindManyAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		anFirstPos = This.FindCS(pcSubStr, pCaseSensitive)

		aResult = []

		if len(anFirstPos) > 0
			nLen = StzStringQ(pcSubStr).NumberOfChars()
			anLastPos = StzListOfNumbersQ(anFirstPos).AddToEachQ(nLen-1).Content()
	
			aResult = StzListQ(anFirstPos).AssociatedWith(anLastPos)
		ok

		return aResult

		#< @FunctionFlunentForm

		def FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>


	#-- WITHOUT CASESENSITIVITY

	def FindAsSections(pcSubStr)
		return This.FindAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQR(pcSubStr, :stzList)

		def FindAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- D/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		aResult = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- S/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Doing the job

		aResult = []

		anPos1 = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if len(anPos1) > 0
			anPos2 = StzListOfNumbersQ(anPos1).AddedToEach(Q(pcSubStr).NumberOfChars() - 1)
			aResult = Association([ :Of = anPos1, :And = anPos2 ])
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsS(pcSubStr, pnStartingAt)
		return This.FindAsSectionsSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                    #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param (because we will use it below)

		if isList(pcSubStr) and Q(pcSubStr).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		anPos = This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- Z/EXTENDED                      #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAllSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def FindAsSectionsSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAsSectionsSDZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- ZZ/EXTENDED                     #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def FindAsSectionsSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAsSectionsSDZZCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDZZCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #=====================================================================#
	 #   FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS ANTI-SECTIONS  #
	#=====================================================================#

	def FindAsAntiSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"

		? o1.FindAsSections("ring")
		#--> [ [7, 10], [24, 27] ]

		? o1.FindAsAntiSections("ring")
		#--> [ [1, 6], [11, 23], [28, 28] ]

		*/

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

		#< @FunctionFlunentForm

		def FindAsAntiSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSections(pcSubStr)
		return This.FindAsAntiSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindAsAntiSectionsQ(pcSubStr)
			return This.FindAsAntiSectionsQR(pcSubStr, :stzList)

		def FindAsAntiSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsAntiSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- D/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- S/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aSections = This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsS(pcSubStr, pnStartingAt)
		return This.FindAsAntiSectionsSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS ANTISECTIONS, STARTING FROM A GIVEN  #
	 #  POSITION, AND GOING IN A GIVEN DIRECTION                    #
	#--------------------------------------------------------------#

	def FindAsAntiSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsAntiSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #=========================================================================#
	 #   FINDING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#=========================================================================#

	def FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		/* EXAMPLE 1:

		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindBetweenCS("word", "<<", ">>", :CaseSensitive = FALSE)
		#--> [ 9, 41 ]

		EXAMPLE 2:

		o1 = new stzString("12*A*33*A*")
		? o1.FindBetween("A", "*", "*")
		*/

		# Checking params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT isString(pcBound1)
			StzRaise("Incorrect param type! pcBound1 must be a string.")
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT isString(pcBound2)
			StzRaise("Incorrect param type! pcBound2 must be a string.")
		ok
	
		nLenBound1 = Q(pcBound1).NumberOfChars()

		# Doing the job

		anPos = This.FindAllCS( pcBound1 + pcSubStr + pcBound2, pCaseSensitive )

		anResult = []

		if len(anPos) > 0
			anResult = QR(anPos, :stzListOfNumbers).AddedToEach(nLenBound1)
		ok

		return anResult

		#< @FunctionFluentForm

		def FindBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

			def FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off
	
		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile #>

		def FindBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

	#-- WITHOUT CASESENSITIVITY

	def FindBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

			def FindBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
				return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile #>

		def FindBoundedBy(pcSubStr, pacBounds)
			return This.FindBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS -- IB() EXTENDED  #
	#---------------------------------------------------------------------#

	def FindBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		anPos = This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if len(anPos) = 0
			return []
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		anResult = QR(anPos, :stzListOfNumbers).AddedToEach( - nLenBound1 )

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBoundedByAsSectionsIBCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsIBCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isLisy(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenAsSectionsIBCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByAsSectionsIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByAsSectionsIBCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSectionsIB(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsIB(cSubStr, pcBound1, pcBound2)
			return This.FindBetweenAsSectionsIB(pcSubStr, pcBound1, pcBound2)

		def FindBoundedByAsSectionsIB(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsIBCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByAsSectionsIB(pcSubStr, pacBounds)
			return FindBoundedByAsSectionsIB(pcSubStr, pacBounds)

	  #-----------------------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS -- IB() EXTENDED  #
	#-----------------------------------------------------------------------------------#

	def FindBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen = len(aSections)
		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + [ aSections[i][1] - nLenBound1, aSections[i][2] + nLenBound2 ]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenIBCS(cSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenIBCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isLisy(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenIBCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenIB(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenIBCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenIB(cSubStr, pcBound1, pcBound2)
			return This.FindBetweenIB(pcSubStr, pcBound1, pcBound2)

		def FindBoundedByIB(pcSubStr, pacBounds)
			return This.FindBoundedByIBCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByIB(pcSubStr, pacBounds)
			return FindBoundedByIB(pcSubStr, pacBounds)

	  #--------------------------------------------------------#
	 #   FINDING NTH SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#--------------------------------------------------------#

	def FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if n = :First or n = :FirstSubString
			n = 1
		but n = :Last or n = :LastSubString
			n = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		ok

		anPositions = This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = anPositions[n]
		return nResult

		def FindNthSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetween(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthBetween(n, pcSubStr, pcBound1, pcBound2)

	  #----------------------------------------------------------#
	 #   FINDING FIRST SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#----------------------------------------------------------#

	def FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = This.FindNthBetweenCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		def FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstBetween(pcSubStr, pcBound1, pcBound2)

	  #----------------------------------------------------------#
	 #   FINDING LAST SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#----------------------------------------------------------#

	def FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = This.FindNthBetweenCS(:Last, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		def FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindLastBetween(pcSubStr, pcBound1, pcBound2)

	   #-------------------------------------------------------------#
	  #   FINDING ALL OCCURRENCES OF A SUBSTRING BETWEEN            #
	 #   TWO OTHER SUBSTRINGS AND RETURN THEIR RELATIVE SECTIONS   #
	#-------------------------------------------------------------#

	def FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindSubStringBetweenAsSectionsCS("word", "<<", ">>", :CaseSensitive = FALSE)
		
		(we used here the simple form of the function)

		#--> [ [11, 14], [28, 31], [41, 44] ]
		*/

		# Getting all the occurrences of pcSubStr in the string

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		#--> [ [ 11, 14 ], [ 32, 35 ], [ 43, 47 ] ]
		nLenSections = len(aSections)

		# Checking the ones that are bounded by pcSubStr1 (<<) and pcSubStr2 (>>)

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		anResult = []
		
		for i = 1 to nLenSections

			aPair = aSections[i]

			cStr = This.Section(aPair[1] - nLen1, aPair[2] + nLen2 )

			if StzStringQ(cStr).IsBoundedByCS([pcBound1, pcBound2], pCaseSensitive)
				anResult + aPair
			ok
		next

		return anResult

		#< @FunctionFluentForm

		def FindBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, :stzList)

			def FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off
		#>

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

			def FindSubStringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
				return This.FindBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

			def FindSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)
				return This.FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

		def FindBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenAsSectionsCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, :stzList)

			def FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)
				return This.FindSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)

			def FindSubStringBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
				return This.FindBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)

			def FindSubStringBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)
				return This.FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)

		def FindBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		#>

	  #========================================================================#
	 #  FINDING SUBSTRINGS IN-BETWEEN (INSIDE THE SUBSTRINGS BOUNDED BY) TWO  #
	#  GIVEN SUBSTRINGS (PSOTITIONS ARE RETURNED AS SECTIONS)                #
	#=======================================================================#

	def FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<--hi!-->>...<<-->>...<<hi!>>...")
		? o1.FindInBetweenAsSections( "hi!", "<<", ">>" )
		#--> [ [8, 10], [29, 30] ]

		# TODO
		? @@( o1.FindXT( "*", :InBetween = [ "<<", ">>" ]) ) # or :InSubStringsBetween
		
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		acBetweenZZ = This.BetweenZZCS(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(acBetweenZZ)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			oBetween = Q(acBetweenZZ[i][1])
			
			if oBetween.ContainsCS(pcSubStr, pCaseSensitive)
				anPos = oBetween.FindAllCS(pcSubStr, pCaseSensitive)
				nLenPos = len(anPos)

				for j = 1 to nLenPos
					n1 = anPos[j] + acBetweenZZ[i][2][1] - 1
					n2 = n1 + nLenSubStr - 1
					aResult + [ n1, n2 ]
				next

			ok
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindInBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------------------------#
	 #  FINDING SUBSTRINGS IN-BETWEEN (INSIDE THE SUBSTRINGS BOUNDED BY) TWO GIVEN SUBSTRINGS  #
	#=========================================================================================#

	def FindInBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aResult = []
		aSections = This.FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if len(aSections) > 0
			aResult = QR(aSections, :stzListOfPairs).FirstItems()
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindInBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindInBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #====================================================================#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#====================================================================#

	def NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		anResult = len( This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)
		/* EXAMPLE
		
		o1 = new stzString("How many <<many>> are there in (many <<many>>): so <<many>>!")
		? o1.NumberOfOccurrenceXT(
			:OfSubString = "many",
			:BetweenSubStrings = ["<<", :and = ">>"]
			# or :BoundedBy = ["<<", :and = ">>"]
		)
		#--> 

		*/

		if isList(pcSubStr) and ( Q(pcSubStr).IsOfNamedParam() or Q(pcSubStr).IsOfSubStringNamedParam() )
			pcSubStr = pcSubStr[2]
		ok

		if isList(pacBetween) and
			( Q(pacBetween).IsBetweenNamedParam() or
			Q(pacBetween).IsBetweenSubstringsNamedParam() or
			Q(pacBetween).IsBoundedByNamedParam() or
			Q(pacBetween).IsBoundedBySubStringsNamedParam() )

			pacBetween = pacBetween[2]
		ok

		if isList(pacBetween) and
			isList(pacBetween[2]) and
			Q(pacBetween[2]).IsAndNamedParam()

				pacBetween[2] = pacBetween[2][2]
		ok

		if NOT ( Q(pacBetween).IsPairOfStrings() or
			
			( isString(pacBetween[1]) and
			   	isList(pacBetween[2]) and
			  	 Q(pacBetween[2]).IsAndNamedParam() and
			   	 isString(pacBetween[2][2])
			)
		      )

			stzRaise("Incorrect param! pacBetween must be a pair of strings.")
		ok

		nResult = This.NumberOfOccurrenceBetweenCS(pcSubStr, pacBetween[1], pacBetween[2], pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)
			return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------------#

	def NumberOfOccurrenceW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pccondition)

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.NumberOfSubStringsW(pcCondition)
		else
			return This.NumberOfCharsW(pcCondition)
		ok

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def ContainsExactlyNOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrences(n, pcSubStr)
		return This.ContainsNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def ContainsExactlyNOccurrences(n, pcSubStr)
			return This.ContainsNOccurrences(n, pcSubStr)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsMoreThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) > n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThenNOccurrences(n, pcSubStr)
		return This.ContainsMoreThenNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS LESS THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsLessThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) < n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsLessThenNOccurrences(n, pcSubStr)
		return This.ContainsLessThenNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #======================================================#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#======================================================#

	def FindAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		aResult = StzListOfPairsQ(aSections).FirstItems()

		return aResult

		#< @FunctionAlterativeForms
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetween(pcBound1, pcBound2)
		return This.FindAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlterativeForms
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedBy(pacBounds)
			return This.FindAnyBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#====================================================================#

	def FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		anResult = StzListOfPairsQ(aSections).FirstItems()
		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByS(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByS(pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#====================================================================#

	def FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartOrStopOrSection, pCaseSensitive)

		# Checking the pnStartOrStopOrSection param

		nLenStr = This.NumberOfChars()
		startAt = 1
		stopAt = nLenStr

		if isNumber(pnStartOrStopOrSection)
				startAt = pnStartOrStopOrSection

		but isList(pnStartOrStopOrSection)
			oTemp = Q(pnStartOrStopOrSection)

			if oTemp.IsOneOfTheseNamedParams([ :StartingAt, :StartAt, :Start ])
				startAt = pnStartOrStopOrSection[2]

			but oTemp.IsOneOfTheseNamedParams([ :StoppingAt, :StopAt, :Stop ])
				stopAt = pnStartOrStopOrSection[2]

			but oTemp.IsOneOfTheseNamedParams([ :Section, :InSection ])
				startAt = pnStartOrStopOrSection[2][1]
				stopAt  = pnStartOrStopOrSection[2][2]

			ok
		ok

		# Cheching the startAt value (the only one we use in this function)
		#--> we leave the checking of stopAt to the called .Section() function

		if isString(startAt)
			oTemp = Q(startAt)

			if oTemp.IsOneOfThese([ :First, :FirstChar ])
				startAt = 1

			but oTemp.IsOneOfThese([ :Last, :LastChar ])
				startAt = nLenStr
			ok
		ok

		# Doing the job

		aSections = This.SectionQ(startAt, stopAt).
				FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(aSections)

		aResult = []
		for i = 1 to nLen
			aResult + [ aSections[i][1] + startAt - 1, aSections[i][2] + startAt - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#=========================================================#

	def BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)		
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForm

		def AnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def AnySubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenS(pcBound1, pcBound2, pnStartingAt)
		return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def SubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def AnySubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def SubStringBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#======================================================================#

	def FindAnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<***>>...<<***>>...")

		? o1.FindAnyBetween("<<", ">>")
		#--> [ 6, 16 ]

		? o1.FindAnyBetweenSIB("<<", ">>", :StartingAt = 10)
		#--> [ 16 ]

		*/

		nStoppingAt = 0

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
			nStoppingAt  = This.NumberOfChars()
		
		but isList(pnStartingAt) and Q(pnStartingAt).IsPairOfNumbers()
			pnStartingAt = pnStartingAt[1]
			nStoppingAt  = pnStartingAt[2]

		but isList(pnStartingAt) and Q(pnStartingAt).IsInSectionNamedParam()

			if isList(pnStartingAt[2]) and Q(pnStartingAt[2]).IsPairOfNumbers()
				nStoppingAt  = pnStartingAt[2][2]
				pnStartingAt = pnStartingAt[2][1]

			else
				StzRaise("Incorrect param! Correct form is :InSection = [n1, n2].")
			ok

		but isList(pnStartingAt) and Q(pnStartingAt).IsStoppingAtNamedParam()
			nStoppingAt  = pnStartingAt
			pnStartingAt = 1
		ok

		anPos = This.SectionQ(pnStartingAt, nStoppingAt).
			FindAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(anPos)
		for i = 1 to nLen
			anPos[i] += pnStartingAt - 1
		next

		return anPos

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedBySIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSIBCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSIBCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySIBCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedBySIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySIBCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySIBCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySIB(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySIB(pacBounds, pnStartingAt)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#======================================================================#

	def FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		nStoppingAt = 0

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
			nStoppingAt  = This.NumberOfChars()
		
		but isList(pnStartingAt) and Q(pnStartingAt).IsPairOfNumbers()
			pnStartingAt = pnStartingAt[1]
			nStoppingAt  = pnStartingAt[2]

		but isList(pnStartingAt) and Q(pnStartingAt).IsInSectionNamedParam()

			if isList(pnStartingAt[2]) and Q(pnStartingAt[2]).IsPairOfNumbers()
				nStoppingAt  = pnStartingAt[2][2]
				pnStartingAt = pnStartingAt[2][1]

			else
				StzRaise("Incorrect param! Correct form is :InSection = [n1, n2].")
			ok

		but isList(pnStartingAt) and Q(pnStartingAt).IsStoppingAtNamedParam()
			nStoppingAt  = pnStartingAt
			pnStartingAt = 1
		ok

		aSections = This.SectionQ(pnStartingAt, nStoppingAt).
				FindAnyBetweenAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(aSections)
		for i = 1 to nLen
			aSections[i][1] += pnStartingAt - 1
			aSections[i][2] += pnStartingAt - 1
		next

		return aSections

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSIBCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSIBCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSIBCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#===========================================================#

	def BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringsBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def AnySubStringsBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringBetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSIB(pcBound1, pcBound2, pnStartingAt)
		return This.BetweenSIBCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def SubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def AnySubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def SubStringBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		#>

  	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#=====================================================================#

	def FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<***>>...<<***>>...")

		? o1.FindAnyBetween("<<", ">>")
		#--> [ 6, 16 ]

		? o1.FindAnyBetweenSD("<<", ">>", :StartingAt = 10)
		#--> [ 16 ]

		*/

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		anResult  = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSDCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#=====================================================================#

	def FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartOrStopOrSection, pcDirection, pCaseSensitive)
		
		# Resolving the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )
			StzRaise("Incorrect param! pcDirection must be a string equal to :Default, :Forward or :Backward.")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		aResult = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartOrStopOrSection, pCaseSensitive)
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult


		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSDCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#==========================================================#

	def BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def SubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def AnySubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def SubStringBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
		return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def SubStringsBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def AnySubStringsBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def SubStringBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#=======================================================================#

	def FindAnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		anResult  = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSDIBCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDIBCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDIBCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#=======================================================================#

	def FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections    = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSections = len(aSections)

		if isList(pcBound1) and Q(pcBound1).IsSubStringNamedParam()
			pcBound1 = pcBound1[2]
		ok

		if isList(pcBound2) and Q(pcBound2).IsOneOfTheseNamedParams([ :And, :AndSubString ])
			pcBound2 = pcBound2[2]
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			aSections[i][1] -= nLenBound1
			aSections[i][2] += nLenBound2
		next

		return aSections

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSDIBCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDIBCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDIBCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)

		#>

	  #------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#============================================================#

	def BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def SubStringsBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def AnySubStringsBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def SubStringBetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.BetweenSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def SubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def AnySubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def SubStringBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS           #
	#======================================================#

	def FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		# Checking the pcBound1 and pcBound2 params

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRaise("Incorrect param type! pcBound1 and pcBound2 must both be strings.")
		ok

		# Doing the job

		if This.ContainsNoCS(pcBound1, pCaseSensitive) or
		   This.ContainsNoCS(pcBound2, pCaseSensitive)

			return []
		ok

		aResult = []

		if pcBound1 = pcBound2

			if This.NumberOfOccurrenceCS(pcBound1, pCaseSensitive) = 1
				return []
			ok

			aSections = This.FindAsSectionsCS(pcBound1, pCaseSensitive)

			if This.IsBoundedByCS(pcBound1, pCaseSensitive)

				aResult = This.FindAntiSectionsQ(aSections).Content()

			else

				aResult = This.FindAntiSectionsQ(aSections).
					      FirstAndLastItemsRemoved()
			ok

		else // pcBound1 != pcBound2

			anPos1 = StzListOfNumbersQ( This.FindCS(pcBound1, pCaseSensitive) ).
				 AddedToEach( Q(pcBound1).NumberOfChars() )
	
			anPos2 = StzListOfNumbersQ( This.FindCS(pcBound2, pCaseSensitive) ).
				 AddedToEach( -1 )
	
			nLen1 = len(anPos1)
			nLen2 = len(anPos2)
	
			if nLen1 > 0 and nLen2 > 0
				n = 1
				for j = 1 to nLen2
					if anPos2[j] < anPos1[1]
						n++
					ok
				next
	
				anPos2 = Q(anPos2).Section(n, nLen2)
				aResult = StzListOfListsQ([anPos1, anPos2]).ShrinkQ().Associated()
	
			ok
	
		ok

		return aResult

		#< @FunctionAlternativeForms
		# NOTE: Reorganise! some alternatives are in bottom of file

		def FindAnySubStringBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)


		def FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSections(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms
		# NOTE: Reorganise! some alternatives are in bottom of file

		def FindAnySubStringBetweenAsSections(pcBound1, pcBound2)
			return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

		def FindAnySubStringsBetweenAsSections(pcBound1, pcBound2)
			return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

		def FindAnyBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, :CaseSensitive = TRUE)

		def FindAnySubStringBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSections(pacBounds)

		def FindAnySubStringsBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSections(pacBounds)

		#>

	   #--------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS    #
	 #  AND RETURNING THEIR POSITIONS -- D/EXTENDED           #
	#========================================================#
	
	def FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anResult = QR( This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive), :stzListOfPairs).FirstItems()
		return anResult
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenDCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenDCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenD(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByD(pacBounds, pcDirection)
			return This.FindAnyBoundedByDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	   #-----------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS       #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- D/EXTENDED  #
	#===========================================================#

	def FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		# Checking pcDirection param

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])

			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )
			SzRaise("Incorrect param type! pcDirection must be a string equal to :Forward, :Backward, or :Default.")
			# NOTE this is a misspelled form of StzRaise()
		ok

		# Doing the job

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if pcDirection = :Backward
			aSections = Q(aSections).Reversed()
		ok

		return aSections

		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsDCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsDCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenAsSectionsD(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsD(pacBounds, pcDirection)
			return This.FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- D/EXTENDED  #
	#=========================================================#
	
	def AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)
		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			aSections = This.FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, pCaseSensitive)
			acResult  = This.Sections(aSections)
			return acResult
	
		def BoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenD(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		def SubStringsBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByDC(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		def AnySubStringBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		#>
	
	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DZ/EXTENDED  #
	#==========================================================#
	
	def AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acBetween   = This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anPositions = This.FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acResult = Association([ acBetween, anPositions ])

		return acResult
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenDCSZ(pcBounAnyBetweenDZCSd1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		def BetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def BetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def SubStringsBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def AnySubStringsBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def AnySubStringBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.AnyBetweenDZCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.AnyBetweenDZCS(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

			def AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)

		def BoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
			def BoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
			def SubStringsBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
			def AnySubStringsBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
			def AnySubStringBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDZCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		#>

	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DZZ/EXTENDED  #
	#===========================================================#
	
	def AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acBetween = This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acResult = Association([ acBetween, aSections ])

		return acResult
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		def BetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def BetweenDCZZS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def SubStringsBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
			def AnySubStringsBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def AnySubStringBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.AnyBetweenDZZCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.AnyBetweenDZZCS(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)

		def BoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)

			def BoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)

			def SubStringsBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
	
			def AnySubStringsBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)

			def AnySubStringBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDZZCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		#>

	   #--------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS    #
	 #  AND RETURNING THEIR POSITIONS -- DIB/EXTENDED         #
	#========================================================#
	
	def FindAnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anResult = QR( This.FindAnyBetweenAsSectionsDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive), :stzListOfPairs).FirstItems()
		return anResult
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenDIBCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenDIBCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenDIB(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDIB(pacBounds, pcDirection)
			return This.FindAnyBoundedByDIBCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	   #-------------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS         #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- DIB/EXTENDED  #
	#=============================================================#

	def FindAnyBetweenAsSectionsDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		if NOT isString(pcBound1)
			StzRaise("Incorrect param type! pcBound1 must be a string.")
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT isString(pcBound2)
			StzRaise("Incorrect param type! pcBound2 must be a string.")
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		nLenSections = len(aSections)

		for i = 1 to nLenSections
			aSections[i][1] -= nLenBound1
			aSections[i][2] += nLenBound2
		next

		return aSections
	
		#< @FunctionAlternativeForm

		def FindAnyBoundedByAsSectionsDIBCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsDIBCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsDIBCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenAsSectionsDIB(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenAsSectionsDIBCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsDIB(pacBounds, pcDirection)
			return This.FindAnyBoundedByAsSectionsDIBCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIB/EXTENDED  #
	#===========================================================#
	
	def AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)
		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDIBCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDIBCS(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
	
		def BoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIBCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDC(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
	  #------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIBZ/EXTENDED  #
	#============================================================#
	
	def AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		acBetween  = This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aPositions = This.FindAnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aResult    = Association([ acBetween, aPositions ])

		return aResult
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenDIBCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		def BetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def BetweenDIBCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def SubStringsBetweenDIBCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def AnySubStringsBetweenDIBCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def AnySubStringBetweenDIBCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDIBZCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDIBZCS(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

			def AnyBoundedByDIBCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)

		def BoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)

			def BoundedByDIBCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)

			def SubStringsBoundedByDIBCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)

			def AnySubStringsBoundedByDIBCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)

			def AnySubStringBoundedByDIBCSZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDIBZCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)

	  #-------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIBZZ/EXTENDED  #
	#=============================================================#
	
	def AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		acBetween = This.AnyBetweenDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDIBCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aResult   = Association([ acBetween, aSections ])

		return aResult
	
		#< @FunctionAlternativeForms

		def AnyBetweenDIBCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		def BetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def BetweenDIBCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def SubStringsBetweenDIBCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def AnySubStringsBetweenDIBCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

			def AnySubStringBetweenDIBCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
				return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDIBZZCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDIBZZCS(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

			def AnyBoundedByDIBCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def BoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)

			def BoundedByDIBCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.BoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)

		def SubStringsBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)

			def SubStringsBoundedByDIBCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)

			def AnySubStringsBoundedByDIBCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)

			def AnySubStringBoundedByDIBCSZZ(pacBounds, pcDirection, pCaseSensitive)
				return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDIBZZCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)

	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#=====================================================================#
	#--> Bounds are also considered in the result

	def FindAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		anPositions = This.FindAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		nNumberOfPositions = len(anPositions)
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()

		for i = 1 to nNumberOfPositions
			anPositions[i] -= nLenBound1
		next

		return anPositions

		#< @FunctionAlternativeForm

		def FindAnyBoundedByIBCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenIBCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenIBCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenIB(pcBound1, pcBound2)
		return This.FindAnyBetweenIBCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindAnyBoundedByIB(pacBounds)
			return This.FindAnyBoundedByIBCS(pacBounds, :CaseSensitive = TRUE)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING (AS SECTIONS) BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#===================================================================================#
	#--> Bounds are also considered in the result

	def FindAnyBetweenAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		return aSections

		#< @FunctionAlternatives
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByAsSectionsIBCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsIBCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsIBCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsIBCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternatives
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByAsSectionsIB(pacBounds)
			return This.FindAnyBoundedByAsSectionsIBCS(pacBounds, :CaseSensitive = TRUE)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#===================================================================================#

	def FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthBetweenAsSection(2, "word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 28, 31 ]
		*/

		# Getting all the occurrences of pcSubStr in the string

		if n = :First or n = :FirstSection
			n = 1

		but n = :Last or n = :LastSection
			n = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		ok

		anResult = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)[n]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pcBound[1], pcBound[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindNthSubStringBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)
			return This.FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)

		def FindNthBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindNthSubStringBoundedByAsSection(n, pcsubStr, pacBounds)
			return This.FindNthBoundedByAsSection(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------#
	 #   FINDING FIRST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#=======================================================================================#

	def FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindFirstBetweenAsSection("word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 10, 13 ]
		*/

		nResult = This.FindNthBetweenAsSectionCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(1, pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSection(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenAsSection(pcSubStr, pcBound1, pcbound2)
			return This.FindFirstBetweenAsSection(pcSubStr, pcBound1, pcbound2)

		def FindFirstBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSection(1, pcSubStr, pacBounds)

		def FindFirstSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSection(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 #   FINDING LAST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#======================================================================================#

	def FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindLastBetweenAsSections("word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 27, 32 ]
		*/

		nResult = This.FindNthBetweenAsSectionCS(:Last, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(:Last, pcSubStr, pacBounds, pCaseSensitive)

		def FindLastSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSection(pcSubStr, pcBound1, pcbound2)
		return This.FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenAsSection(pcSubStr, pcBound1, pcbound2)
			return This.FindLasttBetweenAsSection(pcSubStr, pcBound1, pcbound2)

		def FindLastBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSection(:Last, pcSubStr, pacBounds)

		def FindLastSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSection(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#==================================================================================================#
	# Bounds are considered in the result. Otherwise use FindNthAsSections() instead (without ..IB())

	def FindNthBetweenAsSectionIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthBetweenAsSectionIB(2, "word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 26, 33 ]
		*/

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRaise("Incorrect param types! pcBound1 and pcBound2 must both be strings.")
		ok

		aSections = This.FindNthBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		nLen = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLen
			aSections[i][1] -= nLen1
			aSections[i][2] += nLen2
		next

		return aSections

		#< @FunctionAlternativeForms

		def FindNthSubStringBetweenAsSectionIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindNthBoundedByAsSectionIBCS(n, pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindNthSubStringBoundedByAsSectionIBCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionIBCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionIBCS(n, pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSubStringBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)
			return This.FindNthBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)

		def FindNthBoundedByAsSectionIB(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionIBCS(n, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindNthSubStringBoundedByAsSectionIB(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionIB(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------------------#
	 # FINDING FIRST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#===================================================================================================#

	def FindFirstBetweenAsSectionIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindFirstBetweenAsSectionIB("word", "<<", ">>")

		#--> [ 9, 16 ]
		*/

		nResult = This.FindNthBetweenAsSectionIBCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSubStringBetweenAsSectionIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindFirstBetweenAsSectionIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindFirstBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionIBCS(1, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFirstSubStringBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)
			return This.FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)

		def FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSectionIBCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFirstSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#====================================================================================#

	def FindLastBetweenAsSectionsIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindLastBetweenAsSectionsIB("word", "<<", ">>")

		#--> [ 41, 48 ]
		*/

		nResult = This.FindNthBetweenAsSectionsIBCS(:Last, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBetweenAsSectionIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindLastBetweenAsSectionIBCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindLastBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionIBCS(:Last, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFLastSubStringBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastBoundedByAsSectionIBCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSectionsIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastBetweenAsSectionsIB(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)
			return This.FindLastBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)

		def FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSectionIBCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindLastSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)

		#>

	  #=========================================================================#
	 #  POSITIONS OF SUBSTRINGS AFTER BEEING SPLITTED USING A GIVEN SUBSTRING  #
	#=========================================================================#

	def AnySplittedByCS(pcSplitter, pCaseSensitive)
		return This.SplitCS(pcSplitter, pCaseSensitive)

	#--

	def AnySplittedBy(pcSplitter)
		return This.AnySplittedByCS(pcSplitter, :CaseSensitive = TRUE)


	def FindAnySplittedByCS(pcSplitter, pCaseSensitive)

		/* EXAMPLE :

		o1 = new stzString("12*45*78*9")
		? @@( o1.FindAnySplittedBy("*") )
		#--> [ 1, 4, 7, 9 ]

		*/

		if isList(pcSplitter) and Q(pcSplitter).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSplitter)
			stzRaise("Incorrect params types! pcSubStr must be a string.")
		ok

		if NOT This.ContainsCS(pcSplitter, pCaseSensitive)
			return []
		ok

		acSplitted = This.Split( :Using = pcSplitter )
		nLen = len(acSplitted)

		nLenSplitter = Q(pcSplitter).NumberOfChars()
		anResult = []

		nPos = 0
		for i = 2 to nLen
			nPos += len(acSplitted[i-1]) + nLenSplitter - 1
			anResult + nPos
		next

		return anResult

		#< @FunctionFluentForm

		def FindAnySplittedByCSQ(pcSplitter, pCaseSensitive)
			return This.FindAnySplittedByCSQR(pcSplitter, pCaseSensitive, :stzList)

			def FindAnySplittedByCSQR(pcSplitter, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindAnySplittedByCS(pcSplitter, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindAnySplittedByCS(pcSplitter, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySplittedBy(pcSplitter)
		return This.FindAnySplittedByCS(pcSplitter, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def FindAnySplittedByQ(pcSplitter)
			return This.FindAnySplittedByQRCS(pcSplitter, :stzList, pCaseSensitive)

		def FindAnySplittedByQR(pcSplitter, pcReturnType)
			return This.FindAnySplittedByQR(pcSplitter, pcReturnType)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  POSITIONS (AS SECTIONS) OF SUBSTRINGS AFTER BEEING SPLITTED USING A GIVEN SUBSTRING  #
	#---------------------------------------------------------------------------------------#

	def FindAnydSplittedByAsSectionsCS(pcSplitter, pCaseSensitive)
		# TODO: Uses generated code. Chek it for performance,
		# and rempliment it if necessary

		/* EXAMPLE

		o1 = new stzString("**3**67**012**56**92**")
		? o1.FindAnySplittedBy("**")
		#--> [ 3, 6, 10, 15, 19 ]

		? o1.FindAnySplittedByAsSections("*")
		#--> [ [3,3], [6, 7], [10, 12], [15,16], [19,20] ]

		*/

		if isList(pcSplitter) and Q(pcSplitter).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSplitter)
			stzRaise("Incorrect params types! pcSubStr must be a string.")
		ok

		oCopy = This.Copy()
		nLen = Q(pcSubStr).NumberOfChars()

		anResult =  oCopy.FindAllCSQ(pcSplitter, pCaseSensitive).
				Yield(' [ ' + nLen + ' + @item, 0+@nextitem -  ' + nLen + '+ 1 ] ')

		return anResult

		#< @FunctionFluentForm

		def FindAnySplittedByAsSectionsCSQ(pcSplitter, pCaseSensitive)
			return This.FindAnySplittedByAsSectionsCSQR(pcSplitter, pCaseSensitive, :stzList)

			def FindAnySplittedByAsSectionsCSQR(pcSplitter, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindAnySplittedByAsSectionsCS(pcSplitter, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindAnySplittedByAsSectionsCS(pcSplitter, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySplittedByAsSections(pcSplitter)
		return This.FindAnySplittedByAsSectionsCS(pcSplitter, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindAnySplittedByAsSectionsQ(pcSplitter)
			return This.FindAnySplittedByAsSectionsQR(pcSplitter, :stzList)

			def FindAnySplittedByAsSectionsQR(pcSplitter, pcReturnType)
				return This.FindAnySplittedByAsSectionsCSQR(pcSplitter, :CaseSensitive = TRUE, pcReturnType)
	
		#>

	  #-------------------------------------------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF A GIVEN SUBSTRING RESULTING FROM THE SPLITTING OF THE STRING USING A GIVEN SUBSTRING  #
	#-------------------------------------------------------------------------------------------------------------#
	# TODO

	def FindSplittedByCS(pcSubStr, pcSplitter, pCaseSensitive)
		StzRaise("Unavailable function in current release!")

		#< @FunctionAlternativeForm

		def FindSubStringSplittedByCS(pcSubStr, pcSplitter, pCaseSensitive)
			return This.FindSplittedByCS(pcSubStr, pcSplitter, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplittedBy(pcSubStr, pcSplitter)
		StzRaise("Unavailable function in current release!")

		#< @FunctionAlternativeForm

		def FindSubStringSplittedBy(pcSubStr, pcSplitter)
			return This.FindSplittedBy(pcSubStr, pcSplitter)

		#>

	  #==============================================================#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION  #
	#==============================================================#
	# Distance is given by the number of chars inbetween
	# the starting and target positions are not included
	# To include them, use ...XT() form of the function

	def DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)
		nResult = This.DistanceToXTCS(pcSubStr, pnStartingAt, pCaseSensitive) - 2
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def DistanceTo(pcSubStr, pnStartingAt)
		return This.DistanceToCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION -- EXTENDED  #
	#--------------------------------------------------------------------------#

	def DistanceToXTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		n1 = pnStartingAt
		n2 = 0

		if isString(pcSubStr)
			n2 = This.FindNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
		
		but isNumber(pcSubStr)
			n1 = pcSubStr

		but isList(pcSubStr)
			if Q(pcSubStr).IsNextNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = This.FindNextCS(pcSubStr, pnStartingAt + 1, pCaseSensitive)

			but Q(pcSubStr).IsNthNextNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :NextNth, :NthNext ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = This.FindNextNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)
			
				ok

			but Q(pcSubStr).IsPreviousNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = n1
				n1 = This.FindPreviousCS(pcSubStr, pnStartingAt - 1, pCaseSensitive)

			but Q(pcSubStr).IsNthPreviousNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :PreviousNth, :NthPrevious ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = n1
					n1 = This.FindPreviousNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)

				ok

			ok

		ok

		nResult = n2 - n1 + 1

		return nResult


		def DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.DistanceToXTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DistanceToXT(pcSubStr, pnStartingAt)
		return This.DistanceToXTCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #==============================================================#
	 #   SUBSTRING(S) ENCLOSED BETWEEN TWO SUBSTRINGS OR POSITIONS  # 
	#==============================================================#

	def BetweenCS(p1, p2, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(p1, p2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def BetweenCSQ(p1, p2, pCaseSensitive)
			return Q( This.BetweenCS(p1, p2, pCaseSensitive) )

		def BetweenCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassNames() )
				StzRaise("Incorrect param! pcReturnType must be a string containing a Softanza class name.")
			ok

			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				if pcReturnType = :stzString
					return new stzString(Between)
				else
					StzRaise("Can't return a stzString! Because the data is a list.")
				ok

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)

				on :stzListOfStrings
					return new stzListOfStrings(Between)

				other
					StzRaise("Unsupported return type!")
				off

			ok

		#>

		# See alternatives in bottom of file including BoundedBy()

	#-- WITHOUT CASESENSITIVITY

	def Between(p1, p2)
		return This.BetweenCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def BetweenQ(p1, p2)
			return Q( This.Between(p1, p2) )

		def BetweenQR(p1, p2, pcReturnType)
			return This.BetweenCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- Z/EXTENDED  #
	#==================================================================#

	def BetweenZCS(p1, p2, pCaseSensitive)

		between = This.BetweenCS(p1, p2, pCaseSensitive)

		if isString(between) # In case p1 and p2 are numbers forming a section
			return [ between, This.FindCS(between, pCaseSensitive) ]
		
		else
			return This.SubStringsBetweenZCS(p1, p2, pCaseSensitive) 
		ok
		
		#< @FunctionAlternativeForm

		def BetweenCSZ(p1, p2, pCaseSensitive)
			return This.BetweenZCS(p1, p2, pCaseSensitive)

		def AnyBetweenZCS(p1, p2, pCaseSensitive)
			return This.BetweenZCS(p1, p2, pCaseSensitive)

			def AnyBetweenCSZ(p1, p2, pCaseSensitive)
				return This.BetweenZCS(p1, p2, pCaseSensitive)
	
		def BoundedByZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenZCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsListOfStrings()
				return This.BetweenZCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

			def BoundedByCSZ(pacBounds, pCaseSensitive)
				return This.BoundedByZCS(pacBounds, pCaseSensitive)

		def AnyBoundedByZCS(pacBounds, pCaseSensitive)
			return This.BoundedByZCS(pacBounds, pCaseSensitive)

			def AnyBoundedByCSZ(pacBounds, pCaseSensitive)
				return This.AnyBoundedByZCS(pacBounds, pCaseSensitive)

		
		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenZ(p1, p2)
		return This.BetweenZCS(p1, p2, :CaseSensitive = TRUE)
 
		#< @FunctionAlternativeForm

		def AnyBetweenZ(p1, p2)
			return This.BetweenZ(p1, p2)

		def BoundedByZ(pacBounds)
			return This.BoundedByZCS(pacBounds, :CaseSensitive = TRUE)

		def AnyBoundedByZ(pacBounds)
			return This.BoundedByZ(pacBounds)

		#>

	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- ZZ/EXTENDED  #
	#==========================================================#

	def SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acSubStr  = This.Sections(aSections)

		aResult = Association([ acSubStr, aSections ])

		return aResult

		#< @FunctionFluentForm

		def SubStringsBetweenZZCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenZZCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubStringsBetweenZZCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				StzRaise( "Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		# TODO: Add ...AndTheirSections() alternatives to all ...ZZ() functions
		# TODO: Add ...AndTheirPositions() alternatives to all ...Z() functions

		def SubStringsBetweenAndTheirSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def subStringsBetweenZZQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenZZCSQ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def SubStringsBetweenZZQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenZZCSQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- Z/EXTENDED  #
	#=========================================================#

	def SubStringsBetweenZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		aBetweenZZ = This.SubStringsBetweenZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(aBetweenZZ)

		aResult = []
		for i = 1 to nLen
			aResult + [ aBetweenZZ[i][1], aBetweenZZ[i][2][1] ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SubStringsBetweenCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def AnySubStringsBetweenZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		
			def AnySubStringsBetweenCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.AnySubStringsBetweenZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenZ( pcSubStr1, pcSubStr2 )
		return This.SubStringsBetweenZCS( pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsBetweenAndTheirPositions( pcSubStr1, pcSubStr2 )
			return This.SubStringsBetweenZ( pcSubStr1, pcSubStr2 )

		def AnySubStringsBetweenZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenZ(pcSubStr1, pcSubStr2)
		
		def AnySubStringsBetweenAndTheirPositions(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenZ(pcSubStr1, pcSubStr2)

		#>

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZZ/EXTENDED  #
	#====================================================================#

	def BetweenZZCS(p1, p2, pCaseSensitive)

		between = This.BetweenCS(p1, p2, pCaseSensitive)

		if isString(between) # Case where p1 and p2 are numbers
			return [ between, This.FindAsSectionsCS(between, pCaseSensitive) ]

		else
			return This.SubStringsBetweenZZCS(p1, p2, pCaseSensitive)
		ok
		
		#< @FunctionAlternativeForm

		def BetweenCSZZ(p1, p2, pCaseSensitive)
			return This.BetweenZZCS(p1, p2, pCaseSensitive)

		def AnyBetweenZZCS(p1, p2, pCaseSensitive)
			return This.BetweenZZCS(p1, p2, pCaseSensitive)

			def AnyBetweenCSZZ(p1, p2, pCaseSensitive)
				return This.AnyBetweenZZCS(p1, p2, pCaseSensitive)
		
		def BoundedByZZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenZZCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsListOfStrings()
				return This.BetweenZZCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

			def BoundedByCSZZ(pacBounds, pCaseSensitive)
				return This.BoundedByZZCS(pacBounds, pCaseSensitive)

		def AnyBoundedByZZCS(pacBounds, pCaseSensitive)
			return This.BoundedByZZCS(pacBounds, pCaseSensitive)

			def AnyBoundedByCSZZ(pacBounds, pCaseSensitive)
				return This.AnyBoundedByZZCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenZZ(p1, p2)
		return This.BetweenZZCS(p1, p2, :CaseSensitive = TRUE)
 
		#< @FunctionAlternativeForm

		def AnyBetweenZZ(p1, p2)
			return This.BetweenZZ(p1, p2)
		
		def BoundedByZZ(pacBounds)
			return This.BoundedByZZCS(pacBounds, :CaseSensitive = TRUE)

		def AnyBoundedByZZ(pacBounds)
			return This.BoundedByZZ(pacBounds)

		#>

	  #------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS #
	#==========================================#

	def SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive )
		aBetweenZZ = This.SubStringsBetweenZZCS( pcSubStr1, pcSubStr2, pCaseSensitive )
		nLen = len(aBetweenZZ)

		aResult = []

		for i = 1 to nLen
			aResult + aBetweenZZ[i][1]
		next

		return aResult

		#< @FunctionFluentForm

		def SubStringsBetweenCSQ( pcSubStr1, pcSubStr2, pCaseSensitive )
			return This.SubStringsBetweenCSQR( pcSubStr1, pcSubStr2, pCaseSensitive, :stzList )

		def SubStringsBetweenCSQR( pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType )
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive ) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive ) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		// See them in bottom of file

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetween( pcSubStr1, pcSubStr2 )
		return This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		// See them in bottom of file

		#>

	  #------------------------------------------------------------------------------#
	 #  SUBSTRING(S) ENCLOSED BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/EXTENDED  # 
	#==============================================================================#

	def BetweenIBCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			return this.SubStringsBetweenIBCS(p1, p2, pCaseSensitive)

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenIBCSQ(p1, p2, pCaseSensitive)
			Between = This.BetweenIBCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenIBCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenIBCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIB(p1, p2)
		return This.BetweenIBCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenIBQ(p1, p2)
			return This.BetweenIBCSQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenIBQR(p1, p2, pcReturnType)
			return This.BetweenIBCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

	  #-----------------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/Z() EXTENDED  #
	#=======================================================================#

	def BetweenIBZCS(p1, p2, pCaseSensitive)
	
		acBetweenIBU = This.BetweenIBCS(p1, p2, pCaseSensitive)
		anPositions  = This.FindAnyBetweenIBCS(p1, p2, pCaseSensitive)

		aResult = Association([ acBetweenIBU,  anPositions ])
		return aResult
	
		#< @FunctionAlternativeForms
	
		def BetweenIBCSZ(p1, p2, pCaseSensitive)
			return This.BetweenIBZCS(p1, p2, pCaseSensitive)

		def AnyBetweenIBZCS(p1, p2, pCaseSensitive)
			return This.BetweenIBZCS(p1, p2, pCaseSensitive)
	
			def AnyBetweenIBCSZ(p1, p2, pCaseSensitive)
				return This.AnyBetweenIBZCS(p1, p2, pCaseSensitive)

		def BoundedByIBZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenIBZCS(pacBounds, pacBounds, pCaseSensitive)
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.BetweenIBUZCS(pacBounds[1], pacBounds[2], pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

			def BoundedByIBCSZ(pacBounds, pCaseSensitive)
				return This.BoundedByIBZCS(pacBounds, pCaseSensitive)
	
		def AnyBoundedByIBZCS(pacBounds, pCaseSensitive)
			return This.BoundedByIBZCS(pacBounds, pCaseSensitive)

			def AnyBoundedByIBCSZ(pacBounds, pCaseSensitive)
				return This.AnyBoundedByIBZCS(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def BetweenIBZ(p1, p2)
		return This.BetweenIBZCS(p1, p2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenIBZ(p1, p2)
			return This.BetweenIBZ(p1, p2)
	
		def BoundedByIBZ(pacBounds)
			return This.BoundedByIBZCS(pacBounds, :CaseSensitive = TRUE)
	
		def AnyBoundedByIBZ(pacBounds)
			return This.BoundedByIBZ(pacBounds)
	
		#>
		
	  #------------------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/ZZ() EXTENDED  #
	#========================================================================#

	def BetweenIBZZCS(p1, p2, pCaseSensitive)
	
		acBetweenIB = This.BetweenIBCS(p1, p2, pCaseSensitive)
		anSections  = This.FindAnyBetweenAsSectionsIBCS(p1, p2, pCaseSensitive)

		aResult = Association([ acBetweenIB, anSections ])
		return aResult
	
		#< @FunctionAlternativeForms
	
		def BetweenIBCSZZ(p1, p2, pCaseSensitive)
			return This.BetweenIBZZCS(p1, p2, pCaseSensitive)

		def AnyBetweenIBZZCS(p1, p2, pCaseSensitive)
			return This.BetweenIBZZCS(p1, p2, pCaseSensitive)

			def AnyBetweenIBCSZZ(p1, p2, pCaseSensitive)
				return This.AnyBetweenIBZZCS(p1, p2, pCaseSensitive)

		def BoundedByIBZZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenIBZZCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.BetweenIBZZCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

			def BoundedByIBCSZZ(pacBounds, pCaseSensitive)
				return This.BoundedByIBZZCS(pacBounds, pCaseSensitive)
	
		def AnyBoundedByIBZZCS(pacBounds, pCaseSensitive)
			return This.BoundedByIBZZCS(pacBounds, pCaseSensitive)
	
			def AnyBoundedByIBCSZZ(pacBounds, pCaseSensitive)
				return This.AnyBoundedByIBZZCS(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def BetweenIBZZ(p1, p2)
		return This.BetweenIBZZCS(p1, p2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenIBZZ(p1, p2)
			return This.BetweenIBZZ(p1, p2)
	
		def BoundedByIBZZ(pacBounds)
			return This.BoundedByIBZZCS(pacBounds, :CaseSensitive = TRUE)
	
		def AnyBoundedByIBZZ(pacBounds)
			return This.BoundedByIBZZ(pacBounds)
	
		#>

	  #----------------------------------------------------------------------#
	 #   SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS  -- IB/EXTENDED   # 
	#======================================================================#
	# Bounds are considered in the results

	def SubstringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("blabla bla <<word1>> bla bla <<word2>>")
		? o1.SubstringsBetweenIB("<<", ">>")

		#--> [ "<<word1>>", "<<word2>>" ]
		*/

		aSections = This.FindAnyBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubstringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubstringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenIBCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenIBQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenIBCSQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #--------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS -- IB/Z() EXTENDED  #
	#========================================================#

	def SubStringsBetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		acBetweenIB = This.SubStringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		anPositions = This.FindBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		aResult = Association([ acBetweenIB, anPositions ])
	
		return aResult
	
		#< @FunctionAlternativeForms
	
		def SubStringsBetweenIBCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnySubStringBetweenIBCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.AnySubStringBetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
			def AnySubStringsBetweenIBCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.BetweenIBZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def SubStringsBoundedByIBZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.SubStringsBetweenIBZCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.SubstringsBetweenIBZCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

			def SubStringsBoundedByIBCSZ(pacBounds, pCaseSensitive)
				return This.SubStringsBoundedByIBZCS(pacBounds, pCaseSensitive)
	
		def AnySybStringBoundedByIBZCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBZCS(pacBounds, pCaseSensitive)

			def AnySybStringBoundedByIBCSZ(pacBounds, pCaseSensitive)
				return This.AnySybStringBoundedByIBZCS(pacBounds, pCaseSensitive)

		def AnySybStringsBoundedByIBZCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBZCS(pacBounds, pCaseSensitive)
	
			def AnySybStringsBoundedByIBCSZ(pacBounds, pCaseSensitive)
				return This.AnySybStringsBoundedByIBZCS(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenIBZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
	
		def AnySubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)

		def SubStringsBoundedByIBZ(pacBounds)
			return This.SubstringsBoundedByIBZCS(pacBounds, :CaseSensitive = TRUE)
	
		def AnySubStringBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnySubStringsBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)
	
		#>
		
	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS -- IB/ZZ() EXTENDED  #
	#=========================================================#

	def SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		acBetweenIB = This.SubStringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		anSections  = This.FindBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		aResult = Association( :Of = acBetweenIB, :And = anPositions )
	
		return aResult
	
		#< @FunctionAlternativeForms

		def SubStringsBetweenIBCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def AnySubStringBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnySubStringBetweenIBCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def AnySubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnySubStringsBetweenIBCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def SubStringsBoundedByIBZZCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.SubstringsBetweenIBZZCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.SubStringsBetweenIBZZCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
			def SubStringsBoundedByIBCSZZ(pacBounds, pCaseSensitive)
				return This.SubStringsBoundedByIBZZCS(pacBounds, pCaseSensitive)

		def AnySubstringBoundedByIBZZCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBZZCS(pacBounds, pCaseSensitive)

			def AnySubstringBoundedByIBCSZZ(pacBounds, pCaseSensitive)
				return This.AnySubstringBoundedByIBZZCS(pacBounds, pCaseSensitive)

		def AnySubstringsBoundedByIBZZCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBZZCS(pacBounds, pCaseSensitive)
	
			def AnySubstringsBoundedByIBCSZZ(pacBounds, pCaseSensitive)
				return This.AnySubstringsBoundedByIBZZCS(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def SubstringsBetweenIBZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBZZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenIBZZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)

		def SubstringsBoundedByIBZZ(pacBounds)
			return This.subStringsBoundedByIBZZCS(pacBounds, :CaseSensitive = TRUE)
	
		def AnySubStringBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)
	
		def AnySubStringsBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#>

	  #----------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRING(S) ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  # 
	#============================================================================#

	def BetweenUCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			acResult = This.BetweenCSQ(p1, p2, pCaseSensitive).DupplicatesRemoved()
			return acResult

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenUCSQ(p1, p2, pCaseSensitive)
			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenUCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

		#< @FunctionAlternativeForm

		def AnyBetweenUCS(p1, p2, pCaseSensitive)
			return This.BetweenUCS(p1, p2, pCaseSensitive)

		def AnyBetweenUCSQ(p1, p2, pCaseSensitive)
			return This.BetweenUCSQ(p1, p2, pCaseSensitive)

		def AnyBetweenUCSQR(p1, p2, pCaseSensitive, pcReturType)
			return This.BetweenUCSQR(p1, p2, pCaseSensitive, pcReturType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenU(p1, p2)
		return This.BetweenUCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenUQ(p1, p2)
			return This.BetweenUCSQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenUQR(p1, p2, pcReturnType)
			return This.BetweenUCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForm

		def AnyBetweenU(p1, p2)
			return This.BetweenU(p1, p2)

		def AnyBetweenUQ(p1, p2)
			return This.BetweenUQ(p1, p2)

		def AnyBetweenUQR(p1, p2)
			return This.BetweenUQR(p1, p2)

		#>

	  #--------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  #
	#==========================================================================#

	def SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive).
				DuplicatesRemoved()

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			acResult = This.SubstringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType).
				DuplicatesRemoved()

			return acResult

		#>

		#< @FunctionAlternativeForm

		def AnySubStringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturType)
			return This.SubStringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQR(pcSubStr1, pcSubStr2, :stzList)

		def SubstringsBetweenUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenICSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>


		#< @FunctionAlternativeForm

		def AnySubStringsBetweenU(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenU(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenUQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenUQR(pcSubStr1, pcSubStr2, pcReturType)
			return This.SubStringsBetweenUCQR(pcSubStr1, pcSubStr2, pcReturType)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRING(S) ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS) -- IB/Extended  # 
	#===========================================================================================#

	def BetweenIBUCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			acResult = This.BetweenIBCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
			return acResult

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenIBUCSQ(p1, p2, pCaseSensitive)
			Between = This.BetweenIBUCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenIBUCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenIBUCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

		#< @FunctionAlternativeForm

		def AnyBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnyBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnyBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.BetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBU(p1, p2)
		return This.BetweenIBUCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenIBUQ(p1, p2)
			return This.BetweenIBUCSQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenIBUQR(p1, p2, pcReturnType)
			return This.BetweenIBUCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForm

		def AnyBetweenIBU(pcSubStr1, pcSubStr2)
			return This.BetweenIBU(pcSubStr1, pcSubStr2)

		def AnyBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.BetweenIBUQ(pcSubStr1, pcSubStr2)

		def AnyBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.BetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)

		#>

	  #-----------------------------------------------------------------------------#
	 #   UNIQUE SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS  -- IB/EXTENDED   # 
	#=============================================================================#

	def SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.SubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive).
				DuplicatesRemoved()

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			acResult = This.SubstringsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType).
				DuplicatesRemoved()

			return acResult

		#>

		#< @FunctionAlternativeForm

		def AnySubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenIBU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, :stzList)

		def SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenIBUSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def AnySubstringsBetweenIBU(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBU(pcSubStr1, pcSubStr2)

		def AnySubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)

		def AnySubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)

		#>

	  #-------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZ/EXTENDED  #
	#===================================================================#
	# TODO: add FluentForms and AlternativeForms

	def BetweenUZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenUCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY

	def BetweenUZ(p1, p2, pCaseSensitive)
		return BetweenUZCS(p1, p2, :CaseSensitive = TRUE)

	  #------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- UZ/EXTENDED  #
	#============================================================#

	def SubStringsBetweenUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenUZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZZ/EXTENDED  #
	#====================================================================#

	def BetweenUZZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenUCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY

	def BetweenUZZ(p1, p2)
		return BetweenUZZCS(p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- UZZ/EXTENDED  #
	#=============================================================#

	def SubStringsBetweenUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenUZZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBUZ/EXTENDED  #
	#=====================================================================#

	def BetweenIBUZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenIBCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBUZ(p1, p2)
		return This.BetweenIBUZCS(p1, p2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- IBUZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenIBUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenIBUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenIBUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBUZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBUZZ/EXTENDED  #
	#======================================================================#

	def BetweenIBUZZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenIBCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBUZZ(p1, p2)
		return This.BetweenIBUZZCS(p1, p2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- IBUZZ/EXTENDED  #
	#===============================================================#

	def SubStringsBetweenIBUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenIBUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenIBUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBUZZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SUZ/EXTENDED  #
	#====================================================================#

	def BetweenSUZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSUZ(p1, p2)
		return This.BetweenSUZCS(p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SUZ/EXTENDED  #
	#=============================================================#

	def SubStringsBetweenSUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenSUZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenSUZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SUZZ/EXTENDED  #
	#=====================================================================#

	def BetweenSUZZCS(p1, p2, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSUZZ(p1, p2)
		return This.BetweenSUZZCS(p1, p2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SUZZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenSUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenSUZZCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenSUZZCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDUZ/EXTENDED  #
	#=====================================================================#

	def BetweenSDUZCS(p1, p2, pnStartingAt, pCaseSensitive)
		acBetween = This.BetweenSDCSQ(p1, p2, pnStartingAt, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDUZ(p1, p2)
		return This.BetweenSDUZCS(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDUZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenSDUZCS(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.BetweenSDUZCS(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDUZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.SubStringsBetweenSDUZCS(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDUZZ/EXTENDED  #
	#======================================================================#

	def BetweenSDUZZCS(p1, p2, pnStartingAt, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pnStartingAt, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDUZZ(p1, p2, pnStartingAt)
		return This.BetweenSDUZZCS(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDUZZ/EXTENDED  #
	#===============================================================#

	def SubStringsBetweenSDUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.BetweenSDUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDUZZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.SubStringsBetweenSDUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBUZ/EXTENDED  #
	#=======================================================================#

	def BetweenSDIBUZCS(p1, p2, pnStartingAt, pcDirection, pCaseSensitive)
		acBetween = This.BetweenSDIBCSQ(p1, p2, pnStartingAt, pcDirection, pcCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIBUZ(p1, p2)
		return This.BetweenSDIBUZCS(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDIBUZ/EXTENDED  #
	#================================================================#

	def SubStringsBetweenSDIBUZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)
		return This.BetweenSDIBUZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDIBUZ(pcSubStr1, pcSubStr2, pcDirection, pnStartingAt)
		return This.SubStringsBetweenSDIBUZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBUZZ/EXTENDED  #
	#========================================================================#

	def BetweenSDIBUZZCS(p1, p2, pnStartingAt, pcDirection, pCaseSensitive)
		acBetween = This.BetweenSDCSQ(p1, p2, pnStartingAt, pcDirection, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIBUZZ(p1, p2, pnStartingAt, pcDirection)
		return This.BetweenSDIBUZZCS(p1, p2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDIBUZZ/EXTENDED  #
	#=================================================================#

	def SubStringsBetweenSDIBUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirectionpCaseSensitive)
		return This.BetweenSDIBUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDIBUZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.SubStringsBetweenSDIBUZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

#---------------------------

# TODO (future): Add ..CR() to update functions (CR --> Check Return)
#--> Cheks if the function has really made its jobs (returns TRUE or FALSE)

# TODO (future): Add ..XP() to explain what the function does

#---------------------------

	  #-------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SZ/EXTENDED  #
	#===================================================================#

	def BetweenSZCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

		def BetweenSCSZ(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSZCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def BetweenSZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.BetweenSZCS(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SZZ/EXTENDED  #
	#====================================================================#

	def BetweenSZZCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

		def BetweenSCSZZ(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSZZCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def BetweenSZZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.BetweenSZZCS(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDZ/EXTENDED  #
	#====================================================================#

	def BetweenSDZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

		def BetweenSDCSZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def BetweenSDZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDZZ/EXTENDED  #
	#=====================================================================#

	def BetweenSDZZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

		def BetweenSDCSZZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDZZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def BetweenSDZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBZ/EXTENDED  #
	#======================================================================#

	def BetweenSDIBZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

		def BetweenSDIBCSZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)


	#-- WITHOUT CASESENSITIVE

	def BetweenSDIBZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDIBZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBZZ/EXTENDED  #
	#=======================================================================#

	def BetweenSDIBZZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDIBCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

		def BetweenSDIBCSZZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDIBZZCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def BetweenSDIBZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDIBZZCS(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #======================================================================#
	 #  GETIING THE NUMBER OF SUBSTRINGS BOUNDED BY GIVEN OTHER SUBSTRINGS  #
	#======================================================================#

	def NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return len(This.SubStringsBoundedByCS(pacBounds, pCaseSensitive))

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

	  #=====================================================#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=====================================================#

	def NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)

		if isString(n) and
		   (n = :First or n = :FirstSubString)

				n = 1
		ok

		aBetween = This.SubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		if isString(n) and
		   n = :Last or n = :LastSubString

			n = len(aBetween)
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		return Q(aBetween).NthItem(n)

	#-- WITHOUT CASESENSITIVITY

	def NthBetween(n, pcBound1, pcBound2)
		return This.NthBetweenCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- Z/EXTENDED  #
	#-------------------------------------------------------------------#

	def NthBetweenZCS(n, pcBound1, pcBound2, pCaseSensitive)
		cSubStr = This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		anPos   = This.FindNthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
 
		aResult = [cSubStr, anPos]
		return aResult

		def NthBetweenCSZ(n, pcBound1, pcBound2, pCaseSensitive)
			return This.NthBetweenZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenZ(n, p1, p2)
		return This.NthBetweenZCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- ZZ/EXTENDED  #
	#--------------------------------------------------------------------#

	def NthBetweenZZCS(n, p1, p2, pCaseSensitive)
		cSubStr  = This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		aSection = This.FindNthBetweenAsSectionCS(n, pcBound1, pcBound2, pCaseSensitive)

		aResult = [cSubStr, aSection]
		return aResult

		def NthBetweenCSZZ(n, p1, p2, pCaseSensitive)
			return This.NthBetweenZZCS(n, p1, p2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenZZ(n, p1, p2)
		return This.NthBetweenZZCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)
	
	  #--------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IB/EXTENDED  #
	#--------------------------------------------------------------------#
	
	def NthBetweenIBCS(n, pcBound1, pcBound2, pCaseSensitive)
		cResult = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIB(n, pcBound1, pcBound2)
		return This.NthBetweenIBCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBZ/EXTENDED  #
	#---------------------------------------------------------------------#

	def NthBetweenIBZCS(n, pcBound1, pcBound2, pCaseSensitive)

		cSubStr = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2
		nPos    = This.FindNthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive) - Q(pcBound1).NumberOfChars()
		aResult = [ cSubStr, nPos ]

		return aResult

		def NthBetweenIBCSZ(n, pcBound1, pcBound2, pCaseSensitive)
			return This.NthBetweenIBZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIBZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBZZ/EXTENDED  #
	#---------------------------------------------------------------------#

	def NthBetweenIBZZCS(n, pcBound1, pcBound2, pCaseSensitive)

		cSubStr  = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2

		aSection = This.FindNthBetweenAsSectionsCS(n, pcBound1, pcBound2, pCaseSensitive)
		aSection[1] = aSection[1] - Q(pcBound1).NumberOfChars()
		aSection[2] = aSection[2] + Q(pcBound1).NumberOfChars()

		aResult = [ cSubStr, aSection ]

		return aResult

		def NthBetweenIBCSZZ(n, pcBound1, pcBound2, pCaseSensitive)
			return This.NthBetweenIBZZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIBZZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZZCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #==============================#
	 #   NTH SUBSTRING -- EXTENDED  # 
	#==============================#

	def NthSubStringXT(n, paOption)

		cOption = ""
		pOption = []

		if isList(paOption) and
		   Q(paOption).IsOneOfTheseNamedParams([ :Between, :BetweenCS, :Where ])

			cOption = paOption[1]
			pOption = paOption[2]
		ok

		if cOption = :Between
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetween(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BetweenCS
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetweenCS(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BoundedBy
			
			if isString(pOption) or
			    ( isList(pOption) and Q(pOption).IsPairOfStrings() )

				return This.NthSubStringBoundedBy(n, pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string or a pair of strings.")
			ok

		but cOption = :Where
			if isString(pOption)
				return This.NthSubStringW(pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string.")
			ok
		else
			stzRaise("Can't proceed. Null or unrecognized option.")
		ok

	  #------------------------------------------------#
	 #   NTH SUBSTRING WHERE A CONDITION IS VERIFIED  # 
	#------------------------------------------------#

	# TODO: Reimplement it for better performance

	def NthSubStringW(n, pcCondition)
		return This.SubStringsW()[n]

	  #=======================================================================#
	 #  DEEPFINDING OCCURRENCES OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS  #
	#=======================================================================#

	/* TODO */

	  #--------------------------------------------------------------------#
	 #  DEEPFINDING SECTIONS OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS  #
	#--------------------------------------------------------------------#
	# Bounding chars are NOT counted in the result

	def DeepFindAnyBetweenAsSectionsCS(pcChar1, pcChar2, pCaseSensitive)
		aSections = This.DeepFindAnyBetweenAsSectionsIBCS(pcChar1, pcChar2, pCaseSensitive)
		nLen = len(aSections)

		aResult = []
		for i = 1 to nLen
			aSections[i][1] = aSections[i][1] + 1
			aSections[i][2] = aSections[i][2] - 1
			
		next

		return aSections

	  #--------------------------------------------------------------------------------#
	 #  DEEPFINDING SECTIONS OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS -- EXTENDED  #
	#--------------------------------------------------------------------------------#
	# Bounding chars are counted in the result

	def DeepFindAnyBetweenAsSectionsIBCS(pcChar1, pcChar2, pCaseSensitive)

		# Checking the params

		if isList(pcChar1) and Q(pcChar1).IsSubStringNamedParam()
			pcChar1 = pcChar1[2]
		ok

 		if isList(pcChar2) and
			( Q(pcChar2).IsAndNamedParam() or
			  Q(pcChar2).IsAndSubStringNamedParam() )

			pcChar2 = pcChar2[2]
		ok

		if NOT BothAreChars(pcChar1, pcChar2)
			stzRaise("Incorrect params types! pcChar1 and pcChar2 must be chars.")
		ok


		# Doing the job (sometimes we undertake a bit of magic ;)

		nNumberOfSections = This.NumberOfOccurrenceCS(pcChar1, pCaseSensitive)

		aList1 = This.FindAllCS(pcChar1, pCaseSensitive)
		aList2 = This.FindAllCS(pcChar2, pCaseSensitive)
		
		aList = Q(aList1).MergeWithQ(aList2).Sorted()
		nLenList = len(aList)
		aSections = []
		
		while TRUE
		
			for i = 2 to nLenList
			
				if ring_find(aList1, aList[i-1]) > 0 and
				   ring_find(aList2, aList[i]) > 0
			
					aSections + [ aList[i-1], aList[i] ]
					if len(aSections) = nNumberOfSections
						exit 2
					ok
		
				ok
			next
			
			aList = Q(aList).ManyRemoved(Q(aSections).Merged())
			nLenList = len(aList)
		
		end

		return aSections

		#< @FunctionFluentForm

		def DeepFindanyBetweenAsSectionsIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.DeepFindAnyBetweenAsSectionsIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def DeepFindAnyBetweenAsSectionsIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepFindAnyBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.DeepFindAnyBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.DeepFindAnyBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindAnyBetweenAsSectionsIB(pcSubStr1, pcSubStr2)
		return This.DeepFindAnyBetweenAsSectionsIBCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepFindAnyBetweenAsSectionsIBQ(pcSubStr1, pcSubStr2)
			return This.DeepFindAnyBetweenAsSectionsIBQR(pcSubStr1, pcSubStr2, :stzList)

		def DeepFindAnyBetweenAsSectionsIBQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.DeepFindAnyBetweenAsSectionsIBCSQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #-----------------------------------------------------------#
	 #   EXTRACTING DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO CHARS   # TODO: Generealize to substrings not only chars
	#-----------------------------------------------------------#
	# Bouding chars are NOT counted in the result

	def DeepAnyBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		aSections = This.DeepFindAnyBetweenAsSectionsCS(pcChar1, pcChar2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def DeepAnyBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepAnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.DeepAnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepAnyBetween(pcChar1, pcChar2)
		return This.DeepAnyBetweenCS(pcChar1, pcChar2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepAnyBetweenQ(pcChar1, pcChar2)
			return This.DeepAnyBetweenQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.DeepAnyBetweenCSQR(pcChar1, pcChar2, :CaseSensitive = TRUE, pcReturnType)
			
		#>

	  #-----------------------------------------------------------------------#
	 #   EXTRACTING DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO CHARS -- EXTENDED   # 
	#-----------------------------------------------------------------------#
	# Bound chars are counted in the result

	def DeepAnyBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

		aSections = This.DeepFindAnyBetweenAsSectionsIBCS(pcChar1, pcChar2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def DeepAnyBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.DeepAnyBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepAnyBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.DeepAnyBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepAnyBetweenIB(pcChar1, pcChar2)
		return This.DeepAnyBetweenIBCS(pcChar1, pcChar2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepAnyBetweenIBQ(pcChar1, pcChar2)
			return This.DeepAnysBetweenIBQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.DeepAnyBetweenIBCSQR(pcChar1, pcChar2, :CaseSensitive = TRUE, pcReturnType)
			
		#>

	  #========================================#
	 #  VISUALLY FINDING CHARS IN THE STRING  #
	#========================================#

	def VizFindChar(c)
		if IsStzChar(c)
			c = c.Content()
		ok

		if NOT ( isString(c) and StringIsChar(c) )
			return NULL
		ok

		cResult = @@( This.Content() )
		anPositions = This.FindAll( c )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anPositions)
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindCharQ(pItem)
			return new stzString( This.VizFindChar(pItem) )

		#>

	  #-----------------------------------------#
	 #      VISUALLY FINDING A SUBSTRING       #
	#-----------------------------------------#

	def VizFindXT(pcSubStr, paOptions)

		# STEP 1: Checking params TYPES
		
		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT ( isList(paOptions) and
			 Q(paOptions).IsHashList() and

			 StzHashListQ(paOptions).KeysQ().IsMadeOfSome([
				:CaseSensitive, :CS, :PositionSign,
				:BlankSign, :Numbered, :Spacified,
				:Boxed, :BoxOptions ]) )
			 
			stzRaise("Incorrect param type! paOptions must be a wellformed hashlist.")
		ok

		# At this level, we are sure pcSubStr is a string and
		# paOptions is a hashlist made of some of the allowed keys for boxing

		# Before going further, Delegate the work to VizFindBoxedXT()
		# when boxing is required

		if StzHashListQ(paOptions).ContainsKey(:Boxed) and
		   IsBoolean(paOptions[ :Boxed ]) and paOptions[ :Boxed ] = TRUE

			return This.VizFindBoxedXT(pcSubStr, paOptions)
		ok

		if StzHashListQ(paOptions).KeysQ().ContainsBoth(:CaseSensitive, :CS)
			stzRaise("Incorrect options! :CaseSensitive and its short form :CS must not be used both.")
		ok

		# Unfying the :CaseSensitive / :CS keyword

		n = StzHashListQ(paOptions).FindKey(:CS)
		if n > 0
			paOptions[n][1] = :CaseSensitive
		ok

		# STEP 2: Reading params values

		bCaseSensitive = TRUE
		if ( isString(paOptions[:CaseSensitive]) and paOptions[:CaseSensitive] != NULL ) or
		   ( isNumber(paOptions[:CaseSensitive]) and IsBoolean(paOptions[:CaseSensitive])  )

			bCaseSensitive = paOptions[:CaseSensitive]
		ok

		cPositionSign = "^"
		if isString(paOptions[:PositionSign]) and paOptions[:PositionSign] != NULL
			cPositionSign = paOptions[:PositionSign]
		ok

		cBlankSign = "-"
		if isString(paOptions[:BlankSign]) and paOptions[:BlankSign] != NULL
			cBlankSign = paOptions[:BlankSign]
		ok

		bNumbered = FALSE
		if ( isString(paOptions[:Numbered]) and paOptions[:Numbered] != NULL ) or
		   ( isNumber(paOptions[:Numbered]) and IsBoolean(paOptions[:Numbered])  )

			bNumbered = paOptions[:Numbered]
		ok

		bSpacified = FALSE
		if ( isString(paOptions[:Spacified]) and paOptions[:Spacified] != NULL ) or
		   ( isNumber(paOptions[:Spacified]) and IsBoolean(paOptions[:Spacified])  )

			bSpacified = paOptions[:Spacified]
		ok

		# STEP 3: Checking the correctness of the provided values

		bCorrect = TRUE
		acWhy = [] # Will host the reasons of the errors

		If NOT IsBoolean(bCaseSensitive)

			bCorrect = FALSE
			acWhy + ":CaseSensitive option must be a boolean"
		ok

		if NOT ( isString(cPositionSign) and StringIsChar(cPositionSign) )

			bCorrect = FALSE
			acWhy + ":PositionSign option must be a char"
		ok

		if NOT ( isString(cBlankSign) and StringIsChar(cBlankSign) )

			bCorrect = FALSE
			acWhy + ":BlankSign option must be char"
		ok

		if NOT cPositionSign != cBlankSign

			bCorrect = FALSE
			acWhy + ":PositionSign and :BlankSign options must be different"
		ok

		If NOT IsBoolean(bNumbered)

			bCorrect = FALSE
			acWhy + ":Numbered option must be a boalean"
		ok

		If NOT IsBoolean(bSpacified)

			bCorrect = FALSE
			acWhy + ":Spacified option must be a boalean"
		ok

		if NOT bCorrect
			stzRaise([
				:Where	= "stzString.ring > vizFindXT()",
				:What	= StzListOfStringsQ(acWhy).ConcatenatedUsing(", ") + "."
			])
		ok

		# At this level, we are sure the params are well formed
		#--> Let's do the job!

		if bSpacified
			cString= @@( This.Spacified() )
		else
			cString = @@( This.Content() )
		ok

		oString = new stzString(cString)

		anPositions = oString.FindAllCS( pcSubStr, :CS = bCaseSensitive )

		anVizPositions = StzListOfNumbersQ(anPositions).
				 SubstractFromEachQ(1).Content()

		nLen = oString.NumberOfChars()

		cVizLine = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anVizPositions)
				cVizLine += cPositionSign
			else
				cVizLine += cBlankSign
			ok

		next

		cResult = oString.Content() + NL + cVizLine

		if bNumbered

			oVizLine = new stzString(cVizLine)

			oVizLine {
	
				Replace(cBlankSign, " ")

				cCondition = '@char = ' + @@(cPositionSign)

				if NOT bSpacified

					cReplacement@ = '{ Q( ""+ ( This.FindAll(' +
						 @@(cPositionSign) +
						 ')[@i] - 1 ) ).LastChar() }'

				else

					cReplacement@ = '{ Q( ""+ ( This.FindAll(' +
						 @@(cPositionSign) +
						 ')[@i] / 2 ) ).LastChar() }'
					
				ok

				ReplaceW( :Where = cCondition, :With@ = cReplacement@ )

			}

			cResult += NL + oVizLine.TrailingSpacesRemoved()

		ok

		return cResult

		#< @FunctionFluentForm

		def VizFindXTQ(pcSubStr, paOptions)
			return new stzString( This.VizFindXT(pcSubStr, paOptions) )

		#>

	def VizFind(pcSubStr)
		return This.VizFindXT(pcSubStr, [ :PositionChar = "^" ] )

	def VizFindCS(pcSubStr, pCaseSensitive)
		return This.VizFindXT(pcSubStr, [ pCaseSensitive ])
		
	  #----------------------------------------------------#
	 #      VISUALLY FINDING AND BOXING A SUBSTRING       # TODO: Review this
	#----------------------------------------------------#

	def VizFindBoxedXT(pcSubstr, paOptions) # TODO
		/* EXAMLPE

		*/

		if NOT ( isString(pcSubStr) or
		  	sList(paOptions) and StzListQ(paOptions).IsBoxOptionsNamedParam() )

			stzRaise("Incorrect params!")
		ok


/*
	
			if paOptions[ :Casesensitive ] = TRUE or
			   paOptions[ :CS ] = TRUE
	
				paOptions + [ :Hilighted, 
					      This.FindAllCS(pcSubStr, :CS = TRUE)
					    ]
			else
				paOptions + [ :Hilighted, 
					      This.FindAllCS(pcSubStr, :CS = FALSE)
					    ]
			ok
	
			StzHashListQ(paOptions) {
				RemovePairByKeyQ(:Casesensitive = TRUE)
				RemovePairByKeyQ(:CS = TRUE)
				paOptions = Content()
			}
	
			oStzListOfChars = new stzListOfChars(This.String())
			return oStzListOfChars.BoxedXT(paOptions)
	*/

	  #======================================#
	 #   CONTAINMENT OF A GIVEN SUBSTRING   #
	#======================================#

	def ContainsCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.indexOf() >

		# Checking params

		if isList(pcSubStr)
			return This.ContainsTheseSubStringsCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a STRING, while you are providing a " +
				   ring_type(pcSubStr) + ".")
		ok

		# Resolving pCaseSensitive param

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job (Qt-side)

		nPos = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1

		if nPos > 0
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def ContainsSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(cSubStr, pCaseSensitive)
		#>

		#< @FunctionNegativeForm

		def ContainsNoCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		def ConttainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Contains(pcSubStr)
		return This.ContainsCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def ContainsSubString(pcSubStr)
			return This.Contains(pcSubStr)
		#>

		#< @FunctionNegativeForm

		def ContainsNo(pcSubStr)
			return NOT This.Contains(pcSubStr)

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pcSubStr)
			return This.Contains(pcSubStr)

		def Conttains(pcSubStr)
			return This.Contains(pcSubStr)

		#>

	  #------------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS CONTAINED IN AN OTHER GIVEN STRING   #
	#------------------------------------------------------------------#

	def IsContainedInCS(pcOtherStr, pCaseSensitive)

		if NOT Q(pcOtherStr).IsStringOrList()
			StzRaise("Incorrect param type! pcOtherStr must be a string or list.")
		ok

		bResult = Q(pcOtherStr).ContainsCS(This.String(), pCaseSensitive) 
		return bResult

		#< @FunctionAlternativeForms

		def IsIncludedInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		def ExistsInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(pcOtherStr)
		return This.IsContainedInCS(pcOtherStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def IsIncludedIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		def ExistsIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		#>

	  #------------------------------------------------#
	 #   CHECKING CONATAINMENT ON A GIVEN CONDITION   #
	#------------------------------------------------#

	def ContainsW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)
		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Icnorrect syntax! pcCondition must contain either @char or @substring keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.ContainsSubStringsW(pcCondition)

		else
			return This.ContainsCharsW(pcCondition)
		ok

	def ContainsCharsW(pcCondition)
		/* EXAMPLE

		? Q("__---__").ContainsXT(:CharsWhere, '@charQ.IsEither("_", :Or = "-")')
		#--> TRUE
		*/

		if (NOT isString(pcCondition)) or
		   (isString(pcCondition) and Q(pcCondition).WithoutSpaces() = "")

			return FALSE
		ok

		cCondition = StzCCodeQ(pcCondition).Transpiled()
		
		bResult = FALSE
		nLen = This.NumberOfChars()

		for @i = 1 to nLen
			cCode = 'bOk = (' + cCondition + ')'

			eval(cCode)
			if bOk
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def ContainsSubStringsW(pcCondition)
		if (NOT isString(pcCondition)) or
		   (isString(pcCondition) and Q(pcCondition).WithoutSpaces() = "")

			return FALSE
		ok

		pcCondition = StzStringQ(pcCondition).
				ReplaceCSQ("@substring", "@item", :CS = FALSE).
				Content()

		bResult = This.SubStringsQ().ContainsW(pcCondition)

		return bResult

	  #--------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITON/SUBSTRING  #
	#--------------------------------------------------------------------------------------#

	def ContainsBeforeCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosBefore = p

		if isString(p)
			nPosBefore = This.FindLastCS(p, pCaseSensitive)
		ok

		bResult = This.ContainsInSectionCS(pcSubStr, 1, nPosBefore-1, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsBefore(pcSubStr, p)
		return This.ContainsBeforeCS(pcSubStr, p, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITON/SUBSTRING  #
	#-------------------------------------------------------------------------------------#

	def ContainsAfterCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosAfter = p

		if isString(p)
			nPosAfter = This.FindFirstCS(p, pCaseSensitive)
		ok

		nLenSubStr = This.NumberOfChars()
		bResult = This.ContainsInSectionCS(pcSubStr, nPosAfter+1, nLenSubStr, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfter(pcSubStr, p)
		return This.ContainsAfterCS(pcSubStr, p, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITON  #
	#----------------------------------------------------------------------------#

	def ContainsBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforePosition(pcSubStr, pnPos)
		return This.ContainsBeforePositionCS(pcSubStr, pnPos, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#------------------------------------------------------------------------------#

	def ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforeSubString(pcSubStr1, pcSubStr2)
		return This.ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITON  #
	#---------------------------------------------------------------------------#

	def ContainsAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterPosition(pcSubStr, pnPos)
		return This.ContainsAfterPositionCS(pcSubStr, pnPos, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterSubString(pcSubStr1, pcSubStr2)
		return This.ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #=======================================#
	 #   CHECKING CONATAINMENT -- EXTENDED   #
	#=======================================#

	def ContainsXTCS(p1, p2, pCaseSensitive)
		
		#=== GENERAL

		# ? Q("").ContainsXT(:Chars, []) #--> FALSE
		if This.String() = "" and isString(p1) = :Chars and
		   (  (isList(p2)   and len(p2) = 0) or
		      (isString(p2) and p2 = ""    ) or
		      (isNumber(p2) and p2 = 0     )    )

			return FALSE

		# ? Q("").ContainsXT([], :Chars) #--> FALSE
		but ( (isList(p1)   and len(p1) = 0) or
		      (isString(p1) and p1 = ""    ) or
		      (isNumber(p1) and p1 = 0     )    ) and

		    isString(p2) and p2 = :Chars

			return FALSE

		# ? Q("__♥__").ContainsXT("♥", "_")
		but BothAreStrings(p1, p2) and
		    NOT Q(p1).IsOneOfThese([
			:CharsW, :CharsWhere, :SubStringsW, :SubStringsWhere
			])

			return This.ContainsTheseCS([p1, p2], pCaseSensitive)
		
		# ? Q("__♥__").ContainsXT("♥", "_")
		but isString(p1) and isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :And

			return This.ContainsTheseCS([p1, p2[2]], pCaseSensitive)

		# ? Q("__♥__♥__").ContainsXT(2, "♥")
		but isNumber(p1) and isString(p2)
			return This.ContainsNOccurrencesCS(p1, p2, pCaseSensitive)
		
		# ? Q("__♥__♥__").ContainsXT( :Exactly = 2, "♥" )
		but isList(p1) and Q(p1).IsExactlyNamedParam()
			return This.ContainsNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("__♥__♥__").ContainsXT( :MoreThen = 1, "♥")
		but isList(p1) and Q(p1).IsMoreThenNamedParam()
			return This.ContainsMoreThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("__♥__♥__").ContainsXT( :LessThen = 3, "♥")
		but isList(p1) and Q(p1).IsLessThenNamedParam()
			return This.ContainsLessThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("__♥__").ContainsXT("♥", [])
		but isString(p1) and isList(p2) and len(p2) = 0 and
			NOT Q(p2).IsWhereNamedParam()

			return This.ContainsCS(p1, pCaseSensitive)

		# ? Q("_-♥-_").ContainsXT("♥", :BoundedBy = "-")
		# ? Q("_-♥-_").ContainsXT(:SubString = "♥", :BoundedBy = "-")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBoundedByNamedParam()

			if isList(p1) and Q(p1).IsSubStringNamedParam()
				p1 = p1[2]
			ok

			return This.ContainsSubStringBoundedByCS(p1, p2[2], pCaseSensitive)
		
		# ? Q("_/♥\_").ContainsXT("♥", :Between = ["/", :And = "\"])
		but isString(p1) and isList(p2) and Q(p2).IsBetweenNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			if Q(p2[2]).isListOfStrings()
				return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			but Q(p2[2]).isListOfNumbers()
				return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			ok

		# ? Q("..<<--♥♥♥-->>..").ContainsXT("♥♥♥", :InBetween = ["<<", ">>"])
		but isString(p1) and isList(p2) and Q(p2).IsInBetweenNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			if Q(p2[2]).isListOfStrings()
				return This.ContainsInBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
			ok

		but isString(p1) and isList(p2) and
		    Q(p2).IsInSectionNamedParam() and
		    isList(p2[2]) and Q(p2[2]).IsPairOfNumbers()

			return This.containsInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)


		but isString(p1) and isList(p2) and Q(p2).IsBetweenSubStringsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		but isString(p1) and isList(p2) and Q(p2).IsBetweenPositionsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		# ? Q("__-♥-__").ContainsXT(["_", "-", "♥"], [])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and len(p2) = 0
			return This.ContainsTheseCS(p1, pCaseSensitive)
		
		# ? Q("__-♥-__-•-__").ContainsXT(["♥", "•"], :BoundedBy = "-")
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBoundedByNamedParam()
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBoundedByCS(p1[i], p2[2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("__/♥\__/•\__").ContainsXT(["♥", "•"], :Between = ["/","\"])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok
		
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBetweenCS(p1[1], p2[2][1], p2[2][2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("__♥__").ContainsXT([], "♥")
		but isList(p1) and len(p1) = 0 and isString(p2)
			return This.ContainsCS(p2, pCaseSensitive)
		
		# ? Q("__♥__♥__").ContainsXT( [], :BoundedBy = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBoundedByNamedParam()
			return This.ContainsSubStringsBoundedByCS(p2[2], pCaseSensitive)
		
		# ? Q("__/♥\__/^^\__").ContainsXT( [], :Between = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok
		
			return This.ContainsSubStringsBetweenCS(p2[2][1], p2[2][2], pCaseSensitive)
			
		#=== CHARS

		# ? Q("__-♥-__").ContainsXT(:Chars, ["_", "-", "_"])
		# ? Q("__-♥-__").ContainsXT(:TheseChars, ["_", "-", "_"])
		but isString(p1) and (p1 = :Chars or p1 = :TheseChars) and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsTheseSubStrings(p2)

		# ? Q("__-♥-__").ContainsXT(:SomeOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :SomeOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsSomeOfTheseSubStrings(p2)

		# ? Q("__-♥-__").ContainsXT(:OneOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :OneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsOneOfTheseSubStrings(p2)

		# ? Q("__-♥-__").ContainsXT(:NoneOfTheseChars, ["A", "*", "B"])
		but isString(p1) and p1 = :NoneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsNoneOfTheseSubStrings(p2)

		# ? Q("__---__").ContainsXT(:CharsWhere, '@charQ.IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:CharsW, '@charQ.IsEither("_", :Or = "-")')
		but isString(p1) and (p1 = :CharsWhere or p1 = :CharsW) and isString(p2)
			return This.ContainsCharsW(p2)
		
		# ? Q("__---__").ContainsXT(:Chars, :Where = '@charQ.IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:Chars, Where('@charQ.IsEither("_", :Or = "-")'))
		# ? Q("__---__").ContainsXT(:Chars, W('@charQ.IsEither("_", :Or = "-")'))
		but isString(p1) and p1 = :Chars and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return this.ContainsCharsW(p2[2])

		#=== SUBSTRINGS

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStrings, ["softanza", :And = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:TheseSubStrings, ["softanza", :And = "ring"])
		but isString(p1) and (p1 = :SubStrings or p1 = :TheseSubStrings) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfTheseSubStrings, ["ring", "php", :Or = "softanza"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfThese, ["ring", "php", "softanza"])
		but isString(p1) and (p1 = :SomeOfTheseSubStrings or p1 = :SomeOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsSomeOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfTheseSubStrings, ["python", "php", :Or = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :OneOfTheseSubStrings or p1 = :OneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsOneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfTheseSubStrings, ["python", "php", :Nor = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :NoneOfTheseSubStrings or p1 = :NoneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsNoneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsWhere, '@SubStringQ.IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, '@SubStringQ.IsUppercase()')
		but isString(p1) and (p1 = :SubStringsWhere or p1 = :SubStringsW) and isString(p2)

			return This.ContainsSubStringsW(p2)
			
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where = '@SubStringQ.IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where('@SubStringQ.IsUppercase()') )
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :W('@SubStringQ.IsUppercase()') )
		but isString(p1) and p1 = :SubStringsW and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return This.ContainsSubStringsW(p2[2])

		# ? Q("^^♥^^").ContainsXT("♥", :AtPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPosition ]) and
		    isNumber(p2[2])

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAt(p2[2], p1)

		# ? Q("♥^^♥^^♥").ContainsXT("♥", :AtPositions = [1, 4, 7])
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPositions ]) and
		    isList(p2[2]) and Q(p2[2]).IsListOfNumbers()

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAtPositions(p2[2], p1)

		# ? Q("^^♥^^").ContainsXT("^", :Before = "♥^")
		# ? Q("^^♥^^").ContainsXT("^", :Before = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforeNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsBefore(p1, p2[2])

		# ? Q("--♥^^").ContainsXT("^", :After = "-♥")
		# ? Q("^^♥^^").ContainsXT("^", :After = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsAfter(p1, p2[2])

		# ? Q("^^♥^^").ContainsXT("^", :BeforePosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforePositionNamedParam() and isNumber(p2[2])

			return This.ContainsBefore(p1, :Position = p2[2])

		# ? Q("^^♥^^").ContainsXT("^", :AfterPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterPositionNamedParam() and isNumber(p2[2])

			return This.ContainsAfter(p1, :Position = p2[2])

		# ? Q("^^♥^^").ContainsXT("^", :BeforeSubString = "♥^")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforeSubStringNamedParam() and isString(p2[2])

			return This.ContainsBefore(p1, :SubString = p2[2])

		# ? Q("--♥^^").ContainsXT("^", :AfterSubString = "-♥")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterSubStringNamedParam() and isString(p2[2])

			return This.ContainsAfter(p1, :SubString = p2[2])

		else

			StzRaise("Unsupported syntax")
		ok

	#-- WITOUT CASESENSITIVITY

	def ContainsXT(p1, p2)
		return This.ContainsXTCS( p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #   CONTAINING A SUBSTRING BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS   #
	#-------------------------------------------------------------------#

	def ContainsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive) # :CaseSensitive = TRUE or :CaseSensitive = FALSE

		# Case where bounds are provided as numbers

		if isList(pacBounds) and Q(pacBounds).IsSectionNamedParam() and
		   Q(pacBounds[2]).IsPairOfNumbers()

			pacBounds = pacBounds[2]
		ok

		if isList(pacBounds) and Q(pacBounds).IsPositionsNamedParam() and
		   Q(pacBounds[2]).IsPairOfNumbers()

			pacBounds = pacBounds[2]
		ok

		# ? Q("^^♥^^").ContainsBoundedBy("♥", :Positions = [ 2, :And = 4])

		if isList(pacBounds) and Q(pacBounds).IsPositionsNamedParam() and
		   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and
		   Q(pacBounds[2][2]).IsAndNamedParam()

				aTemp = []
				aTemp + pacBounds[2][1]
				aTemp + pacBounds[2][2][2]
				pacBounds = aTemp
		ok

		if isList(pacBounds) and len(pacBounds) = 2
			
			if isList(pacBounds[1]) and Q(pacBounds[1]).IsOneOfTheseNamedParams([ :Position, :Positions ])
				pacBounds[1] = pacBounds[1][2]
			ok

			if isList(pacBounds[2]) and Q(pacBounds[2]).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				pacBounds[2] = pacBounds[2][2]
			ok 
		ok

		if isList(pacBounds) and Q(pacBounds).IsPairOfNumbers()

			aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			nLen = len(aSections)

			for i = 1 to nLen
				if aSections[i][1] = pacBounds[1] + 1 and
				   aSections[i][2] = pacBounds[2]  - 1

					return TRUE
				ok
			next

			return FALSE
		ok

		# Case where bounds are provided as strings

		if isList(pacBounds) and Q(pacBounds).IsAndNamedParam()
			pacBounds[2] = pacBounds[2]
		ok

		bResult = Q(pcSubStr).IsBoundedByIB(pacBounds, :InSide = This.String())

		return bResult

		#< @FunctionAlternativeForm

		def ContainsSubstringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundedBy(pcSubStr, pacBounds)
		return This.ContainsSubstringBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def ContainsSubStringBoundedBy(pcSubStr, pacBounds)
			return This.ContainsBoundedBy(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #    CONTAINING ANY SUBSTRINGS BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS   #
	#-----------------------------------------------------------------------#

	def ContainsAnyBoundedByCS(pacBounds, pCaseSensitive)
		return This.ContainsTheseBoundsCS(pacBounds, pCaseSensitive)

		def ContainsAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			if isList(pcBound1) and Q(pcBound1).IsSubStringNamedParam()
				pcBound1 = pcBound1[2]
			ok

			if NOT isString(pcBound1)
				StzRaise("Incorrect param type! pcBound1 must be a string.")
			ok

			if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
				pcBound2 = pcBound2[2]
			ok

			if NOT isString(pcBound21)
				StzRaise("Incorrect param type! pcBound2 must be a string.")
			ok

			return This.ContainsAnyBoundedByCS([pcBound1, pcBound2], pCaseSensitive)

	#--

	def ContainsAnyBoundedBy(pacBounds)
		return This.ContainsAnyBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		def ContainsAnyBetween(pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #    CONTAINING SUBSTRINGS BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS    #
	#--------------------------------------------------------------------#

	def ContainsSubStringsBoundedByCS(paBounds, pCaseSensitive)
		/* EXAMPLE

		? Q("__/ring\__/is\__/fun\__").ContainsSubStringsBoundedBy(["/", "\"])
		#--> TRUE
		*/

		bResult = FALSE

		if isString(paBounds)
			bResult = This.NumberOfOccurrenceCSQ(paBounds, pCaseSensitive).IsEven()

		but isList(paBounds) and Q(paBounds).IsPair()
			if isList(paBounds[2]) and Q(paBounds[2]).IsAndNamedParam()
				paBounds[2] = paBounds[2][2]
			ok

			if Q(paBounds).IsPairOfStrings()

				n1 = This.FindFirstCS(paBounds[1], pCaseSensitive)
				n2 = This.FindFirstCS(paBounds[2], pCaseSensitive)
	
				if n2 > n1
					bResult = TRUE
				ok

			ok
		ok

		return bResult

		#< @FuntionAlternativeForm

		def ContainsSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsSubStringsBoundedByCS([pcBound1, pcBound2], pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsBoundedBy(paBounds)
		return This.ContainsSubStringsBoundedByCS(paBounds, :CaseSensitive = TRUE)

		#< @FuntionAlternativeForm

		def ContainsSubStringsBetween(pcBound1, pcBound2)
			return This.ContainsSubStringsBoundedBy([pcBound1, pcBound2])

		#>

	  #--------------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#--------------------------------------------------------------#

	def ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([
			:Position, :Positions, :SubString, :SubStrings ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([
			:And, :AndPosition, :AndSubString ])
			p2 = p2[2]
		ok

		bResult = FALSE

		# Q("^^♥♥♥^^").ContainsBetween("♥♥♥", 3, 5)
		if BothAreNumbers(p1, p2)
			if This.SectionQ(p1, p2).ContainsCS(pcSubStr, pCaseSensitive)
				bResult = TRUE
			ok

		# Q("<<♥♥♥>>").ContainsBetween("♥♥♥", "<<", ">>")
		but BothAreStrings(p1, p2)
			bResult = This.ContainsSubstringBoundedByCS(pcSubStr, [p1, p2], pCaseSensitive)

		else
			StzRaise("Incorrect param! p1 and p2 must be both numbers or strings.")
		ok

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		def ContainsInBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		def ContainsSubstringInBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetween(pcSubStr, p1, p2)
		return This.ContainsBetweenCS(pcSubStr, p1, p2, :CaseSensitive = TRUE)

		def ContainsSubstringBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

		def ContainsInBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

		def ContainsSubstringInBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

	  #------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO GIVEN POSITIONS  #
	#------------------------------------------------------#

	def ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
		if isList(n2) and Q(n2).IsAndNamedParam()
			n2 = n2[2]
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param types! Both n1 and n2 must be numbers.")
		ok

		return This.ContainsBetweenCS(pcSubStr, n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		def ContainsInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetweenPositions(pcSubStr, n1, n2)
		return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenPositions(pcSubStr, n1, n2)
			return This.ContainsBetweenPositions(pcSubStr, n1, n2)

		def ContainsInSection(pcSubStr, n1, n2)
			return This.ContainsBetweenPositions(pcSubStr, n1, n2)

		#>

	  #--------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#--------------------------------------------------------#

	def ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound1) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRais("Incorrect param types! Both pcBound1 and pcBound2 must be numbers.")
			# NOTE that this is a misspelled form of StzRaise()
		ok

		return This.ContainsBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def ContainsSubStringBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetweenSubStrings(pcSubStr, pcBound1, pcBound2)
		return This.ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def ContainsSubstringBetweenSubStrings(pcSubStr, pcBound1, pcBound2)
			return This.ContainsBetweenSubStrings(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN NUMBER OF BOUNDED SUBSTRINGS  #
	#------------------------------------------------------------------------#

	def ContainsNSubStringsBoundedByCS(n, pacBounds, pCaseSensitive)
		if n = This.NumberOfubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

		def ContainsNSubStringsBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsNSubStringsBoundedByCS(n, [pcBound1, pcBound2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNSubStringsBoundedBy(n, pacBounds)
		return This.ContainsNSubStringsBoundedByCS(n, pacBounds, :CaseSensitive = TRUE)

		def ContainsNSubStringsBetween(n, pcBound1, pcBound2)
			return This.ContainsNSubStringsBoundedBy(n, [pcBound1, pcBound2])

	  #----------------------------------------------#
	 #    CONTAINING ONE OF THE GIVEN SUBSTRINGS    #
	#----------------------------------------------#

	def ContainsOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE
		nLen = len(paSubStr)

		for i = 1 to nLen
			if This.ContainsCS( paSubStr[i],  pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#--

		def ContainsOneOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(paSubStr)
		return This.ContainsOneOfTheseCS(paSubStr, :Casesensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsAnyOfThese(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#--

		def ContainsOneOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#>

	  #-------------------------#
	 #    CONTAINING SPACES    #
	#-------------------------#

	def ContainsSpaces()
		return This.Contains(" ")

		#< @FunctionNegativeForm

		def ContainsNoSpaces()
			return NOT This.ContainsSpaces()

		#>

	  #------------------------------------------------#
	 #    CONTAINING BOTH OF THE GIVEN SUBSTRINGS     #
	#------------------------------------------------#

	def ContainsBothCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and Q(pcStr2).IsAndNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.ContainsEachCS( [pcStr1, pcStr2], pCaseSensitive )

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pcStr1, pcStr2)
		return This.ContainsBothCS(pcStr1, pcStr2, :CaseSensitive = TRUE)
	
	  #==============================================#
	 #   REMOVING A SUBSTRING AT A GIVEN POSITION   #
	#==============================================#

	def RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		if This.ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			nRange = StzStringQ(pcSubStr).NumberOfChars()
			This.RemoveRange(n, nRange)
		ok

		#< @FunctionFluentForm

		def RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		#>

	def SubStringAtPositionNRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubsStringAtPositionCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAt(n, pcSubStr)
		This.RemoveSubStringAtPositionCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtQ(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPosition(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)

		#>

	def SubStringAtPositionNRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveSubsStringAtPositionQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------#
	 #   REMOVING A SUBSTRING AT A SOME GIVEN POSITIONS    #
	#-----------------------------------------------------#

	def RemoveSubStringAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python rping cshar ring")
		o1.RemoveSubstringAtPositions([ 10, 20, 32, 44 ], "ring")

		? o1.Content() #--> "ring php ruby python csharp"
		*/

		if NOT isList(panPositions) and Q(panPositions).IsListOfNumbers()
			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		anPositions = Q(panPositions).SortedInAscending()

		# Doing the job

		for i = len(anPositions) to 1 step -1
			n = anPositions[i]

			This.RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemovedCS(panPos, pcSubStr, pCaseSensitive)

		cResult = This.
			  Copy().
			  RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive).
			  Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAtPositions(panPositions, pcSubStr)
		This.RemoveSubStringAtPositionsCS(panPositions, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsQ(panPos, pcSubStr)
			This.RemoveSubStringAtPositions(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemoved(panPos, pcSubStr)
		return This.SubStringAtPositionsRemovedCS(panPos, pcSubStr, :CaseSensitive = TRUE)

	  #================================================#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if ( (isNumber(n)) and (isString(pcSubStr)) ) or
		   ( (isString(n)) and (isNumber(pcSubStr)) )

			return This.ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		but ( isList(n) and Q(n).IsListOfNumbers() and isString(pcSubStr) ) or
		    ( isString(n) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers() )

			return This.ContainsAtPositionsCS(n, pcSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param types! n must be a number and pcSubStr must be a string or vice versa.")
		ok

		def ContainsSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

	def ContainsAt(n, pcSubStr)
		return This.ContainsAtCS(n, pcSubStr, :CaseSensitive = TRUE)

		def ContainsSubStringAt(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

	  #------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(n) and isNumber(pcSubStr)
			temp = pcSubStr
			pcSubStr = n
			n = temp
		ok

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# ? Q("^^♥^^").ContainsAt(2, "♥")

		bResult = FALSE
		bContinue = TRUE
		i = 1

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		bResult = ring_find(anPos, n)

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		def SubStringExistsAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPosition(n, pcSubStr)
		return This.ContainsAtPositionCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		def SubStringExistsAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT GIVEN (MANY) POSITIONS   #
	#======================================================#

	def ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		if isList(panPositions) and
		   Q(panPositions).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			panPositions = panPositions[2]
		ok

		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(panPositions) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers()
			temp = pcSubStr
			pcSubStr = panPositions
			panPositions = temp
		ok

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param type! panPositions must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
			return This.ContainsSubStringsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)
		ok

		bResult = TRUE
		nLen = len(panPositions)

		for i = 1 to nLen
			if NOT This.ContainsSubStringAtPositionCS(panPositions[i], pcSubStr, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		def ContainsSubStringAtThesePositionsCS(panPositions, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPositions(panPositions, pcSubStr)
		return This.ContainsAtPositionsCS(panPositions, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositions(panPositions, pcSubStr)
			return This.ContainsAtPositions(panPositions, pcSubStr)

		def ContainsSubStringAtThesePositions(panPositions, pcSubStr)
			return This.ContainsAtPositions(panPositions, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   CONTAINING SUBSTRINGS AT GIVEN POSITIONS    #
	#-----------------------------------------------#

	def ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		if NOT ( isList(panPositions) and Q(panPositions).IsListOFNumbers() )

			stzRaise("Incorrect param type! panPositions must be a list of numbers.")
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if NOT ( len(panPositions) = len(pacSubStr) )
			stzRaise("Incorrect values! panPositions and pacSubStr lists must have same number of items.")
		ok

		bResult = TRUE

		# TODO: change for in with for loop --> better performance
		i = 0
		for n in panPositions
			i++
			if NOT This.ContainsSubStringAtPosition(n, pacSubStr[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositionsCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		def ContainsSubStringsAtCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		def ContainsManyAtCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsAtPositions(panPositions, pacSubStr)
		return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositions(n, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		def ContainsSubStringsAt(panPositions, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		def ContainsManyAt(panPositions, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   CONTAINING SOME (ONE OR MORE) SUBSTRINGS   #
	#----------------------------------------------#

	def ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfString() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		bResult = FALSE

		nLen = len(pacSubStr)
		n = 0
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				n++
				if n > 1
					bResult = TRUE
					exit
				ok
			ok
		next

		return bResult
		
	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMore(paSubStr)
		return This.ContainsOneOrMoreCS(paSubStr, :CS = TRUE)

	  #------------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A SUBSTRING     #
	#------------------------------------------------#

	def ContainsNTimesCS(n, pcSubstr, pCaseSensitive)
		return This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive) = n

		def ContainsNTimesTheSubstringCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNTimesCS(n, pcSubstr, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ContainsNTimes(n, pcSubStr)
		return This.ContainsNTimesCS(n, pcSubstr, :CaseSensitive = TRUE)

		def ContainsNTimesTheSubstring(n, pcSubstr)
			return This.ContainsNTimes(n, pcSubstr)

	  #-------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A CHAR     #
	#-------------------------------------------#

	def ContainsNTimesTheChar(n, pcChar)
		if NOT IsChar(pcChar)
			return FALSE
		ok
		
		return This.ContainsNTimesCS(n, pcChar, :CaseSensitive = FALSE)

	  #-------------------------------------------------#
	 #    CONTAINING ONE OCCURRENCE OF A SUBSTRING     #
	#-------------------------------------------------#

	def ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)
		return This.ContainsNTimesCS(1, pcSubStr, pCaseSensitive)
	
		#< @FunctionAlternativeForms

		def ContainsOnlyOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		def ContainsOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOccurrence(pcSubStr)
		return This.ContainsOneOccurrenceCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsOnlyOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		def ContainsOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		#>
	  #----------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS SOME (MORE THAN ONE OCCURRENCE) OF A SUBSTRING  #
	#----------------------------------------------------------------------------------#

	def ContainsSomeCS(pcSubstr, pCaseSensitive)
		return This.ContainsMoreThanNOccurrencesCS(1, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSome(pcSubstr)
		return This.ContainsMoreThanOneOccurrenceCS(pcSubstr, :CaseSensitive = TRUE)
			
	  #--------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THAN N OCCURRENCES OF A SUBSTRING  #
	#--------------------------------------------------------------------------#

	def ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

		bResult = FALSE

		bContinue = TRUE
		i = 0
		nPos = 0

		while bContinue
	
			nPos = This.FindFirstXTCS(pcSubStr, :StartingAt = nPos + 1, pCaseSensitive)
			if nPos = 0
				bContinue = FALSE
			else
				i++
				if i > n
					bResult   = TRUE
					bContinue = FALSE
				ok
			ok
		end

		return bResult

		def ContainsMoreThenNCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThanNOccurrences(n, pcSubstr)
		return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, :CaseSensitive = TRUE)

		def ContainsMoreThenN(n, pcSubStr)
			return This.ContainsMoreThanNOccurrences(n, pcSubstr)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OR MORE OCCURRENCES OF A SUBSTRING  #
	#------------------------------------------------------------------------#

	def ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)
		bResult = This.ContainsMoreThenNOccurrencesCS(n - 1, pcSubStr, pCaseSensitive)
		return bResult

		def ContainsNOrMoreCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOrMoreOccurrences(n, pcSubstr)
		return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, :CaseSensitive = TRUE)
	
		def ContainsNOrMore(n, pcSubStr)
			return This.ContainsNOrMoreOccurrences(n, pcSubstr)

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS EACH OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
		bResult = TRUE
		nLen = len(pacSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(pacSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsManyCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsEachOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

		#< @FunctionNegativeForms

		def ContainsNoneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoOneOfCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([ :These, :TheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsNoSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoSubStringCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseSubStrings(pacSubStr)
		return This.ContainsTheseSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsMany(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEach(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOne(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		#>

		#< @FunctionNegativeForm

		def ContainsNoneOfTheseSubStrings(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoneOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNone(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoOneOf(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubStringOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubString(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #    CONTAINING CHARS IN A GIVEN SCRIPT   #
	#-----------------------------------------#

	def ContainsCharsInScript(pcScript)
		return This.ToStzText().ContainsScript(pcScript)

		#< @FunctionNegativeForm

		def ContainsNocharsInScript(pcScript)
			return NOT This.ContainsCharsInScript(pcScript)

		#>

	  #---------------------------#
	 #    CONTAINING LETTERS     #
	#---------------------------#

	def ContainsLetter(pcLetter)

		if Q(pcLetter).IsAChar() and
		   StzCharQ(pcLetter).IsLetter()

		  	return This.ContainsCS( pcLetter, :CS = FALSE )
		else
			return FALSE
		ok

	def ContainsLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()
		
		for i = 1 to nLen
			if This.CharQ(i).IsLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLetters()
			return NOT This.ContainsNumbers()

		#>

	def ContainsTheLetters(pacLetters)
		if Q(pacLetters).IsListOfLetters()
			bResult = TRUE
			oStr = This.UppercaseQ()

			pacLetters = StzListOfCharsQ(pacLetters).Uppercased()
			for cLetter in pacLetters
				if oStr.ContainsNo(cLetter)
					bResult = FALSE
					exit
				ok
			next

			return bResult
		ok

	def ContainsArabicLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsArabicLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoArabicLetters()
			return NOT This.ContainsArabicNumbers()

		#>

	def ContainsLatinLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsLatinLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLatinLetters()
			return NOT This.ContainsLatinNumbers()

		#>

	def ContainsLettersInScript(pcScript)
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsLetterInScript(pcScript)
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLettersInScript(pcScript)
			return NOT This.ContainsNumbers(pcScript)

		#>

	  #==========================#
	 #   SPLITTING THE STRING   #
	#==========================#

	/* GENERAL NOTE:

	There are many forms of splitting in Softanza:
		- splitting AT one or many positions (or one or many substrings)
		- splitting BEFORE one or many positions (or one or many substrings)
		- splitting AFTER one or more positions (or one or many substrings)
		- splitting to n parts (or equal n parts)
		- splitting to parts of n chars (or exactly n chars)
		- splitting at, before, or after a condition is verified on a char,
		  substring, or a char position or substring position

	*/

	def SplitCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Split ( :At = ...) or Split( :Using = ... )

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtSubString, :AtThisSubString ]) 
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtSubStrings, :AtTheseSubStrings ]) 
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			#-- Split ( :Before = ...)

			but Q(pSubStrOrPos).IsBeforeNamedParam()
				return This.SplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			#-- Split ( :After = ...)

			but Q(pSubStrOrPos).IsAfterNamedParam()
				return This.SplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitAtPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitAtSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitAtSections(pSubStrOrPos)
			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.SplitCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Split(pSubStrOrPos)
		return This.SplitCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SplitQ(pSubStrOrPos)
			return This.SplitQR(pSubStrOrPos, :stzList)

		def SplitQR(pSubStrOrPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.Split(pSubStrOrPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Split(pSubStrOrPos) )

			on :stzListOfChars
				return new stzListOfChars( This.Split(pSubStrOrPos) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Split(pSubStrOrPos) )

			on :stzListOfLists
				return new stzListOfLists( This.Split(pSubStrOrPos) )

			on :stzListOfPairs
				return new stzListOfPairs( This.Split(pSubStrOrPos) )

			on :stzListOfObjects
				return new stzListOfObjects( This.Split(pSubStrOrPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def Splitted(pSubStrOrPos)
		return This.Split(pSubStrOrPos)

	  #-----------------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING OR POSITION  #
	#-----------------------------------------------#

	def SplitAtCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitAtPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitAtSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitAtSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitAtCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedAtCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pSubStrOrPos)
		return This.SplitAtCS(pSubStrOrPos, :CaseSensitive = TRUE)

		def SplitAtQ(pSubStrOrPos)
			return This.SplitAtQR(pSubStrOrPos, :stzList)

		def SplitAtQR(pSubStrOrPos, pcReturnType)
			return This.SplitAtCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#-----------------------------------#

	def SplitAtPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtPosition(n)
		acResult = This.Sections(aSections)

		return acResult

	def SplittedAtPosition(n)
		return This.SplitAtPositions(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(anPos)

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ(This.NumberOfChars()).SplitAtPositions(anPos)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplitAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	def SplittedAtPositions(anPos)
		return This.SplitAtPositions(anPos)

		#< @FunctionAlternativeForms

		def SplittedAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplittedAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	  #------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING   #
	#------------------------------------#

	def SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		acResult = QStringListToList( QStringObject().split(pcSubStr, 0, pCaseSensitive) )
		return acResult

	def SplittedAtSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubString(pcSubStr)
		return This.SplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

	def SplittedAtSubString(pcSubStr)
		return This.SplitAtSubString(pcSubStr)

	  #-----------------------------------#
	 #   SPLITTING AT GIVEN SUBSTRINGS   #
	#-----------------------------------#

	def SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		acResult = This.SplitAtPositions(anPos)
		return acResult

		#< @FunctionAlternativeForms

		def SplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	def SplittedAtSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStrings(pacSubStr)
		return This.SplitAtSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SplitAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplitAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		#>

	def SplittedAtSubStrings(pacSubStr)
		return This.SplitAtSubStrings(pacSubStr)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		#>

	  #----------------------------------#
	 #   SPLITTING AT A GIVEN SECTION   #
	#----------------------------------#

	def SplitAtSection(paSection)

		if NOT ( isList(paSection) and Q(paSection).IsPairOfNumbers() )
			StzRaise("Incorrect param type! paSection must be a pair of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSection(paSection)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAtSection(paSection)
		return This.SplitAtSection(paSection)

	  #--------------------------------#
	 #   SPLITTING AT MANY SECTIONS   #
	#--------------------------------#

	def SplitAtSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSections(paSections)
		acResult = This.AntiSections( paSections )

		return acResult

	def SplittedAtSections(paSections)
		return This.SplitAtSections(paSections)

	  #----------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION OR SUBSTRING   #
	#----------------------------------------------------#

	def SplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitBeforePositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitBeforeSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitBeforeSections(pSubStrOrPos)


			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBeforeCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBefore(pSubStrOrPos)
		return This.SplitBeforeCS(pSubStrOrPos, :CaseSensitive = TRUE)

		def SplitBeforeQ(pSubStrOrPos)
			return This.SplitBeforeQR(pSubStrOrPos, :stzList)

		def SplitBeforeQR(pSubStrOrPos, pcReturnType)
			return This.SplitBeforeCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitBeforePosition(n)

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePosition(n)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedBeforePosition(n)
		return This.SplitBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult			

	def SplittedBeforePositions(anPos)
		return This.SplitBeforePositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubString(pcSubStr)
		return This.SplitBeforeSubStringCS(pcSubStr, :CaseSensitive = TRUE)

	def SplittedBeforeSubString(pcSubStr)
		return This.SplitBeforeSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
	def SplittedBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStrings(pacSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION   #
	#--------------------------------------#

	def SplitBeforeSection(paSection)

		if NOT ( isList(paSection) and Q(paSection).IsPairOfNumbers() )
			StzRaise("Incorrect param type! paSection must be a pair of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSection(paSection)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedBeforeSection(paSection)
		return This.SplitBeforeSection(paSection)

	  #------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS   #
	#------------------------------------#

	def SplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedBeforeSections(paSections)
		return This.SplitBeforeSections(paSections)

	  #--------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN POSITION OR SUBSTRING  #
	#--------------------------------------------------#

	def SplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitAfterSections(pSubStrOrPos)


			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitAfterCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedAfterCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAfterCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfter(pSubStrOrPos)
		return This.SplitAfterCS(pSubStrOrPos, :CaseSensitive = TRUE)

		def SplitAfterQ(pSubStrOrPos)
			return This.SplitAfterQR(pSubStrOrPos, :stzList)

		def SplitAfterQR(pSubStrOrPos, pcReturnType)
			return This.SplitAfterCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPosition(n)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterPosition(n)
		return This.SplitAfterPosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterPositions(anPos)
		return This.SplitAfterPositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubString(pcSubStr)
		return This.SplitAfterSubStringCS(pcSubStr, :CaseSensitive = TRUE)

	def SplittedAfterSubString(pcSubStr)
		return This.SplitAfterSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
	def SplittedAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStrings(pacSubStr)

	  #-------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION   #
	#-------------------------------------#

	def SplitAfterSection(paSection)

		if NOT ( isList(paSection) and Q(paSection).IsPairOfNumbers() )
			StzRaise("Incorrect param type! paSection must be a pair of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSection(paSection)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterSection(paSection)
		return This.SplitAfterSection(paSection)

	  #-----------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS   #
	#-----------------------------------#

	def SplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

	def SplittedAfterSections(paSections)
		return This.SplitAfterSections(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#-------------------------------------------------#

	def SplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

	def SplittedBetweenCS(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetween(pBound1, pBound2)
		return This.SplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

	def SplittedBetween(pBound1, pBound2)
		return This.SplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#----------------------------#

	def SplitToNParts(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToNParts(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToNPartsQ(n)
			return This.SplitToNPartsQR(n, :stzList)

		def SplittoNPartsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToNParts(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToNParts(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToNParts(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToNParts(n)
		return This.SplitToNParts(n)

	  #-----------------------------------#
	 #   SPLITTING TO PARTS OF N CHARS   #
	#-----------------------------------#

	def SplitToPartsOfNChars(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfNPositions(n)

		aResult = This.Sections(aSections)

		return aResult

	def SplitToPartsOfExactlyNChars(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfExactlyNPositions(n)

		aResult = This.Sections( aSections )
		return aResult

		def SplitToPartsOfNCharsXT(n)
			return This.SplitToPartsOfExactlyNChars(n)

	  #---------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDTION   #
	#---------------------------------------#

	def SplitW(pcCondition)
		/*
		? StzSplitterQ(1:5).SplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.SplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.SplitAfterW(pcCondition[2])

			ok
		
		else

			return This.SplitAtW(pcCondition)
		ok

	  #------------------------------------#
	 #    SPLITTING AT A GIVEN CONDTION   #
	#------------------------------------#

	def SplitAtW(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.SplitAtSections(aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.SplitAtPositions(anPositions)
		ok

		return aResult

	  #----------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDTION   #
	#----------------------------------------#

	def SplitBeforeW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.SplitBeforePositions(anPositions)

		return aResult

	  #---------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDTION   #
	#---------------------------------------#

	def SplitAfterW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.SplitAfterPositions(anPositions)

		return aResult

	  #----------------------------------------------------------------#
	 #  NTH SUBSTRING AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#----------------------------------------------------------------#
	# Specific function used to simplify code ins stzListOfStrings

	def NthSubstringAfterSplittingStringUsing(n, cSep)
		return This.Split(cSep)[n]

	  #--------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AND RETURNING THE POSITIONS OF THE SPLITTED PARTS  #
	#--------------------------------------------------------------------------#

	def SplitCSZ(pcSep, pCaseSensitive)
		aSplittedZZ = This.SplitCSZZ(pcSep, pCaseSensitive)
		anPos = QR(aSplittedZZ, :stzListOfPairs).FirstItems()
		return anPos

	#-- WITHOUT CASESENSITIVITY

	def SplitZ(pcSep)
		return This.SplitCSZ(pcSep, :CaseSensitive = TRUE)

	  #------------------------------------------------------#
	 #   SPLITTING THE STRING AND RETURNING THE POSITIONS   #
	#   (AS SECTIONS) OF THE SPLITTED PARTS                #
	#-----------------------------------------------------#

	def SplitCSZZ(pcSep, pCaseSensitive)

		if isList(pcSep)
			oaSep = new stzList(pcSep)

			if oaSep.IsAtOrUsingNamedParam()

			but oaSep.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ])

			but oaSep.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ])

			but oaSep.IsOneOfTheseNamedParams([ :AtSubString, :AtThisSubString ])

			but oaSep.IsOneOfTheseNamedParams([ :AtSubStrings, :AtTheseSubStrings ])

			but oaSep.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ])

			but oaSep.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ])

			but oaSep.IsBeforeNamedParam()

			but oaSep.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition])

			but oaSep.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ])

			but oaSep.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ])

			but oaSep.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ])

			but oaSep.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ])

			but oaSep.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ])

			but oaSep.IsAfterNamedParam()

			but oaSep.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ])

			but oaSep.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ])

			but oaSep.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ])

			but oaSep.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ])

			but oaSep.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ])

			but oaSep.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ])

			but oaSep.IsListOfStrings()

			butoaSep.IsListOfNumbers()

			ok
		else
			if isString(pcSep)

			but isNumber(pcSep)

			ok
		ok


	#-- WITHOUT CASESENSITIVITY

	def SplitZZ(pcSep)
		return This.SplitCSZZ(pcSep, :CaseSensitive = TRUE)

	  #======================================================#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTIONNER   #
	#======================================================#

	/* Note:

	This method analyzes the string, by sequentially partitioning
	its content, using a given "partition expression", a "partionner",
	for short. Hence, it serves in answering this kind of question:

	How is the string composed in term of some char criteria
	(beeing, for example, lowercase or uppercase, or left-oriented
	or right-oriented).

	The partionner is what we should provide to the method in
	a param as a conditional code containing the @char keyword.

	For example:

	o1 = new stzString("TUNIS gafsa NABEUL beja")
	? o1.Parts(:Using = 'Q(@char).CharCase()' ) # NOTE: Parts() is the simple
						    # form of PartsAsSubstrings()

	Uses the CharCase() method in stzChar as a partionner.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or NULL, then the classification done will return:

	[
		"TUNIS" = :Uppercase,
		" " = NULL,
		"gafsa" = :Lowercase,
		" " = NULL,
		"NABEUL" = :Uppercase,
		" " = NULL,
		"beja" = :Lowercase
	]

	*/

	def PartsAsSubstrings(pcPartionner)
		/*
		Example:

		o1 = new stzString("Abc285XY&من")

		? o1.PartsAsSubstrings( :Using = 'Q(@char).IsLetter()' )
		--> Gives:
		[ "Abc" = TRUE, "285" = FALSE, "XY" = TRUE, "&" = FALSE, "من" = TRUE ]

		? o1.PartsAsSubstrings( :Using = 'Q(@char).Orientation()' )
		--> Gives:
		[ "Abc285XY&" = :LeftToRight, "من" = :RightToLeft ]

		? o1.PartsAsSubstrings( :Using = 'Q(@char).IsUppercase()' )
		--> Gives:
		[ "A" = TRUE, "bc285" = FALSE, "XY" = TRUE, "&من" = FALSE ]

		? o1.PartsAsSubstrings(:Using = 'Q(@char).CharCase()' )
		--> Gives:
		[ "A" = :Uppercase, "bc" = :Lowercase, "285" = NULL, "XY" = :Uppercase, "&من" = NULL ]

		*/


		if isList(pcPartionner) and
		   StzListQ(pcPartionner).IsOneOfTheseNamedParams([ :Using, :By, :With ])

			pcPartionner = pcPartionner[2]

			if NOT isString(pcPartionner)
				stzRaise("Incorrect param type!")
			ok
		ok

		if This.NumberOfChars() = 0
			return []
		ok

		cCode = StzStringQ(pcPartionner).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				ReplaceCSQ("@item", "@char", :CaseSensitive = FALSE).
				Content()

		cCode = "cPartionner = ( '' + " + cCode + " )"

		if This.NumberOfChars() = 1
			@char = This.FirstChar()
			eval(cCode)
			aResult = [ @char, cPartionner ]

			return aResult
		ok

		cPart = This.FirstChar()
		aParts = []

		@char = This.FirstChar()
		@i = 1
		eval(cCode)
		cPrevious = cPartionner

		for @i = 2 to This.NumberOfChars()

			cCurrentChar = This.Char(@i)
			oCurrentChar = new stzChar(cCurrentChar)
			@char = cCurrentChar

			eval(cCode)
			cCurrent = cPartionner

			oPreviousChar = new stzChar(This.Char(@i-1))
			@char = oPreviousChar.Content()
			eval(cCode)
			cPrevious = cPartionner

			if cCurrent = cPrevious
				cPart += cCurrentChar

			else
				aParts + [ cPart, cPrevious ]
				cPart = cCurrentChar
			ok

		end

		oLastChar = This.LastCharQ()
		@char = oLastChar.Content()
		eval(cCode)
		aParts + [ cPart, cPartionner ]

		return aParts

		#< @FunctionFluentForm

		def PartsAsSubstringsQ(pcPractionner)
			return PartsAsSubstringsQ(pcPractionner, :stzList)

		def PartsAsSubstringsQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSubstrings(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSubStrings(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForm

		def Parts(pcPartionner)
			return This.PartsAsSubstrings(pcPartionner)

			def PartsQ(pcPartionner)
				return new stzList( This.Parts(pcPartionner) )

		#>

	def PartsAsSections(pcPartionner)
		/*
		o1 = new stzString("TUNIS1250XT")
		? o1.PartsAsSections( :Using = :IsNumber )
		--> Gives
			[
				[ [ 1,  5], FALSE ],
				[ [ 6,  9], TRUE  ],
				[ [10, 11], FALSE ]
			]
		*/

		aParts = This.PartsAsSubstrings(pcPartionner)
	
		aResult = []
		n1 = 1
		n2 = 1
		aSection = []
	
		i = 0
		for aPair in aParts
			i++
			cPart = aPair[1]
			nLenPart = StzStringQ(cPart).NumberOfChars()

			n2 = n1 + nLenPart - 1
			aSection = [n1, n2]
	
			aResult + [ aSection, aPair[2] ]
			n1 += nLenPart
	
		next
	
		return aResult

		def PartsAsSectionsQ(pcPractionner)
			return PartsAsSectionsQ(pcPractionner, :stzList)

		def PartsAsSectionsQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSections(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSections(pcPartionner) )

			on :stzHashList@C
				return new stzHashList( This.PartsAsSectionsSF(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off

	def PartsAsSectionsClassified(pcPartionner)
		oPartsAsSections = This.PartsAsSectionsQ(:stzHashlList)
		aResult = oPartsAsSections.Classify(pcPartionner)

		return aResult

		def PartsAsSectionsClassifiedQ(pcPractionner)
			return PartsAsSectionsClassifiedQR(pcPractionner, :stzList)

		def PartsAsSectionsClassifiedQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSectionsClassified(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSectionsClassified(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off

	#--

	def PartsAsSubstringsAndSections(pcPartionner)
		aSubstrings = This.PartsAsSubstrings(pcPartionner)
		aSections   = This.PartsAsSections(pcPartionner)

		aResult = []

		for i = 1 to len(aSubstrings)
			aResult + [ aSubstrings[i][1], aSections[i][1], aSections[i][2] ]
		next

		return aResult

	def PartsAsSectionsAndSubstrings(pcPartionner)
		aSubstrings = This.PartsAsSubstrings(pcPartionner)
		aSections   = This.PartsAsSections(pcPartionner)

		aResult = []

		for i = 1 to len(aSubstrings)
			aResult + [ aSections[i][1], aSubstrings[i][1], aSubstrings[i][2] ]
		next

		return aResult

	  #------------------------------------#
	 #     UNIQUE PARTS OF THE STRING     #
	#------------------------------------#

	def UniqueParts(pcPartionner)
		aResult = This.PartsQ(pcPartionner).DuplicatesRemoved()
		return aResult

		#< @FunctionFluentForms

		def UniquePartsQ(pcPartionner)
			return This.UniquePartsQR(pcPartionner, :stzList)
	
		def UniquePartsQR(pcPartionner, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueParts(pcPartionner))

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueParts(pcPartionner))

			other
				stzRaise("Unsupported return type!")
			off


		#>

		#< @FunctionAlternativeForm

		def PartsU(pcPartitionner)
			return This.UniqueParts(pcPartionner)

			def PartsUQ(pcPartionner)
				return This.UniquePartsQ(pcPartionner)

			def PartsUQR(pcPartionner, pcReturnType)
				return This.UniquePartsQR(pcPartionner, pcReturnType)

		def PartsWithoutDuplication(pcPartitionner)
			return This.UniqueParts(pcPartionner)

			def PartsWithoutDuplicationQ(pcPartionner)
				return This.UniquePartsQ(pcPartionner)

			def PartsWithoutDuplicationQR(pcPartionner, pcReturnType)
				return This.UniquePartsQR(pcPartionner, pcReturnType)

		#>

	  #---------------------------------------#
	 #     PARTS OF THE STRING CLASSIFIED    #
	#---------------------------------------#

	def PartsClassified(pcClassifier)
		if isList(pcClassifier) and Q(pcClassifier).IsUsingNamedParam()
			pcClassifier = pcClassifier[2]
		ok

		if NOT isString(pcClassifier)
			stzRaise("Incorrect param type! pcClassifier must be a string.")
		ok

		aResult = This.UniquePartsQ(pcClassifier).
				ToStzHashList().
				Classify()

		return aResult

		def Classified(pcClassifier)
			return This.PartsClassified()

		def Classify(pcClassifier)
			return This.PartsClassified()

	  #-------------------------------------------------------------#
	 #  GETTINING THE PARTS OF STRING VERIFYING A GIVEN CONDITION  # TODO
	#-------------------------------------------------------------#

	def PartsW(pcCondition)
		/* EXAMPLE

		o1 = new stzString("Приве́т नमस्ते שָׁלוֹם")
		? o1.PartsW('{
			Q(@part).Script() = :Cyrillic
		}')
		#--> [ "Приве", "т" ]

		*/

		StzRaise("Function unavailable yet!")
		
	  #=============================#
	 #     DIVIDING THE STRING     #
	#=============================#

	def Divide(paByDividor)
		if isList(paByDividor) and Q(paByDividor).IsByNamedParam()
			paByDividor = paByDividor[2]
		ok

		return This.DivideBy(paDividor)

	def DivideBy(pDividor)
		
		switch ring_type(pDividor)

		on "NUMBER"
			This.SplitToNParts(n)

		on "STRING"
			n = This.NumberOfOccurrence(pDividor)
			oTempStr = StzStringQ(pDividor) * n
			
			if oTempStr.IsEqualTo(This.String())
				return n
			else
				oTempStr = ( This.Copy() - oTempStr.Content() )
				nLen = oTempStr.NumberOfChars()
				if oTempStr.IsEqualTo( This.Section(1, n) )
					nResult = n + nLen / StzStringQ(pDividor).NumberOfChars()
					return nResult
				else
					return n
				ok
			ok
		off

	  #=====================================#
	 #   SORTING THE CHARS OF THE STRING   #
	#=====================================#

	def CharsSortingOrder()
		cResult = :Unsorted

		if This.CharsAreSorted()
			if This.CharsAreSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

		def SortingOrder()
			return This.CharsSortingOrder()
			

	def HasSameCharsSortingOrderAs(pcOtherStr)

		oTemp = new stzString(pcOtherStr)
		if oTemp.CharsSortingOrder() = This.CharsSortingOrder()
			return TRUE
		else
			return FALSE
		ok

		def HasSameCharsOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

		def HasSameSortingOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

	def CharsAreSorted()
		if This.CharsAreSortedInAscending() or
		   This.CharsAreSortedInDescending()
			return TRUE
		else
			return FALSE
		ok

		def IsSorted()
			return This.CharsAreSorted()

	def CharsAreSortedInAscending()
		/*
		The idea is to sort a copy of the string in ascending order
		and then compare the copy to the original string...
		If they are identical, then the string is sorted in ascending order!
		*/

		oSortedInAscending = This.Copy().SortCharsInAscendingQ()
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if NOT AreEqual([ oSortedInAscending[i] , This.Char(i) ])
				return FALSE
			ok
		next

		return TRUE

		def IsSortedInAscending()
			return This.CharsAreSortedInAscending()

	def CharsAreSortedInDescending()
		/*
		The idea is to reverse the string, and check if its reversed
		copy is sorted in ASCENDING order. If so, then the string itself
		is actually sorted in DESCENDING order!
		*/
		oTemp = new stzString( This.CharsReversed() )
		if oTemp.CharsAreSortedInAscending()
			return TRUE
		else
			return FALSE
		ok

		def IsSortedInDescending()
			return This.CharsAreSortedInDescending()

	def SortCharsInAscending()
		
		aResult = This.CharsQ().SortInAscendingQ().ToStzListOfStrings().Concatenated()

		This.Update( aResult )

		def SortCharsInAscendingQ()
			This.SortCharsInAscending()
			return This

		def SortInAscending()
			This.SortCharsInAscending()

			def SortInAscendingQ()
				This.SortInAscending()
				return This
			
	def StringWithCharsSortedInAscending()
		cResult = This.Copy().SortCharsInAscendingQ().Content()
		return cResult

		def SortedInAscending()
			return This.StringWithCharsSortedInAscending()

		def Sorted()
			return This.SortedInAscending()

	def SortCharsInDescending()
		aReversed = ListReverse( This.SortCharsInAscendingQ().Chars() )
		cResult = StzListOfStringsQ(aReversed).Concatenated()

		This.Update( cResult )

		def SortCharsInDescendingQ()
			This.SortCharsInDescending()
			return This

		def SortInDescending()
			This.SortCharsInDescending()

			def SortInDescendingQ()
				This.SortInDescending()
				return This
			
	def StringWithCharsSortedInDescending()
		cResult = This.Copy().SortCharsInDescendingQ().Content()
		return cResult

		def SortedInDescending()
			return This.StringWithCharsSortedInDescending()

	  #============================================================#
	 #     COMPARING THE STRING TO OTHER STRINGS USING UNICODE    #
	#============================================================#
	# TODO: add Casesensitivity support

	// Compares the main string with an other string (base on the unicode code table)
	// --> Use this for internal string comparisons and sorting
	// --> For lists presented to the user, use SystemLocaleCompare()

	def UnicodeCompareWithCS(pcOtherStr, pCaseSensitive)
		#< QtBased | Uses QString.compare() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nQtResult = @oQString.compare(pcOtherStr, pCaseSensitive)

	
		if  nQtResult = 0
			return :Equal	# Be careful :Equal is "equal" and not "Equal" with capital "E"

		but nQtResult < 0
			return :Less

		but  nQtResult > 0
			return :Greater
		ok
		/*
		Returns :Equal, :Less, or :Greater:

		:Equal   --> The 2 strings are equal
		:Less    --> The main string is "less" then the substring
		:Greater --> The main string is "greater" then the substring
		
		"less" and "greater" should be understood at the sense
		provided to them by Qt. Read this:
	
		https://doc.qt.io/qt-5/qstring.html#comparing-strings
		*/

	def UnicodeCompareWith(pcOtherStr)
		return This.CompareWithCS(pcOtherStr, :CaseSensitive = TRUE)

	def UnicodeCompareWithInSystemLocale(pcOtherStr)
		nQtResult = @oQString.localeAwareCompare(pcOtherStr)

		if nQtResult = 0
			return :equal
		but nQtResult < 0
			return :less
		but nQtResult > 0
			return :greater
		ok
		/*
		From Qt documentation:
	
		The comparison is performed in a locale- and also
		platform-dependent manner. Use this function to present
		sorted lists of strings to the user.

		NOTE:
		This works only for the current system locale.

		To compare for a defined locale, softanza should rely on
		the QCollator class in RingQt (which is not implemented yet)

		--> TODO: Add QCollator class to RingQt and make CompareWithInLocale()
		*/

	def UnicodeCompareWithInLocale(pcOtherStr, pLocale) # TODO
		// Needs the implementation of QCollator class in RingQt (read comment
		// in SystemLocaleCompareWith() methof above

	def IsUnicodeEqualTo(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Equal

		def IsUnicodeEqualWith(pcOtherStr)
			return This.IsUnicodeEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsUnicodeDifferentFrom(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		#>

	def IsUnicodeEqualToInLocale(pcOtherStr, pLocale)
		return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Equal

		def IsUnicodeDifferentFromInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

		def IsNotUnicodeEqualToInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

	def IsUnicodeLessThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Less

		def IsUnicodeLessThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Less
	
	def IsUnicodeGreaterThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Greater

		def IsUnicodeGreaterThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Greater

	  #-----------------------------------------------#
	 #     COMPARING THE STRING TO OTHER STRINGS     #
	#===============================================#

	def IsEqualToCS(pcOtherStr, pCaseSensitive)

		if NOT isString(pcOtherStr)
			return FALSE
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		if pCaseSensitive = TRUE
			# We do a double-check for potential performance gain
			if This.NumberOfChars() != Q(pcOtherStr).NumberOfChars()
				return FALSE

			else
				return This.String() = pcOtherStr
			ok

		else // pCaseSensitive = FALSE
			return This.Lowercased() = StzStringQ(pcOtherStr).Lowercased()
		ok
		
		def IsEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionNegativeForm

		def IsNotEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(pcOtherStr)
		return This.IsEqualToCS(pcOtherStr, :CaseSensitive = TRUE)

		def IsEqualWith(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsNotEqualTo(pcOtherStr)
			return NOT This.IsEqualTo(pcOtherStr)

		def IsNotEqualWith(pcOtherStr)
			return NOT This.IsEqualTo(pcOtherStr)

		def IsDifferentFrom(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)
	
		def IsDifferentTo(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)

		def IsDifferentOf(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS STRICTLY EQUAL TO ANOTHER STRING  #
	#--------------------------------------------------------------#

	def IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
		if This.IsEqualToCS(pcOtherStr, pCaseSensitive) and
		   This.HasSameSortingOrderAs(pcOtherStr)

			return TRUE

		else
			return FALSE
		ok

		def IsStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsStrictlyDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(pcOtherStr)
		return This.IsStrictlyEqualToCS(pcOtherStr, :CaseSensitive = TRUE)

		def IsStrictlyEqualWith(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualTo(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsNotStrictlyEqualWith(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentFrom(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)
	
		def IsStrictlyDifferentTo(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentOf(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS EQUAL TO ONE OF THE PROVIDED STRINGS  #
	#------------------------------------------------------------------#

	def IsEqualToOneOfTheseCS(pacOtherStr, pCaseSensitive)
		bResult = TRUE
		for str in pacOtherStr
			if NOT This.IsEqualToCS(str, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def IsEqualToOneOfThese(pacOtherStr)
		return This.IsEqualToOneOfTheseCS(pacOtherStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS SMALLER THAN THE PROVIDED STRING  #
	#--------------------------------------------------------------#

	def IsSmaller(pcOtherStr)
		if isList(pcOtherStr) and Q(pcOtherStr).IsThanNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		return This.IsIncludedIn(pcOtherStr)

		#< @FunctionAlternativeForms

		def IsSmallerThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def IsLessThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		#>

	def IsLarger(pcOtherStr)
		return This.Contains(pcOtherStr)

		#< @FunctionAlternativeForms

		def IsLargerThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		#>

	def IsQuietEqualTo(pcOtherStr)
		# WARNING: Performance issue is caused by DiacriticsRemoved()

		cThisString = This.LowercaseQ().ToStzText().DiacriticsRemoved()

		cOtherString = StzStringQ(pcOtherStr).LowercaseQ().ToStzText().DiacriticsRemoved()

		if cThisString = cOtherString
			return TRUE
		ok

		nDif = abs(This.NumberOfChars() - StzStringQ(pcOtherStr).NumberOfChars())
		n = nDif / This.NumberOfChars()
		
		if n <= QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return TRUE
		ok

		return FALSE

	  #-------------------------------------------------#
	 #     STRING IS A MULTIPLE OF AN OTHER STRING     #
	#-------------------------------------------------#

	def IsMultipleOfCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		n = This.NumberOfOccurrenceCS( pcSubStr, pCaseSensitive )

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsMultipleOf(pcSubStr)
		return This.IsMultipleOfCS(pcSubStr, :CaseSensitive = TRUE)

	def IsNTimesMultipleOfCS(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsNTimesMultipleOf(n, pcSubStr)
		return This.IsNTimesMultipleOfCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #------------------------------------------------#
	 #     STRING IS A SPLITTER OF AN OTHER STRING    #
	#------------------------------------------------#

	def IsSplitterOfCS(pcOtherStr, pCaseSensitive)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		bResult = StzStringQ(pcOtherStr).NumberOfOccurrenceCS( This.String(), pCaseSensitive ) > 1
		return bResult

	def IsSplitterOf(pcOtherStr)
		bResult = This.IsSplitterOfCS(pcOtherStr, :CaseSensitive = TRUE)
		return bResult

	  #---------------------------------------------------#
	 #     STRING IS SPLITTABLE USING AN OTHER STRING    #
	#---------------------------------------------------#

	def IsSplittableUsingCS(pcSubStr)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		return Q(pcSubStr).IsSplitterOfCS( This.String(), pCaseSensitive )

	def IsSplittableUsing(pcSubStr)
		return This.IsSplittableUsingCS(pcSubStr, pCaseSensitive)

	  #==============================#
	 #    REMOVING ALL SUBSTRINGS   # 
	#==============================#

	def RemoveCS(pSubStr, pCaseSensitive)
		This.ReplaceCS(pSubstr, "", pCaseSensitive)

		def RemoveCSQ(pSubStr, pCaseSensitive)
			This.RemoveCS(pSubStr, pCaseSensitive)
			return This

	def RemovedCS(pSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveCSQ(pSubStr, pCaseSensitive).Content()
		return cResult
		
	#-- WITHOUT CASESENSITIVITY

	def Remove(pcSubStr) # replace with @oQString.remove() when added to RingQt
		This.ReplaceAll(pcSubStr , "")

		def RemoveQ(pcSubStr)
			This.Remove(pcSubStr)
			return This
	
	def Removed(pSubStr)
		cResult = This.Copy().RemoveCSQ(pSubStr).Content()
		return cResult

	  #----------------------------------------------#
	 #   REMOVING SOME OCCURRENCES OF A SUBSTRING   #
	#----------------------------------------------#

	def RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("ring __ ring __ ring __ ring")
		o1.RemoveOccurrences([2, 3], "ring")
		? o1.Content() #--> "ring __  __  __ ring"
		*/

		anPos = This.FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtPositionsCS(anPos, pcSubStr, pCaseSensitive)

		def RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This

		def RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

			def RemoveTheseOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
				This.RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

	def TheseOccurrencesRemovedCS(panOccurr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveOccurrences(panOccurr, pcSubStr)
		This.RemoveOccurrencesCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		def RemoveOccurrencesQ(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)
			return This

		def RemoveTheseOccurrences(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)

			def RemoveTheseOccurrencesQ(panOccurr, pcSubStr)
				This.RemoveTheseOccurrences(panOccurr, pcSubStr)

	def TheseOccurrencesRemoved(panOccurr, pcSubStr)
		return This.Copy().RemoveOccurrencesQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	  #-------------------------------------------------#
	 #   REMOVING FIRST N OCCURRENCES OF A SUBSTRING   #
	#-------------------------------------------------#

	def RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.RemoveTheseOccurrencesCS( 1 : n, pcSubStr, pCaseSensitive )

		def RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstNOccurrences(n, pcSubStr)
		This.RemoveFirstNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemoved(n, pcSubStr)
			return This.FirstNOccurrencesRemoved(n, pcSubStr)

	  #------------------------------------------------#
	 #   REMOVING LAST N OCCURRENCES OF A SUBSTRING   #
	#------------------------------------------------#

	def RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		nNumberOfOccurr = This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
		n1 = nNumberOfOccurr - n + 1
		This.RemoveTheseOccurrencesCS( n1 : nNumberOfOccurr , pcSubStr, pCaseSensitive )

		def RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastNOccurrences(n, pcSubStr)
		This.RemoveLastNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemoved(n, pcSubStr)
			return This.LastNOccurrencesRemoved(n, pcSubStr)

	  #----------------------------------------------#
	 #   REMOVING MANY SUBSTRING AT THE SAME TIME   #
	#----------------------------------------------#

	def RemoveManyCS(pacSubStr, pCaseSensitive)
		for cSubstr in paCsubstr
			This.RemoveAllCS(cSubstr, pCaseSensitive)
		next

		def RemoveManyCSQ(pacSubStr, pCaseSensitive, pCaseSensitive)
			This.RemoveManyCS(pacSubStr, pCaseSensitive)
			return This

		def RemoveAllOfTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseCSQ(pacSubStr, pCaseSensitive)
				This.RemoveAllOfTheseCS(pacSubstr, pCaseSensitive)
				return This

		def RemoveManySubstringsCS(pcSubStr, pCaseSensitive)
			This.RemoveAllCS(pcSubStr, pCaseSensitive)

			def RemoveManySubstringsCSQ(pSubStr, pCaseSensitive)
				This.RemoveManySubstringsCS(pSubStr, pCaseSensitive)
				return This

	def ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)
		return This.Copy().RemoveManySubstringsCS(pacSubStr, pCaseSensitive).Content()

		def SubstringsRemovedCS(pacSubStr, pCaseSensitive)
			return This. ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)

	#-- CASEèSENSITIVE

	def RemoveMany(pacSubStr)
		for cSubstr in paCsubstr
			This.RemoveAll(cSubstr)
		next

		def RemoveManyQ(pacSubStr)
			This.RemoveMany(pacSubstr)
			return This

		def RemoveAllOfThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseQ(pacSubstr)
				This.RemoveAllOfThese(pacSubstr)
				return This

		def RemoveManySubstrings(pcSubStr)
			This.RemoveMany(pacSubStr)

			def RemoveManySubstringsQ(pSubStr)
				This.RemoveManySubstrings(pSubStr, pCaseSensitive)
				return This

	def ManySubstringsRemoved(pacSubStr)
		return This.Copy().RemoveManySubstrings(pacSubStr).Content()

		def SubstringsRemoved(pacSubStr)
			return This. ManySubstringsRemoved(pacSubStr)

	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This.InBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetween(pcSubStr,pcBound1, pcBound2)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, :CaseSensitive = TRUE)
		
		#< @FunctionFluentForm

		def RemoveBetweenQ(pcSubStr,pcBound1, pcBound2)
			This.RemoveBetween(pcSubStr,pcBound1, pcBound2)
			return This

		#>

	def InBetweenRemoved(pcSubStr, pcBound1, pcBound2)
		return This.InBetweenRemovedCS(pcSubStr, pcBound1, pcBound2, :CaseSensitiVE = TRUE)

		def SubStringInBetweenRemoved(pcSubStr,pcBound1, pcBound2)
			return This.InBetweenRemoved(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------------------------------------#
	 #  REMOVING A SUBSTRING BETWEEN TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindBetweenAsSectionsSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)
	
		#< @FunctionFluentForm

		def RemoveBetweenSCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	def InBetweenRemovedSCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenSCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInBetweenRemovedSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.InBetweenRemovedSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def RemoveBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)
	
		#< @FunctionFluentForm

		def RemoveBetweenSQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveBetweenS(pcSubStr, pcBound1, pcBound2)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.RemoveBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)

		#>

	def InBetweenRemovedS(pcSubStr,pcBound1, pcBound2)
		cResult = This.Copy().RemoveBetweenSQ(pcSubStr,pcBound1, pcBound2).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInBetweenRemovedS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.InBetweenRemovedS(pcSubStr, pcBound1, pcBound2, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#-----------------------------------------------------------------------------------#
	# NOTE: encolsing substrings (bounds) are also removed

	def RemoveBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenIBCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenIBCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This.InBetweenRemovedIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetweenIB(pcSubStr, pcBound1, pcBound2)
		return This.RemoveBetweenIBCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveBetweenIBQ(pcSubStr,pcBound1, pcBound2)
			This.RemoveBetweenIB(pcSubStr,pcBound1, pcBound2)
			return This

		#>

	def InBetweenRemovedIB(pcSubStr, pcBound1, pcBound2)
		return This.InBetweenRemovedIBCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def SubStringInBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)
			return This.InBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)

	  #----------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#----------------------------------------------------------------------------------#

	def RemoveBetweenIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenIBSCSQ(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.RemoveBetweenIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenIBSCSQ(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.InBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetweenIBS(pcSubStr, pcBound1, pnStartingAt, pcBound2)
		return This.RemoveSubStringBetweenIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveBetweenIBSQ(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.RemoveBetweenIBS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			return This

		#>

	def InBetweenRemovedIBS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.InBetweenRemovedIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		def SubStringInBetweenRemovedIBS(pcSubStr,pcBound1, pcBound2, pnStartingAt)
			return This.InBetweenRemovedIBS(pcSubStr,pcBound1, pcBound2, pnStartingAt)

	  #====================================#
	 #  REMOVING A SUBSTRING -- EXTENDED  #
	#====================================#

	def RemoveXTCS(p1, p2, pCaseSensitive)

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").RemoveXT("♥", [])
		if isString(p1) and

			( (isList(p2)   and len(p2) = 0) or
			  (isString(p2) and p2 = "") or
			  (isNumber(p2) and p2 = 0) )

			This.RemoveCS(p1, pCaseSensitive)
			return

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").RemoveXT([], "♥")
		but isString(p2) and

			( (isList(p1)   and len(p1) = 0) or
			  (isString(p1) and p1 = "") or
			  (isNumber(p1) and p1 = 0) )

			This.RemoveCS(p2, pCaseSensitive)
			return

		# Q("/♥\__/♥\__/♥♥\__/♥\__").RemoveXT(:Nth = 4, "♥")
		but isString(p2) and

		    ( isList(p1) and len(p1) = 2 and
		      isString(p1[1]) and p1[1] = :Nth and
		      isNumber(p1[2]) )

			This.RemoveNthCS(p1[2], p2, pCaseSensitive)
		ok


		if isList(p1) and Q(p1).IsEachNamedParam()
			p1 = p1[2]
		ok


		if isList(p2)
			oP2 = new stzList(p2)

			if oP2.IsAtNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				but isList(p2) and Q(p2).IsListOfNumbers()
					This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number or a list of numbers.")
				ok
					
			# Q("^^♥^^").RemoveXT( "♥", :AtPosition = 4)
			but oP2.IsAtPositionNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number.")
				ok
	
			#-- Removing at many positions
			# TODO: Add example here for better readability
			but oP2.IsAtPositionsNamedParam()
				p2 = p2[2]
	
				if NOT ( isList(p2) and Q(p2).IsListOfNumbers() )
					stzRaise("Incorrect param type! p2 must be a list of numbers.")
				ok
	
				This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

			# Removing from, Nth from, First from, Last from
			# TODO: Add examples here for better readability
			but oP2.IsFromNamedParam()
				p2 = p2[2]

				# Removing from

				if isString(p1)
					cNewSubStr =  ( Q(p2) - p1 ).Content()
	
				# Removing Nth from

				but isList(p1) and Q(p1).IsNthNamedParam()
					n = p1[2][1]
					p1 = p1[2][2]

					cNewSubStr = Q(p2).
							RemoveNthCSQ(n, p1, pCaseSensitive).
							Content()

				# Removing first from

				but isList(p1) and Q(p1).IsFirstNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveFirstCSQ(p1, pCaseSensitive).
							Content()

				but isList(p1) and Q(p1).IslastNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveLastCSQ(p1, pCaseSensitive).
							Content()

				ok

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing after
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :After, :AfterEach  ])

				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing after nth
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterNth ])
				n = p2[2][1]
				p2 = p2[2][2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after first
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing atfer last
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing Before
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Before, :BeforeEach  ])

				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before nth
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeNth ])
				n = p2[2][1]
				p2 = p1 + p2[2][2]
				
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing before first
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeFirst, :ToFirst ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before last
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeLast, :ToLast ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing around
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				p2 = p2[2]

				if isList(p1) and Q(p1).IsPairOfStrings()

					This.ReplaceCS(
						(p1[1] + p2 + p1[2]),
						p2,
						pCaseSensitive)

				else	
					This.ReplaceCS(
						(p1 + p2 + p1),
						p2,
						pCaseSensitive)
				ok

			# Removing around nth
			# TODO: Add example here for better readability
			but oP2.IsAroundNthNamedParam()
				
				n = p2[2][1]
				p2 = p2[2][2]

				if isString(n)
					if n = :First
						n = 1

					but n = :Last
						n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
					ok
				ok

				if NOT isNumber(n)
					StzRaise("Incorrect param! n must be a number.")
				ok

				if NOT isString(p2)
					StzRaise("Incorrect param! p2 must be a string.")
				ok

				# Forcing p1 to be a pair of lists

				if isString(p1)
					aTemp = []
					aTemp + p1 + p1
					p1 = aTemp	
				ok

				if NOT isList(p1) and Q(p1).ISPairOfStrings()
					StzRaise("Incorrect param type! p1 must be a string or a pair of strings.")
				ok

				# Finding the section of the nth substring

				anSection = This.FindNthAsSection(n, p2)
				
				n1 = anSection[1] - Q(p1[1]).NumberOfChars()
				n2 = anSection[2] + Q(p1[2]).NumberOfChars()
				
				# If the substring is really bounded by the substrings to remove
				# then we make the necessary to remove them from the string

				if This.Section(n1, anSection[1] - 1) = p1[1] and
				   This.Section(anSection[2] + 1, n2) = p1[2]
				
					This.ReplaceSection(n1, n2, p2)
				ok

				# Otherwise, we do nothing.

			# Removing around first
			# TODO: Add example for better readability
			but oP2.IsAroundFirstNamedParam()
				RemoveXT(p1, :AroundNth = [1, p2[2]])

			# Removing around last

			but oP2.IsAroundLastNamedParam()
				RemoveXT(p1, :AroundNth = [:Last, p2[2]])

			#-- Removing between

			# Q("__/\/\__/♥\__").RemoveXT("♥", :Between = ["/","\"])
			# Q("__/\/\__/♥\__").RemoveXT("♥", :BetweenIB = ["/","\"])
			but oP2.IsOneOfTheseNamedParams([
				:Between, :BetweenIB, :BetweenS, :BetweenIBS ])

				cBetween = p2[1]
				p2  = p2[2]

				if isList(p2) and len(p2) = 2 and
				   isList(p2[2]) and p2[2][1] = :And

					p2[2] = p2[2][2]
				ok

				if NOT ( isList(p2) and Q(p2).IsPairOfStrings() )
					stzRaise("Incorrect param type! p2 must be a pair of strings.")
				ok

				if isString(p1) and p1 != ""
					if cBetween = :Between
						This.RemoveBetweenCS(p1, p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveBetweenIBCS(p1, p2[1], p2[2], pCaseSensitive)
		
					ok

				but (isList(p1) and len(p1) = 0) or
				    (isString(p1) and p1 = "") or
				    (isNumber(p1) and p1 = 0)

					if cBetween = :Between
						This.RemoveAnyBetweenCS(p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveAnyBetweenIBCS(p2[1], p2[2], pCaseSensitive)
		
					ok
	
				ok

	
			# Q("__/\/\__^^♥^^__").RemoveXT("♥", :BoundedBy = "^^")
			# Q("__/\/\__^^♥^^__").RemoveXT("♥", :BoundedByIB = "^^")
			but oP2.IsBoundedByNamedParam() or
			    oP2.IsBoundedByIBNamedParam()

				cBounded = p2[1]

				cBound1 = ""
				cBound2 = ""

				if isString(p2[2])
					cBound1 = p2[2]
					cBound2 = p2[2]

				but isList(p2[2]) and Q(p2[2]).IsPairOfStrings()
					cBound1 = p2[2][1]
					cBound2 = p2[2][2]

				but isList(p2[2]) and len(p2[2]) = 2 and
				    isString(p2[2][1]) and
				    isList(p2[2][2]) and Q(p2[2][2]).IsAndNamedParam()

					cBound1 = p2[2][1]
					cBound2 = p2[2][2][2]

				ok

				if cBounded = :BoundedBy
					This.RemoveXTCS( p1, :Between = [ cBound1, cBound2 ], pCaseSensitive)

				but cBounded = :BoundedByIB
					This.RemoveXTCS( p1, :BetweenIB = [ cBound1, cBound2 ], pCaseSensitive)

				ok

			ok
		ok

		def RemoveXTCSQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.RemoveXTCS(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def RemovedXTCS(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveXTCSQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveXT(pcNewSubStr, pcSubStr)
		This.RemoveXTCSQ(pcNewSubStr, pcSubStr, :CaseSensitive = TRUE)

		def RemoveXTQ(pcNewSubStr, pcSubStr)
			This.RemoveXT(pcNewSubStr, pcSubStr)
			return This

	def RemovedXT(pcNewSubStr, pcSubStr)
		return This.Copy().RemoveXTQ(pcNewSubStr, pcSubStr).Content()

	  #---------------------------------------#
	 #   REMOVING CHAR AT A GIVEN POSITION   #
	#---------------------------------------#

	def RemoveCharAtPosition(n)
		This.ReplaceNthChar(n, "")

		def RemoveCharAtPositionQ(n)
			This.RemoveCharAtPosition(n)
			return This

		def RemoveCharAt(n)
			This.RemoveCharAtPosition(n)

			def RemoveCharAtQ(n)
				This.RemoveCharAt(n)
				return This

		def RemoveNthChar(n)
			This.RemoveCharAtPosition(n)

			def RemoveNthCharQ(n)
				This.RemoveNthChar(n)
				return This

	def CharAtPositionNRemoved(n)
		return This.Copy().RemoveCharAtPositionQ(n).Content()

		def CharAtNPositionRemoved(n)
			return This.CharAtPositionRemoved(n)

		def NthCharRemoved(n)
			return This.CharAtPositionRemoved(n)

	  #=========================#
	 #   REMOVING FIRST CHAR   #
	#=========================#

	def RemoveFirstChar()
		This.RemoveNthChar(1)

		def RemoveFirstCharQ()
			This.RemoveFirstChar()
			return This

	def FirstCharRemoved()
		return This.Copy().RemoveFirstCharQ().Content()

	  #-----------------------#
	 #   REMOVING LAST CHAR  #
	#-----------------------#

	def RemoveLastChar()
		This.RemoveNthChar(This.NumberOfChars())

		def RemoveLastCharQ()
			This.RemoveLastChar()
			return This

	def LastCharRemoved()
		return This.Copy().RemoveLastCharQ().Content()

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST CHARS  #
	#----------------------------------#

	def RemoveFirstAndLastChars()
		This.RemoveFirstChar()
		This.RemoveLastChar()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsQ()
			This.RemoveFirstAndLastChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstChars()
			This.RemoveFirstAndLastChars()

			def RemoveLastAndFirstCharsQ()
				This.RemoveLastAndFirstChars()
				return This

		#--

		def RemoveFirstCharAndLastChar()
			This.RemoveFirstAndLastChars()

			def RemoveFirstCharAndLastCharQ()
				This.RemoveFirstCharAndLastChar()
				return This

		def RemoveLastCharAndFirstChar()
			This.RemoveFirstAndLastChars()

			def RemoveLastCharAndFirstCharQ()
				This.RemoveLastCharAndFirstChar()
				return This

		#>

	def FirstAndLastCharsRemoved()
		return This.Copy().RemoveFirstAndLastCharsQ().Content()

		def LastAndFirstCharsRemoved()
			return This.FirstAndLastCharsRemoved()

		#--

		def FirstCharAndLastCharRemoved()
			return This.FirstAndLastCharsRemoved()

		def LastCharAndFirstCharRemoved()
			return This.FirstAndLastCharsRemoved()

	  #-----------------------------------------------------------------------------#
	 #  REMOVING A GIVEN CHAR AT A GIVEN POSITION (IF ANY) WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def RemoveThisNthCharCS(n, cChar, pCaseSensitive)
		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.RemoveNthChar(n)
		ok

		def RemoveThisNthCharCSQ(n, cChar, pCaseSensitive)
			This.RemoveThisNthCharCS(n, cChar, pCaseSensitive)
			return This

	def ThisNthCharRemovedCS(n, cChar, pCaseSensitive)
		return This.Copy().RemoveThisNthCharCSQ(n, cChar, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthChar(n, cChar)
		This.RemoveThisNthCharCS(n, cChar, :CaseSensitive = TRUE)

		def RemoveThisNthCharQ(n, cChar)
			This.RemoveThisNthChar(n, cChar)
			return This

	def ThisNthCharRemoved(n, cChar)
		return This.Copy().RemoveThisNthCharQ(n, cChar).Content()

	  #---------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR   #
	#---------------------------------#

	def RemoveThisFirstCharCS(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstChar()
		ok

		def RemoveThisFirstCharCSQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCS(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstChar(c)
		This.RemoveThisFirstCharCS(c, :CaseSensitive = TRUE)

		def RemoveThisFirstCharQ(c)
			This.RemoveThisFirstChar(c)
			return This

	def ThisFirstCharRemoved(c)
		return This.Copy().RemoveThisFirstCharQ(c).Content()

	  #--------------------------------#
	 #   REMOVING A GIVEN LAST CHAR   #
	#--------------------------------#

	def RemoveThisLastCharCS(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastChar()
		ok

		def RemoveThisLastCharCSQ(c, pCaseSensitive)
			This.RemoveThisLastCharCS(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastChar(c)
		This.RemoveThisLastCharCS(c, :CaseSensitive = TRUE)

		def RemoveThisLastCharQ(c)
			This.RemoveThisLastChar(c)
			return This

	def ThisLastCharRemoved(c)
		return This.Copy().RemoveThisLastCharQ(c).Content()

	  #---------------------------------------------------------#
	 #   REMOVING FIRST & LAST CHARS UPAON A GIVEN CONDITION   #
	#---------------------------------------------------------#

	def RemoveFirstCharW(pcCondition)
		cCode = StzStringQ(pcCondition).RemoveSpacesQ().BoundsRemoved("{","}")
		cCode = 'bOk = ' + cCode
		eval(cCode)

		if bOk
			This.RemoveFirstChar()
		ok

		def RemoveFirstCharWQ(pcCondition)
			This.RemoveFirstCharW(pcCondition)
			return This

	def FirstCharRemovedW(pcCondition)
		return This.Copy().RemoveFirstCharWQ(pcCondition).Content()

	#--

	def RemoveLastCharW(pcCondition)
		@char = @@(This.LastChar())
		cCode = StzStringQ(pcCondition).RemoveSpacesQ().BoundsRemoved(["{","}"])
		cCode = 'bOk = (' + cCode + ')'

		eval(cCode)

		if bOk
			This.RemoveLastChar()
		ok

		def RemoveLastCharWQ(pcCondition)
			This.RemoveLastCharW(pcCondition)
			return This

	def LastCharRemovedW(pcCondition)
		return This.Copy().RemoveLastCharWQ(pcCondition).Content()

	  #---------------------------------#
	 #   REMOVING LEFT & RIGHT CHARS   #
	#---------------------------------#

	def RemoveLeftChar()
		This.RemoveNLeftChars(1)

		def RemoveLeftCharQ()
			This.RemoveLeftChar()
			return This

	def LeftCharRemoved()
		cResult = This.Copy().RemoveLeftCharQ().Content()
		return cResult

	def RemoveRightChar()
		This.RemoveNRightChars(1)

		def RemoveRightCharQ()
			This.RemoveRightChar()
			return This

	def RightCharRemoved()
		cResult = This.Copy().RemoveRightCharQ().Content()
		return cResult

	  #----------------------------#
	 #   REMOVING N FIRST CHARS   #
	#----------------------------#

	def RemoveNFirstChars(n)
		if This.IsRightToLeft()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok
		
		#< @FunctionFluentForm

		def RemoveNFirstCharsQ(n)
			This.RemoveNFirstChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstNChars(n)
			This.RemoveNFirstChars(n)

			#< @FuncFluentForm
	
			def RemoveFirstNCharsQ(n)
				This.RemoveNFirstCharsQ(n)
	
			#>

		#>
	
	def NFirstCharsRemoved(n)
		cResult = This.Copy().RemoveNFirstCharsQ(n).Content()
		return cResult

		def FirstNCharsRemoved(n)
			return This.NFirstCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LAST CHARS   #
	#---------------------------#

	def RemoveNLastChars(n)

		if This.IsLeftToRight()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok	

		#< @FunctionFluentForm

		def RemoveNLastCharsQ(n)
			This.RemoveNLastChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastNChars(n)
			This.RemoveNLastChars(n)

			#< @FuncFluentForm
	
			def RemoveLastNCharsQ(n)
				This.RemoveNLastCharsQ(n)
	
			#>

		#>
	
	def NLastCharsRemoved(n)
		cResult = This.Copy().RemoveNLastCharsQ(n).Content()
		return cResult

		def LastNCharsRemoved(n)
			return This.NLastCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LEFT CHARS   #
	#---------------------------#

	def RemoveNLeftChars(n)
		if This.IsLeftToRight()
			This.RemoveSection( 1, n )

		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNLeftCharsQ(n)
			This.RemoveNLeftChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLeftNChars(n)
			This.RemoveNLeftChars(n)

			#< @FuncFluentForm
	
			def RemoveLeftNCharsQ(n)
				This.RemoveNLeftCharsQ(n)
	
			#>
		#>
	
	def NLeftCharsRemoved(n)
		cResult = This.Copy().RemoveNLeftCharsQ(n).Content()
		return cResult

		def LeftNCharsRemoved(n)
			return This.NLeftCharsRemoved(n)


	  #----------------------------#
	 #   REMOVING N RIGHT CHARS   #
	#----------------------------#

	def RemoveNRightChars(n)
		if This.IsRightToLeft()
			This.RemoveSection( 1, n)
		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNRightCharsQ(n)
			This.RemoveNRightChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveRightNChars(n)
			This.RemoveNRightChars(n)

			#< @FuncFluentForm
	
			def RemoveRightNCharsQ(n)
				This.RemoveNRightCharsQ(n)
	
			#>
		#>
	
	def NRightCharsRemoved(n)
		cResult = This.Copy().RemoveNRightCharsQ(n).Content()
		return cResult

		def RightNCharsRemoved(n)
			return This.NRightCharsRemoved(n)

	  #---------------------------------------------#
	 #    REMOVING A GIVEN CHAR FROM THE STRING    # 
	#---------------------------------------------#

	def RemoveCharCS(pcChar, pCaseSensitive) # TODO (future): accept also stzChar objects
		if NOT StringIsChar(pcChar)
			stzRaise("Incorrect param type! You must provide a string containing char")
		ok

		This.RemoveCharsCSW('@char = ' + @@(pcChar), pCaseSensitive)

		def RemoveCharCSQ(pcChar, pCaseSensitive)
			This.RemoveCharCS(pcChar, pCaseSensitive)
			return This

	def CharRemovedCS(pcChar, pCaseSensitive)
		cResult = This.Copy().RemoveCharCSQ(pcChar, pCaseSensitive).Content()
		return cResult

	#---

	def RemoveChar(pcChar)
		if NOT StringIsChar(pcChar)
			stzRaise("Incorrect param type! You must provide a string containing char")
		ok

		This.RemoveCharsW('@char = ' + @@(pcChar))

		def RemoveCharQ(pcChar)
			This.RemoveChar(pcChar)
			return This

	def CharRemoved(pcChar)
		cResult = This.Copy().RemoveCharQ(pcChar).Content()
		return cResult

	  #----------------------------------#
	 #    REMOVING A SECTION OF CHARS   # 
	#----------------------------------#
	
	// Removes a portion of the string defined by its start and end positions
	def RemoveSection(n1, n2)
		#< @QtBased = TRUE #>

		if n1 = :FirstChar or n1 = :StartOfString or n1 = :Frist
			n1 = 1
		ok

		if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
			n1 = This.NumberOfChars()
		ok

		if n2 = :LastChar  or n2 = :EndOfString or n2 = :Last
			n2 = This.NumberOfChars()
		ok

		if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
			n2 = 1
		ok

		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, "")
		This.Update(cResult)

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

	def SectionRemoved(n1, n2)
		cResult = This.Copy().RemoveSectionQ(n1, n2).Content()
		return cResult
	
	  #-------------------------------------------------------#
	 #    REMOVING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#-------------------------------------------------------#

	def RemoveManySections(paSections)
 		/* EXAMPLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.RemoveManySections([
			[1,2], [8, 10], [16, 17], [23, 25]
		])
		
		? o1.Content() #--> "blablablablabla"

		*/

		if isList(paSections)
			oSections = new stzList(paSections)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paSections = oSections.Content()
			
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManySections(paSections)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paSections) is not a list of pairs of numbers."
			])

		ok

		nLen = len(paSections)
		if nLen = 0
			return
		ok

		aSorted = QR(paSections, :stzListOfPairs).Sorted()

		for i = nLen to 1 step -1
			This.RemoveSection(aSorted[i][1], aSorted[i][2])
		next

		def RemoveManySectionsQ(paListOfSections)
			This.RemoveManySections(paListOfSections)
			return This

		def RemoveSections(paListOfSections)
			This.RemoveManySections(paListOfSections)

			def RemoveSectionsQ(paListOfSections)
				This.RemoveSections(paListOfSections)
				return This

	def ManySectionsRemoved(paListOfSections)
		cResult = This.Copy().RemoveManySectionsQ(paListOfSections).Content()
		return This

		def SectionsRemoved(paListOfSections)
			return This.ManySectionsRemoved(paListOfSections)

	  #--------------------------------#
	 #    REMOVING A RANGE OF CHARS   # 
	#--------------------------------#

	// Removes a portion of the string defined by a start position and
	// a range of n chars

	def RemoveRange(nStart, nRange)

		if nStart = :FirstChar or nStart = :StartOfString { nStart = 1 }
		if nRange = :EndOfString { nRange = This.NumberOfChars() - nStart + 1 }

		This.RemoveSection(nStart, nStart + nRange - 1)

		def RemoveRangeQ(nStart, nRange)
			This.RemoveRange(nStart, nNumberOfChars)
			return This

	def RangeRemoved(nStart, nRange)
		cResult = This.RemoveRangeQ(nStart, nRange).Content()
		return cResult

	  #-----------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#-----------------------------------------------------#

	def RemoveManyRanges(paRanges) # Todo: use for loop instead of for/in

		if NOT ( isList(paRanges) and Q(paRanges).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManyRanges(paRanges)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paRanges) is not a list of pairs of numbers."
			])

		ok

		if isList(paRanges)
			oSections = new stzList(paRanges)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paRanges = oSections.Content()
			
		ok

		# Tranform ranges to sections and then use RemoveManySections()

		nLen = len(paRanges)
		aSections = []

		for i = 1 to nLen
			n1 = paRanges[i][1]
			n2 = paRanges[i][1] + paRanges[i][2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.RemoveManySections(aSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManySections(paRanges)

		def RemoveRanges(paRanges)
			This.RemoveManyRanges(paRanges)

			def RemoveRangesQ(paRanges)
				This.RemoveRanges(paRanges)
				return This

	def ManyRangesRemoved(paRanges)
		cResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return This

		def RangedRemoved(paRanges)
			return This.ManyRangesRemoved(paRanges)

	  #-------------------------------------------------------------#
	 #    REMOVING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#-------------------------------------------------------------#

	def RemoveSectionsW(paSections, pcCondition)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Wehre = '{ Q(This(@section)).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		if isString(pcCondition)
			cCondition = pcCondition

		but isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			cCondition = pcCondition[2]

		else
			// TODO: add this check everywhere in the library!
			stzRaise("Incorrect condition format!")
		ok

		cCondition = StzStringQ(cCondition).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				Content()

		cCode = "bOk = ( " + cCondition + " )"

		aSubStrings = This.Sections(paSections)

		aSectionsToRemove = []
		for i = 1 to len( paSections )
			@n1 = paSections[i][1]
			@n2 = paSections[i][2]

			@section = aSubStrings[i]

			eval(cCode)

			if bOk
				aSectionsToRemove + [ @n1, @n2 ]
			ok
		next

		This.RemoveManySections(aSectionsToRemove)

		#< @FunctionFluentForm

		def RemoveSectionsWQ(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
			return This

		def RemoveSectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveSectionsWhereQ(paSections, pcCondition)
				This.RemoveSectionsWhere(paSections, pcCondition)
				return This

		def RemoveManySectionsW(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
	
			def RemoveManySectionsWQ(paSections, pcCondition)
				This.RemoveManySectionsW(paSections, pcCondition)
				return This

		def RemoveManySectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveManySectionsWhereQ(paSections, pcCondition)
				This.RemoveManySectionsWhere(paSections, pcCondition)
				return This

	def ManySectionsRemovedW(paSections, pcCondition)
		cResult = This.Copy().RemoveManySectionsQ(paSections, pcCondition).Content()
		return cResult

		def ManySectionsRemovedWhere(paSections, pcCondition)
			return This.ManySectionsRemovedW(paSections, pcCondition)

	  #----------------------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#----------------------------------------------------------------#

	def RemoveManyRangesW(paListOfRanges, pcCondition)

		# Tranform ranges to sections and then use RemoveManySectionsW()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
	

	
		if isString(pcCondition)
			cCondition = pcCondition

		but isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			cCondition = pcCondition[2]
		ok

		if NOT isString(cCondition)
			stzRaise("Incorrect param! pcCondition must be a string.")
		ok

		cCondition = StzStringQ(cCondition).
				ReplaceCSQ("@range", "@section", :CS = FALSE).
				Content()

		This.RemoveManySectionsW(aSections, cCondition)

		def RemoveManyRangesWQ(paListOfRanges, pcCondition)
			This.RemoveManyRangesW(paListOfRanges, pcCondition)

		def RemoveRangesW(paListOfRanges, pcCondition)
			This.RemoveManyRangesW(paListOfRanges, pcCondition)

			def RemoveRangesWQ(paListOfRanges, pcCondition)
				This.RemoveRangesW(paListOfRanges, pcCondition)
				return This

	def ManyRangesRemovedW(paListOfRanges, pcCondition)
		cResult = This.Copy().RemoveManyRangesWQ(paListOfRanges, pcCondition).Content()
		return cResult

		def RangedRemovedW(paListOfRanges, pcCondition)
			return This.ManyRangesRemovedW(paListOfRanges, pcCondition)

	  #------------------------------------------------------------#
	 #    REMOVING CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION   # 
	#------------------------------------------------------------#

	def RemoveW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam(pcCondition)
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.RemoveSubstringsW(pcCondition)

		else
			return This.RemoveCharsW(pcCondition)
		ok

	  #-------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION   # 
	#-------------------------------------------------#

	def RemoveCharsWhere(pcCondition)

		if isList(pcCondition) and stzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]

			if NOT isString(pcCondition)
				stzRaise("Incorrect param type! pcCondition mus tbe a string.")
			ok
		ok

		anPositions = This.FindAllCharsWhereQ( pcCondition ).SortedInDescending()

		for for n in anPositions
			This.RemoveCharAtPosition(n)
		next

		#< @FunctionFluentForm

		def RemoveCharsWhereQ(pcCondition)
			This.RemoveCharsWhere(pcCondition)
			return This

		#>

		def RemoveCharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveCharsWQ(pcCondition)
				This.RemoveCharsW(pcCondition)
				return This

		def RemoveAllcharsWhere(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWhereQ(pcCondition)
				This.RemoveAllcharsWhere(pcCondition)
				return This

		def RemoveAllcharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWQ(pcCondition)
				This.RemoveAllCharsWhere(pcCondition)
				return This

	  #-----------------------------------#
	 #    REPLACING A SECTION OF CHARS   # 
	#-----------------------------------#
	
	// Replaces a portion of the string defined by its start and end positions

	def ReplaceSection(n1, n2, pcNewSubStr)
		#< @MotherFunction = YES | @QtBased #>

		# Checking the correctness of n1 and n2 params

		if isList(n1) and Q(n1).IsFromNamedParam()
			n1 = n1[2]
		ok

		if isList(n2) and Q(n2).IsToNamedParam()
			n2 = n2[2]
		ok

		if isString(n1)
			if n1 = :First or n1 = :FirstChar or n1 = :StartOfString
				n1 = 1
			ok
		ok

		if isString(n2)
			if n2 = :Last or n2 = :LastChar  or n2 = :EndOfString
				n2 = This.NumberOfChars()
			ok
		ok

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect param types! n1 and n2 must be numbers.")
		ok

		# Checking the pcNewSubStr param

		if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithOrByNamedParam()

			if Q(pcNewSubStr[1]).LastChar() = "@"

				acTemp = eval@( pcNewSubStr[2], :On = This.SectionQ(n1, n2).Chars() )
				pcNewSubStr = QR(acTemp, :stzListOfStrings).Concatenated()

			else
				pcNewSubStr = pcNewSubStr[2]
			ok
		ok

		nQtStart = n1 - 1
		nQtRange = n2 - n1 + 1

		cResult = QStringObject().replace(nQtStart, nQtRange, pcNewSubStr)
		This.Update(cResult)

		#< @FunctionFluentForm

		def ReplaceSectionQ(n1, n2, pcNewSubStr)
			This.ReplaceSection(n1, n2, pcNewSubStr)
			return This

		#>

	def SectionReplaced(n1, n2, pcNewSubStr)
		cResult = This.Copy().ReplaceSectionQ(n1, n2, pcNewSubStr).Content()
		return cResult
	
	  #--------------------------------------------------------#
	 #    REPLACING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#--------------------------------------------------------#

	def ReplaceManySections(paListOfSections, pcNewSubStr)

		/* EXAMLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.ReplaceManySections([ [1,2], [8, 10], [16, 17], [23, 25] ], "_" )
		
		? o1.Content() #--> "_word1_word2_word3_"
		*/

		if NOT( isList(paListOfSections) and Q(paListOfSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		aListOfSections = StzListOfPairsQ( paListOfSections ).SortedInAscending()

		n = 0
		nNumberOfSections = len(aListOfSections)
		
		for i = len(aListOfSections) to 1 step -1

			aSection = aListOfSections[i]

			n1 = aSection[1]
			n2 = aSection[2]

			This.ReplaceSection(n1, n2, pcNewSubStr)

		next

		def ReplaceManySectionsQ(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)
			return This


		def ReplaceSections(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)

			def ReplaceSectionsQ(paListOfSections, pcNewSubStr)
				This.ReplaceSections(paListOfSections, pcNewSubStr)
				return This

	def ManySectionsReplaced(paListOfSections, pcNewSubStr)
		cResult = This.Copy().ReplaceManySectionsQ(paListOfSections, pcNewSubStr).Content()
		return This

		def SectionsReplaced(paListOfSections, pcNewSubStr)
			return This.ManySectionsReplaced(paListOfSections, pcNewSubStr)

	  #---------------------------------#
	 #    REPLACING A RANGE OF CHARS   # 
	#---------------------------------#

	// Replaces a portion of the string defined by a start position and
	// a range of n chars
	def ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)

		if nStart = :FirstChar or nStart = :StartOfString { nStart = 1 }
		if nNumberOfChars = :EndOfString { nNumberOfChars = This.NumberOfChars() - nStart + 1 }

		This.ReplaceSection(nStart, nStart + nNumberOfChars - 1, pcNewSubStr)

		def ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr)
			This.ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)
			return This

	def RangeReplaced(nStart, nNumberOfChars, pcNewSubStr)
		cResult = This.ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#------------------------------------------------------#

	def ReplaceManyRanges(paListOfRanges, pcNewSubStr)

		# Tranform ranges to sections and then use ReplaceManySections()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySections(aSections, pcNewSubStr)

		def ReplaceManyRangesQ(paListOfRanges, pcNewSubStr)
			This.ReplaceManySections(paListOfRanges, pcNewSubStr)

		def ReplaceRanges(paListOfRanges, pcNewSubStr)
			This.ReplaceManyRanges(paListOfRanges, pcNewSubStr)

			def ReplaceRangesQ(paListOfRanges, pcNewSubStr)
				This.ReplaceRanges(paListOfRanges, pcNewSubStr)
				return This

	def ManyRangesReplaced(paListOfRanges, pcNewSubStr)
		cResult = This.Copy().ReplaceManyRangesQ(paListOfRanges, pcNewSubStr).Content()
		return This

		def RangedReplaced(paListOfRanges, pcNewSubStr)
			return This.ManyRangesReplaced(paListOfRanges, pcNewSubStr)

	  #--------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#--------------------------------------------------------------#

	def ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:With = "_",
			:Wehre = '{ Q(This(@section)).IsLowercase() }'
		)

		#--> "..AA.._..BB.._"
		*/

		if NOT( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]

		else
			// TODO: add this check everywhere in the library!
			stzRaise("Incorrect condition format!")
		ok

		pcCondition = StzStringQ(pcCondition).
				SimplifyQ().
				ReplaceBoundsQ(["{","}"]).
				Content()

		cCode = "bOk = ( " + pcCondition + " )"

		aSubStrings = This.Sections(paSections)

		aSectionsToReplace = []
		for i = 1 to len( paSections )
			@n1 = paSections[i][1]
			@n2 = paSections[i][2]

			@range = aSubStrings[i]

			eval(cCode)

			if bOk
				aSectionsToReplace + [ @n1, @n2 ]
			ok
		next

		This.ReplaceManySections(aSectionsToReplace, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSectionsWQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedW(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhere(paSections, pcCondition)
			return This.ManySectionsReplacedW(paSections, pcCondition)

	  #-----------------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#-----------------------------------------------------------------#

	def ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

		# Tranform ranges to sections and then use ReplaceManySectionsW()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySectionsW(aSections, pcNewSubStr, pcCondition)

		def ReplaceManyRangesWQ(paListOfRanges, pcNewSubStr, pcCondition)
			This.ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

		def ReplaceRangesW(paListOfRanges, pcNewSubStr, pcCondition)
			This.ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWQ(paListOfRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesW(paListOfRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedW(paListOfRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWQ(paListOfRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def RangedReplacedW(paListOfRanges, pcNewSubStr, pcCondition)
			return This.ManyRangesReplacedW(paListOfRanges, pcNewSubStr, pcCondition)

	  #==========================================#
	 #    SWAPPING TWO SECTIONS OF THE STRING   # 
	#==========================================#

	def SwapSections( panSection1, panSection2 )
		if isList(panSection2) and Q(panSection2).IsWithOrAndNamedParams()
			panSection2 = panSection2[2]
		ok

		if NOT BothArePairsOfNumbers(panSection1, panSection2)
			StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
		ok

		aSorted = QR([ panSection1, panSection2 ], :stzListOfPairs).Sorted()

		anFirstSection = []
		anLastSection  = []

		if Q(aSorted[1]).IsEqualTo(panSection1)
			anFirstSection = panSection1
			anLastSection  = panSection2

		else
			anFirstSection = panSection2
			anLastSection  = panSection1
		ok

		cResult = This.Section(anLastSection[1], anLastSection[2]) +
			  This.Section(anFirstSection[2] + 1, anLastSection[1] - 1) +
			  This.Section(anFirstSection[1], anFirstSection[2])

		This.UpdateWith(cResult)


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2)
		return cResult

	  #========================================#
	 #    REMOVING NUMBERS FROM THE STRING    # 
	#========================================#

	def RemoveNumbers()
		cResult = ""
	
		aStzChars = This.ToListOfStzChars()

		# TODO: Replace for/in with for --> better performance
		for oChar in aStzChars
			if NOT oChar.IsANumber()
				cResult += oChar.Content()
			ok
		next
	
		This.Update( cResult )

	
		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

	def NumbersRemoved()
		cResult = This.Copy().RemoveNumbersQ().Content()
		return cResult

	  #====================================================#
	 #     REMOVING THE NTH OCCURRENCE OF A SUBSTRING     #
	#====================================================#

	def RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if isList(n)
			This.RemoveOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return
		ok

		This.ReplaceNthOccurrenceCS(n, pcSubStr, "", pCaseSensitive)

		#< @FunctionFluentForm
	
		def RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def RemoveNthCS(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

			def RemoveNthCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNthCS(n, pcSubStr, pCaseSensitive)
				return This

		#>

	def NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def NthRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def SubStringNthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pcSubStr)
		This.RemoveNthOccurrenceCS(n, pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveNth(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)

			def RemoveNthQ(n, pcSubStr)
				This.RemoveNth(n, pcSubStr)
				return This

		#>

	def NthOccurrenceOfSubStringRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveNthOccurrenceQ(n, pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def NthRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def SubStringNthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		#>

	  #------------------------------------------------#
	 #    REMOVING FIRST OCCURRENCE OF A SUBSTRING    #
	#------------------------------------------------#

	def RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveFirstCS(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveFirstCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def FirstRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pcSubStr)
		This.RemoveFirstOccurrenceCS(pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.RemoveFirstOccurrence(pcSubStr)
			return This
	
		#>

		#< @functionAlternativeForm

		def RemoveFirst(pcSubStr)
			This.RemoveFirstOccurrence(pcSubStr)

			def RemoveFirstQ(pcSubStr)
				This.RemoveFirst(pcSubStr)
				return This

		#>

	def FirstOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveFirstOccurrenceQ(pcSubStr).Content()

		def FirstRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringFirstOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	  #--------------------------------------------------#
	 #     REMOVING LAST OCCURRENCE OF A SUBSTRING      #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveLastCS(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveLastCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def LastRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringLastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pcSubStr)
		This.RemoveLastOccurrenceCS(pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)
			return This
	
		#>

		#< @FunctionLastOccurrence

		def RemoveLast(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)

			def RemoveLastQ(pcSubStr)
				This.RemoveLast(pcSubStr)
				return This

		#>

	def LastOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveLastOccurrenceQ(pcSubStr).Content()

		def LastRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringLastOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	   #----------------------------------------------------#
	  #    REMOVING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		def RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				This.RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
				return This

		#>

	def NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthNextOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

		#>

	def NextNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthNextOccurrenceRemoved(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart, pCaseSensitive)

	   #------------------------------------------------#
	  #    REMOVING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		def RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

	def NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, :CaseSensitive = TRUE)

		def RemoveNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemoveNextOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

	   #-------------------------------------------------------#
	  #    REMOVING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                       #
	#-------------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				This.RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
				return This

		#>

	def PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthPreviousOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

		#>

	def PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart).Content()
		return cResult

		def NthPreviousOccurrenceRemoved(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

	   #----------------------------------------------------#
	  #    REMOVING PREVIOUS OCCURRENCE OF A SUBSTRING     # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		def RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

	def PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, :CaseSensitive = TRUE)

		def RemovePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

	  #-----------------------------------------------#
	 #    REMOVING LEFT OCCURRENCE OF A SUBSTRING    # 
	#-----------------------------------------------#

	def RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsRightToLeft()
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def LeftOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLeftOccurrence(pcSubStr)
		This.RemoveLeftOccurrenceCS(pcSubStr, :CaseSensitive = FALSE)

		def RemoveLeftOccurrenceQ(pcSubStr)
			This.RemoveLeftOccurrence(pcSubStr)
			return This

	def LeftOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveLeftOccurrenceQ(pcSubStr).Content()
		return cResult

	  #---------------------------------------------#
	 #    REMOVING RIGHT OCCURRENCE OF SUBSTRING   # 
	#---------------------------------------------#

	def RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsRightToLeft()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsLeftToRight()

			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def RightOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveRightOccurrence(pcSubStr)
		This.RemoveRightOccurrenceCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveRightOccurrenceQ(pcSubStr)
			This.RemoveRightOccurrence(pcSubStr)
			return This

	def RightOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveRightOccurrenceQ(pcSubStr).Content()
		return cResult

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM LEFT    #
	#-------------------------------------#

	def RemoveFromLeftCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NLeftCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsLeftToRight()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr
			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
			return This

		def RemovSubStringFromLeftCS(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromLeftCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromLeftCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromLeftCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromLeftCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromLeftCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromLeftCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromLeft(pcSubStr)
		This.RemoveFromLeftCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveFromLeftQ(pcSubStr)
			This.RemoveFromLeft(pcSubStr)
			return This

		def RemovSubStringFromLeft(pcSubStr)
			This.RemoveFromLeft(pcSubStr)

			def RemovSubStringFromLeftQ(pcSubStr)
				This.RemovSubStringFromLeft(pcSubStr)
				return This

	def RemovedFromLeft(pcSubStr)
		cResult = This.Copy().RemoveFromLeftQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromLeft(pcSubStr)
			return This.RemovedFromLeft(pcSubStr)

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM RIGHT   #
	#-------------------------------------#

	def RemoveFromRightCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NRightCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsRightToLeft()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr

			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromRightCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
			return This

		def RemoveRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightCS(pcSubStr, pCaseSensitive)
				return This

		def RemovSubStringFromRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromRightCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromRightCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromRightCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromRightCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromRightCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromRightCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromRight(pcSubStr)
		This.RemoveFromRightCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveFromRightQ(pcSubStr)
			This.RemoveFromRight(pcSubStr)
			return This

		def RemoveRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveRightQ(pcSubStr)
				This.RemoveRight(pcSubStr)
				return This

		def RemovSubStringFromRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemovSubStringFromRightQ(pcSubStr)
				This.RemovSubStringFromRight(pcSubStr)
				return This

	def RemovedFromRight(pcSubStr)
		cResult = This.Copy().RemoveFromRightQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromRight(pcSubStr)
			return This.RemovedFromRight(pcSubStr)	

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM START   #
	#-------------------------------------#

	def RemoveFromStartCS(pcSubStr, pCaseSensitive)

		if This.IsLeftToRight()
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromStartCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromStartCS(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromStartCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromStartCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveStartCS(pcSubStr, pCaseSensittive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveStartCSQ(pcSubStr, pCaseSensittive)
				This.RemoveStartCS(pcSubStr, pCaseSensittive)
				return This

		#>

	def RemovedFromStartCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromStartCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromStartCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

		def StartRemovedCS(pcSubStr, pCaseSensittive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromStart(pcSubStr)
		This.RemoveFromStartCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFromStartQ(pcSubStr)
			This.RemoveFromStart(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemovSubStringFromStartQ(pcSubStr)
				This.RemovSubStringFromStart(pcSubStr)
				return This

		def RemoveStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveStartQ(pcSubStr)
				This.RemoveStart(pcSubStr)
				return This

		#>

	def RemovedFromStart(pcSubStr)
		cResult = This.Copy().RemoveFromStartQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromStart(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

		def StartRemoved(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

	  #-----------------------------------#
	 #   REMOVING A SUBSTRING FROM END   #
	#-----------------------------------#

	def RemoveFromEndCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromEndCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromEndCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromEndCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEndCS(pcSubStr, pCaseSensitive)
				return This
		#>

	def RemovedFromEndCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromEndCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromEndCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

		def EndRemovedCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromEnd(pcSubStr)
		This.RemoveFromEndCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFromEndQ(pcSubStr)
			This.RemoveFromEnd(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemovSubStringFromEndQ(pcSubStr)
				This.RemovSubStringFromEnd(pcSubStr)
				return This

		def RemoveEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveEndQ(pcSubStr)
				This.RemoveEnd(pcSubStr)
				return This

		#>

	def RemovedFromEnd(pcSubStr)
		cResult = This.Copy().RemoveFromEndQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromEnd(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

		def EndRemoved(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

	  #--------------------------------------------------------#
	 #    REMOVING CHARS FROM LEFT UNDER A GIVEN CONDITION    # 
	#--------------------------------------------------------#

	def RemoveCharsFromLeftW(pcCondition)
		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param type! Condition should be in a string.")
		ok

		pcCondition = StzCCodeQ(pcCondition).UnifiedFor(:stzString)

		cCode = "bOk = ( " + pcCondition + " )"
		oCode = new stzString(cCode)

		cSubStrToRemove = ""

		nLen = This.NumberOfChars()

		for @i = 1 to nLen
			@char = This.Char(@i)
			bEval = TRUE

			if @i = nLen and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i+1]", :CS = FALSE )

				bEval = FALSE
			ok

			if @i = 1 and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i-1]", :CS = FALSE )

				bEval = FALSE
			ok
			
			if bEval
				eval(cCode)
				if bOk
					cSubStrToRemove += @charName
				ok
			ok
		next

		This.RemoveSubStringFromLeft(cSubStrToRemove)

		def RemoveCharsFromLeftWWQ(pcCondition)
			This.RemoveCharsFromLeftW(pcCondition)
			return This

		def RemoveFromLeftW(pcCondition)
			This.RemoveCharsFromLeftW(pcCondition)

			def RemoveFromLeftWQ(pcCondition)
				This.RemoveFromLeftW(pcCondition)
				return This

		def RemoveLeftW(pcCondition)
			This.RemoveFromLeftW(pcCondition)

			def RemoveLeftWQ(pcCondition)
				This.RemoveLeftW(pcCondition)
				return This

	def CharsRemovedFromLeft(pcCondition)
		cResult = This.Copy().RemoveCharsFromLeftWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM RIGHT UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromRightW(pcCondition)
		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param type! Condition should be in a string.")
		ok

		pcCondition = StzCCodeQ(pcCondition).UnifiedFor(:stzString)

		cCode = "bOk = ( " + pcCondition + " )"
		oCode = new stzString(cCode)

		cSubStrToRemove = ""

		for @i = 1 to This.NumberOfChars()
			@char = This.Char(@i)
			bEval = TRUE

			if @i = This.NumberOfChars() and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i+1]", :CS = FALSE )

				bEval = FALSE
			ok

			if @i = 1 and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i-1]", :CS = FALSE )

				bEval = FALSE
			ok
			
			if bEval
				eval(cCode)
				if bOk
					cSubStrToRemove += @charName
				ok
			ok
		next

		This.RemoveSubStringFromRight(cSubStrToRemove)

		def RemoveCharsFromRightWWQ(pcCondition)
			This.RemoveCharsFromRightW(pcCondition)
			return This

		def RemoveFromRightW(pcCondition)
			This.RemoveCharsFromRightW(pcCondition)

			def RemoveFromRightWQ(pcCondition)
				This.RemoveFromRightW(pcCondition)
				return This

		def RemoveRightW(pcCondition)
			This.RemoveFromRightW(pcCondition)

			def RemoveRightWQ(pcCondition)
				This.RemoveRightW(pcCondition)
				return This

	def CharsRemovedFromRight(pcCondition)
		cResult = This.Copy().RemoveCharsFromRightWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM START UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromStartW(pcCondition)
		if This.IsLeftToRight()
			This.RemoveCharsFromLeftW(pcCondition)

		else
			This.RemoveCharsFromRightW(pcCondition)
		ok


		def RemoveCharsFromStartWWQ(pcCondition)
			This.RemoveCharsFromStartW(pcCondition)
			return This

		def RemoveFromStartW(pcCondition)
			This.RemoveCharsFromStartW(pcCondition)

			def RemoveFromStartWQ(pcCondition)
				This.RemoveFromStartW(pcCondition)
				return This

		def RemoveStartW(pcCondition)
			This.RemoveFromStartW(pcCondition)

			def RemoveStartWQ(pcCondition)
				This.RemoveStartW(pcCondition)
				return This

	def CharsRemovedFromStart(pcCondition)
		cResult = This.Copy().RemoveCharsFromStartWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM END UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromEndW(pcCondition)
		if This.IsLeftToRight()
			This.RemoveCharsFromRighttW(pcCondition)

		else
			This.RemoveCharsFromLeftW(pcCondition)
		ok

		def RemoveCharsFromEndWWQ(pcCondition)
			This.RemoveCharsFromEndW(pcCondition)
			return This

		def RemoveFromEndW(pcCondition)
			This.RemoveCharsFromEndW(pcCondition)

			def RemoveFromEndWQ(pcCondition)
				This.RemoveFromEndW(pcCondition)
				return This

		def RemoveEndW(pcCondition)
			This.RemoveFromEndW(pcCondition)

			def RemoveEndWQ(pcCondition)
				This.RemoveEndW(pcCondition)
				return This

	def CharsRemovedFromEnd(pcCondition)
		cResult = This.Copy().RemoveCharsFromEndWQ(pcCondition).Content()
		return cResult

	  #----------------------------------#
	 #    TRIMMING & REMOVING SPACES    # 
	#----------------------------------#

	def Trim()
		This.Update( This.QStringObject().trimmed() )

		def TrimQ()
			This.Trim()
			return This

	def Trimmed()
		cResult = This.Copy().TrimQ().Content()
		return cResult

		def WithoutLeadingAndTrailingSpaces()
			return This.Trimmed()

	def TrimStart()
		if This.HasRepeatedLeadingChars()	
			This.RemoveThisRepeatedLeadingChar(" ")
		ok

		if This.FirstChar() = " "
			This.RemoveFirst(" ")
		ok

		def TrimStartQ()
			This.TrimStart()
			return This

		def RemoveLeadingSpaces()
			This.TrimStart()

			def RemoveLeadingSpacesQ()
				This.RemoveLeadingSpaces()
				return This

	def TrimmedFromStart()
		cResult = This.Copy().TrimStartQ().Content()
		return cResult

		def LeadingSpacesRemoved()
			return This.TrimmedFromStart()

		def WithoutLeadingSpaces()
			return This.TrimmedFromStart()

	def TrimEnd()

		This.RemoveThisRepeatedTrailingChar(" ")

		if This.LastChar() = " "
			This.RemoveLast(" ")
		ok

		def TrimEndQ()
			This.TrimEnd()
			return This

		def RemoveTrailingSpaces()
			This.TrimEnd()

			def RemoveTrailingSpacesQ()
				This.RemoveTrailingSpaces()
				return This
	
	def TrimmedFromEnd()
		cResult = This.Copy().TrimEndQ().Content()
		return cResult

		def TrailingSpacesRemoved()
			return This.TrimmedFromEnd()

		def WithoutTrailingSpaces()
			return This.TrimmedFromEnd()

	def TrimLeft()
		if This.IsLeftToRight()
			This.TrimStart()

		else # IsRightToLeft
			This.TrimEnd()
		ok

		def TrimLeftQ()
			This.TrimLeft()
			return This

		def RemoveLeftSpaces()
			This.TrimeLeft()

			def RemoveLeftSpacesQ()
				This.RemoveLeftSpaces()
				return This

	def TrimmedFromLeft()
		cResult = This.Copy().TrimLeftQ().Content()
		return cResult

		def LeftSpacesRemoved()
			return This.TrimmedFromLeft()

		def WithoutLeftSpaces()
			return This.TrimmedFromLeft()

	def TrimRight()
		if This.IsRightToLeft()
			This.TrimStart()

		else # IsLeftToRight
			This.TrimEnd()
		ok

		def TrimRightQ()
			This.TrimRight()
			return This

		def RemoveRightSpaces()
			This.TrimRight()

			def RemoveRightSpacesQ()
				This.RemoveRightSpaces()
				return This

	def TrimmedFromRight()
		cResult = This.Copy().TrimRightQ().Content()
		return cResult

		def RightSpacesRemoved()
			return This.TrimmedFromRight()

		def WithoutRightSpaces()
			return This.TrimmedFromRight()

	def RemoveSpaces()
		This.RemoveAll(" ")

		def RemoveSpacesQ()
			This.RemoveSpaces()
			return This

		def RemoveAllSpaces()
			This.RemoveSpaces()

			def RemoveAllspacesQ()
				This.RemoveSpaces()
				return This

	def SpacesRemoved()
		cResult = This.Copy().RemoveSpacesQ().Content()
		return cResult

		def WithoutSpaces()
			return This.SpacesRemoved()

			#< @FunctionMisspelledForm

			def WithoutSapces()
				return This.WithoutSpaces()

			#>

	  #==========================================#
	 #  EXTRACTING A SUBSTRING FROM THE STRING  #
	#==========================================#

	def ExtractCS(pcSubStr, pCaseSensitive)
		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			StzRaise("Can't extract the substring! It does not exist in the string.")
		ok

		This.RemoveCS(pcSubStr, pCaseSensitive)
		return pcSubStr

	#-- WITHOUT CASESENSITIVITY

	def Extract(pcSubStr)
		return This.ExtractCS(pcSubStr, :CaseSensitive = TRUE)

	  #----------------------------------------------#
	 #  EXTRACTING MANY SUBSTRINGS FROM THE STRING  #
	#----------------------------------------------#

	def ExtractManyCS(pacSubStrings, pCaseSensitive)
		if NOT This.ContainsManyCS(pacSubStrings, pCaseSensitive)
			StzRaise("Can't extract the substrings! Items in pacSubStrings do not exist in the list.")
		ok

		This.RemoveManyCS(pacSubStrings, pCaseSensitive)
		return pacSubStrings

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(pacSubStrings)
		return This.ExtractManyCS(pacSubStrings, :pCaseSensitive = TRUE)

	  #-------------------------------------------------#
	 #  EXTRACTING ALL THE SUBSTRINGS FROM THE STRING  #
	#-------------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

	  #---------------------------#
	 #  EXTRACTING THE NTH CHAR  #
	#---------------------------#

	def ExtractAt(n)
		if isString(n) and ( n = :Last or n = :LastChar )
			n = This.NumberOfItems()
		ok

		if NOT isNumber(n) and Q(n).IsBetween(1, This.NumberOfItems())
			StzRaise("Can't extract! n outside of range.")
		ok

		cTempChar = This.CharAt(n)

		This.RemoveAt(n)

		return cTempChar

		def ExtractNthChar(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST CHAR  #
	#-----------------------------#

	def ExtractFirstChar()
		return This.ExtractAt(1)
 
	  #----------------------------#
	 #  EXTRACTING THE LAST CHAR  #
	#----------------------------#

	def ExtractLastChar()
		return This.ExtractAt(:LastChar)

	  #------------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF A SUBSTRING  #
	#------------------------------------------------#

	def ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive) > 0
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			StzRaise("Can't extract! The string does not contain n occurrences of pcSubStr.")
		ok

		def ExtractNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pcSubStr)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, :CaseSensitive = TRUE)

		def ExtractNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

	  #--------------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF A SUBSTRING  #
	#--------------------------------------------------#

	def ExtractFirstCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pcSubStr)
		return This.ExtractFirstCS(pcSubStr, :CaseSensitive = TRUE)

	  #-------------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF A SUBSTRING  #
	#-------------------------------------------------#

	def ExtractLastCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(:Last, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pcSubStr)
		return This.ExtractLastCS(pcSubStr, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------#
	 #  EXTRACTING CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------------#

	def ExtractW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Can't proceed! pcCondition must contain either @char or @substring keywords, but not both.")
		ok

		if Q(pcCondition).ConytainsCS("@substring", :CS = FALSE)
			aResult = This.SubStringsW(pcCondition)

		else
			aResult = This.CharsW(pcCondition)
		ok

		if len(aResult) = 0
			StzRaise("Can't extract! The condition returns no values at all.")
		ok

		This.RemoveW(pcCondition)
		return aResult

	  #----------------------------------------#
	 #  EXTRACTING A SECTION FROM THE STRING  #
	#----------------------------------------#

	def ExtractSection(n1, n2)
		if NOT BothAreNumbers(n1, n2) and
		   Q(n1).IsBetween(1, This.NumberOfItems()) and
		   Q(n2).IsBetween(1, This.NumberOfItems())

			StzRaise("Can't extract! The section is outside the list.")
		ok

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

	  #--------------------------------------#
	 #  EXTRACTING A RANGE FROM THE STRING  #
	#--------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

	  #-----------------------------------------------------#
	 #  EXTRACTING NEXT SUBSTRING STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------#

	def ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if This.FindNextCS(pcSubStr, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemoveNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return pcSubStr

	#-- WITHOUT CASESENSITIVITY

	def ExtractNext(item, pnStartingAt)
		return This.ExtractNextCS(item, pnStartingAt, :CaseSensitive = TRUE)

	  #---------------------------------------------------------#
	 #  EXTRACTING PREVIOUS SUBSTRING STARTING AT A GIVEN POSITION  #
	#---------------------------------------------------------#

	def ExtractPreviousCS(item, pnStartingAt, pCaseSensitive)
		if This.FindPreviousCS(item, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemovePreviousCS(item, pnStartingAt, pCaseSensitive)
		return item

	#-- WITHOUT CASESENSITIVITY

	def ExtractPrevious(item, pnStartingAt)
		return This.ExtractPreviousCS(item, pnStartingAt, :CaseSensitive = TRUE)

	
	  #==========================================================#
	 #   SIMPLIFYING THE STRING BY REMOVING DUPLICATED SPACES   #
	#==========================================================#

	def Simplify()

		# t0 = clock() // Veryf fast, takes almost 0.01s

		This.Update( @oQString.simplified() )

		# ? ( clock() - t0 ) / clockspersecond()

		def SimplifyQ()
			This.Simplify()
			return This

	def Simplified()
		cResult = This.Copy().SimplifyQ().Content()
		return cResult

	  #-------------------------------------------------#
	 #   SIMPLIFYING THE STRING EXCEPT SOME SECTIONS   #
	#-------------------------------------------------#

	def SimplifyExcept(paSections)
		/* EXAMPLE

		o1 = new stzString(' this code:   txt1  = "    withspaces    "   and txt2="nospaces"  ')
		o1.SimplifyExcept( [ [], [] ] )

		#--> 'var txt = "    nice    "'

		*/

		if isList(paSections) and Q(paSections).IsSectionsNamedParam()
			paSections = paSections[2]
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aAntiSections = This.AntiSectionsAsPairsOfNumbers(paSections)
		nLen = len(aAntiSections)

		for i = nLen to 1 step -1

			n1 = aAntiSections[i][1]
			n2 = aAntiSections[i][2]

			cSection = This.Section(n1, n2)

			cSectionSimplified = Q(cSection).Simplified()

			if (n2 - n1 + 1) > 2
				if Q(cSection).LastChar() = " " and
				   Q(cSectionSimplified).Last2CharsAsString() != "  "
	
					cSectionSimplified += " "
	
				but Q(cSection).FirstChar() = " " and
				    Q(cSectionSimplified).First2CharsAsString() != "  "
	
					cSectionSimplified = " " + cSectionSimplified
				ok
			ok

			This.ReplaceSection(n1, n2, cSectionSimplified)
		next

		This.Trim()

		def SimplifyExceptQ(paSections)
			This.SimplifyExcept(paSections)
			return This

	def SimplifiedExcept(paSections)
		cResult = This.Copy().SimplifyExceptQ().Content()
		return cResult

	  #==========================#
	 #  SPACIFYING THE STRING   #
	#==========================#

	def SpacifyXT(pcSeparator, pnStep, pcDirection)
		/* EXAMPLE

		Basic mode:

		o1 = new stzString("99999999999")
		? o1.SpacifiedXT(:Separator = "_", :Step = 3, :Direction = :Backward)
		#--> 99_999_999_999

		Advanced mode:
		
		o1 = new stzString("99999999999")
		o1.SpacifyXT(
			:Using    = [ ".", :AndThen = " " ],
			:Stepping = [ 2, :AndThen = 3],
			:Going    = :Backward
		)
		
		? o1.Content()
		#--> 99 999 999.99

		*/

		cMode = :Basic
		cSeparator2 = ""
		nStep2 = 0

		# Checking params correctness

		if isList(pcSeparator) and Q(pcSeparator).IsOneOfTheseNamedParams([ :Using, :Separator ])
			pcSeparator = pcSeparator[2]
		ok

		if isList(pnStep) and Q(pnStep).IsOneOfTheseNamedParams([ :Step, :Stepping, :EachNChars ])
			pnStep = pnStep[2]
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# checking :Using = [ ".", :AndThen = " " ]
		if isList(pcSeparator) and (isString(pcSeparator[2]))

			cMode = :Extended
			pcSeparator = pcSeparator[1]
			cSeparator2 = pcSeparator[2]

		but isList(pcSeparator) and isList(pcSeparator[2]) and
		    Q(pcSeparator[2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isString(pcSeparator[2][2])

			cMode = :Extended
			cSeparator2 = pcSeparator[2][2]
			pcSeparator = pcSeparator[1]
			
		ok

		# checking :Stepping = [ 2, :AndThen = 3]
		if isList(pnStep) and (isNumber(pnStep[2]))

			cMode = :Basic
			pnStep = pnStep[1]
			nStep2 = pnStep[2]

		but isList(pnStep) and isList(pnStep[2]) and
		    Q(pnStep[2][2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isNumber(pnStep[2][2][2])

			cMode = :Extended
			nStep2 = pnStep[2][2][2]
			pnstep = pnStep[2][1]
			
		ok

		if NOT (isString(pcSeparator) and pcSeparator != "")
			StzRaise("Incorrect param type! pcSeparator must be a non null string.")
		ok

		if NOT (isNumber(pnStep) and pnStep != 0)
			StzRaise("Incorrect param type! pnStep must be a non null number.")
		ok

		# Doing the job

		nLen = This.NumberOfChars()

		if cMode = :Basic

			anPos = []
			if pcDirection = :Forward
					
				for i = (pnStep + 1) to nLen step pnStep
					anPos + i
				next

				This.InsertBeforeThesePositions(anPos, pcSeparator)

			but pcDirection = :Backward
		
				for i = (nLen - pnStep) to 1 step -pnStep

					anPos + i
				next

				This.InsertAfterThesePositions(anPos, pcSeparator)
			ok

			

		but cMode = :Extended
			
			nStart = 0
			if pcDirection = :Forward
				This.InsertBefore( pnStep + 1, pcSeparator )
				nStart = pnStep + nStep2 + 1
			else
				This.InsertBefore( nLen - pnStep + 1, pcSeparator )
				nStart = nLen - pnStep - nStep2
			ok

			pnStep = nStep2
			pcSeparator = cSeparator2
			anPos = []

			if pcDirection = :Forward
				for i = nStart to nLen step pnStep
					anPos + i
				next
		
			but pcDirection = :Backward
		
				for i = nStart to 1 step -pnStep
					anPos + i
				next
			ok

			This.InsertAfterThesePositions(anPos, pcSeparator)

		ok

		def SpacifyXTQ(pcSeparator, pnStep, pcDirection)
			This.SpacifyXT(pcSeparator, pnStep, pcDirection)
			return This

	def SpacifiedXT(pcSeparator, pnStep, pcDirection)
		return This.Copy().SpacifyXTQ(pcSeparator, pnStep, pcDirection).Content()

	  #----------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING   #
	#----------------------------------------#

	def SpacifyEachNChars(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsQ(n)
			This.SpacifyEachNChars(n)
			return This

	def EachNCharsSpacified(n)
		return This.Copy().SpacifyEachNCharsQ(n).Content()

	#--

	def SpacifyEachNCharsForward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsForwardQ(n)
			This.SpacifyEachNCharsForward(n)
			return This

	def EachNCharsSpacifiedForward(n)
		return This.Copy().SpacifyEachNCharsForwardQ(n).Content()

	#--

	def SpacifyEachNCharsBackward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Backward)

		def SpacifyEachNCharsBackwardQ(n)
			This.SpacifyEachNCharsBackward(n)
			return This

	def EachNCharsSpacifiedBackward(n)
		return This.Copy().SpacifyEachNCharsBackwardQ(n).Content()

	#--

	def SpacifyChars()
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").Spacified()
		#--> R I N G O R I A L A N D

		*/
		This.SpacifyXT(:Using = " ", :EachNChars = 1, :Forward)

		def SpacifyCharsQ()
			This.SpacifyChars()
			return This

		def Spacify()
			This.SpacifyChars()

			def SpacifyQ()
				This.Spacify()
				return This

	def CharsSpacified()
		cResult = This.Copy().SpacifyCharsQ().Content()
		return cResult

		def Spacified()
			return This.CharsSpacified()

	  #----------------------------------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------#

	def SpacifyCharsUsing(pcSep)
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").SpacifiedUsing("_")
		#--> R_I_N_G_O_R_I_A_L_A_N_D

		*/

		This.SpacifyXT(:Using = pcSep, :EachNChars = 1, :Forward)

		def SpacifyCharsUsingQ(pcSep)
			This.SpacifyCharsUsing(pcSep)
			return This

		def SpacifyUsing(pcSep)
			This.SpacifyCharsUsing(pcSep)

			def SpacifyUsingQ(pcSep)
				This.SpacifiyUsing(pcSep)
				return This

	def CharsSpacifiedUsing(pcSep)
		cResult = This.Copy().SpacifyCharsUsingQ(pcSep).Content()
		return cResult

		def SpacifiedUsing(pcSep)
			return CharsSpacifiedUsing(pcSep)

	  #--------------------------------------------------------------------------#
	 #  SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING USING A GIVEN SEPARATOR  #
	#--------------------------------------------------------------------------#

	def SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
		This.AddBoundsToSubStringCS(pcSubStr, pcSep, pcSep, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
			return This

		#>

	def SubStringSpacifiedUsingCS(pcSubStr, pcSep, pCaseSensitive)
		cResult = This.Copy().SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubstringUsing(pcSubStr, pcSep)
		This.SpacifySubStringUsingCS(pcSubStr, pcSep, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringUsingQ(pcSubStr, pcSep)
			This.SpacifySubstringUsing(pcSubStr, pcSep)
			return This

		#>

	def SubStringSpacifiedUsing(pcSubStr, pcSep)
		cResult = This.Copy().SpacifySubStringUsingQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	  #----------------------------------------------------#
	 #   SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#----------------------------------------------------#

	def SpacifySubstringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed()
	
		for aSection in anSections
			n1 = aSection[1]
			n2 = aSection[2]

			if n2 < This.NumberOfChars() and
			   This.CharAt(n2 + 1) != " "

				This.InsertAfter(n2, " ")
			ok

			if n1 > 1 and This.CharAt(n1 - 1) != " "
				This.InsertBefore(n1, " ")
			ok
		next

		def SpacifySubStringCSQ(pcSubStr, pCaseSensitive)
			This.SpacifySubStringCS(pcSubStr, pCaseSensitive)
			return This

		def SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
			This.SpacifySubstringCS(pcSubStr, pCaseSensitive)

			def SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

	def SubStringSpacifiedCS(pcSubStr, pCaseSensitive)
		return This.Copy().SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive).Content()

		def ThisSubStringSpacifiedCS(pcSubStr, pCaseSensitive)
			return This.SubStringSpacifiedCS(pcSubStr, pCaseSensitive)

	#-- CASE-SENSITIVE

	def SpacifySubstring(pcSubStr)
		This.SpacifySubstringCS(pcSubStr, :CaseSensitive = TRUE)

		def SpacifySubstringQ(pcSubStr)
			This.SpacifySubstring(pcSubStr)
			return This

		def SpacifyThisSubString(pcSubStr)
			This.SpacifySubstring(pcSubStr)

			def SpacifyThisSubStringQ(pcSubStr)
				This.SpacifyThisSubString(pcSubStr)
				return This

	def SubStringSpacified(pcSubStr)
		return This.Copy().SpacifyThisSubStringQ(pcSubStr).Content()

		def ThisSubStringSpacified(pcSubStr)
			return This.SubStringSpacified(pcSubStr)

	  #----------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING   #
	#----------------------------------------------#

	def SpacifySubStringsCS(pacSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("IbelieveinRingfutureandengageforit!")

		o1.SpacifyTheseSubStrings([
			"believe", "in", "Ring", "future", "and", "engage", "for"
		])

		#--> I believe in Ring future and engage for it!

		*/

		This.SpacifySubStringsUsingCS(pacSubStr, " ", pCaseSensitive)

		#< @FuncionFluentForm

		def SpacifySubStringsCSQ(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def SpacifyTheseCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This


		#>

	def SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
		return This.Copy().SpacifySubStringsCSQ(pacSubStr, pCaseSensitive).Content()

		def TheseSubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

		def TheseSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStrings(pacSubStr)
		This.SpacifySubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		def SpacifySubStringsQ(pacSubStr)
			This.SpacifySubStrings(pacSubStr)
			return This

		def SpacifyTheseSubStrings(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseSubStringsQ(pacSubStr)
				This.SpacifyTheseSubStrings(pacSubStr)
				return This

		def SpacifyThese(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseQ(pacSubStr)
				This.SpacifyThese(pacSubStr)
				return This

	def SubStringsSpacified(pacSubStr)
		return This.Copy().SpacifySubStringsQ(pacSubStr).Content()

		def TheseSubStringsSpacified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

		def TheseSpaccified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

	  #----------------------------------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------------#

	def SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).isListOfStrings() )
			stzRaise("Incorrect param! pacSubStr must be a list of strings.")
		ok


		if NOT ( isList(pacSubStr) and Q(pacSubStr).isListOfStrings() )
			stzRaise("Incorrect param! pacSubStr must be a list of strings.")
		ok

		# Removing duplicates from the provided substrings

		pacSubStr = Q(pacSubStr).DuplicatesRemoved()
		nLen = len(pacSubStr)

		# Among the substrings provided, idenifying those that
		# actually exist in the string (others are ignored)

		acSubstrings = []
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				acSubstrings + pacSubStr[i]
			ok
		next
		#--> [ "believe", "in", "Ring", "future", "and", "engage", "for" ]
		nLenSubStr = len(acSubStrings)

		if nLenSubStr = 0
			return
		ok

		# Sorting the substrings in descending order

		acSubStrings = QR(acSubStrings, :stzListOfStrings).SortedInDescendingBy('Q(@string).NumberOfChars()')
		nLenSubStr = len(acSubStrings)

		aSections = []
		aSectionsNow = [ [ 1, This.NumberOfChars() ] ]

		for i = 1 to nLenSubStr

			aTempSections = This.FindInSectionsAsSectionsCS(
					acSubStrings[i], aSectionsNow, pCaseSensitive)

			nLenTemp = len(aTempSections)

			for j = 1 to nLenTemp
				aSections + aTempSections[j]
			next

			aSectionsNow = This.FindAntiSections( aSections )

		next

		This.SpacifySections(aSections)


		#< @FunctionFluentForm

		def SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseSubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		def SpacifyTheseUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		#>

	def SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
		return This.Copy().SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def TheseSubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		def TheseSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStringsUsing(pacSubStr, pcSep)
		This.SpacifySubStringsUsingCS(pacSubStr, pcSep, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringsUsingQ(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)
			return This

		def TheseSpacifiedUsingUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)

			def SpacifyTheseSubStringsUsingQ(pacSubStr, pcSep)
				This.SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
				return This

		#>

	def SubStringsSpacifiedUsing(pacSubStr, pcSep)
		return This.Copy().SpacifySubStringsUsingQ(pacSubStr, pcSep).Content()

		def TheseSubStringsSpacifiedUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

	  #------------------------------------------#
	 #   SPACIFITYING A SECTION OF THE STRING   #
	#------------------------------------------#

	def SpacifySection(n1, n2)

		cLeftSpace = ""
		if This.CharAt(n1) != " "
			cLeftSpace = " "
		ok

		cRightSpace = ""
		if This.CharAt(n2)
			cRightSpace = " "
		ok

		This.ReplaceSection(n1, n2, :By = (cLeftSpace + This.Section(n1, n2) + cRightSpace) )

		def SpacifySectionQ(n1, n2)
			This.SpacifySection(n1, n2)
			return This

	def SectionSpacified(n1, n2)
		cResult = This.Copy().SpacifySectionQ(n1, n2).Content()
		return cResult

	  #----------------------------------------------#
	 #   SPACIFITYING MANY SECTIONS OF THE STRING   #
	#----------------------------------------------#

	def SpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		anPos = []
		for i = 1 to nLen
			anPos + paSections[i][1]
			anPos + (paSections[i][2] + 1)
		next

		This.InsertBeforePositions(anPos, " ")

		def SpacifySectionsQ(paSections)
			This.SpacifySections(paSections)
			return This

	def SectionsSpacified(paSections)
		cResult = This.Copy().SpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #   UNSPACIFYING THE STRING --> REMOVING SPACES  #
	#================================================#

	def UnSpacify()
		if This.Content() = ""
			return

		but This.NumberOfChars() = 1 and This.Content() = " "
			This.Clear()

		but This.NumberOfChars() = 2
			if This.Content() = " " + " "
				This.Update(" ")

			but This.Contains(" ")
				This.Remove(" ")
			ok

		else

			This.Trim()
		ok


		def UnSpacifyQ()
			This.UnSpacify()
			return This

	def Unspacified()
		return This.Copy().UnSpacifyQ().Content()

	  #------------------------------------------------------#
	 #   UNSPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#------------------------------------------------------#

	def UnSpacifySubStringCS(pcSubStr, pCaseSensitive)

		if NOT ( isString(pcSubStr) and Q(pcSubStr).ContainsSpaces() )
			StzRaise("Incorrect param! pcSubStr must be a string containing spaces.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.ReplaceSections( aSections, Q(pcSubStr).Unspacified() )

	def UnSpacifySubString(pcSubStr)
		This.UnSpacifySubStringCS(pcSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------#
	 #   UNSPACIFITYING A SECTION OF THE STRING   #
	#--------------------------------------------#

	def UnSpacifySection(n1, n2)
		This.ReplaceSection(n1, n2, :By = Q(This.SectionQ(n1, n2).Unspacified()) )

		def UnSpacifySectionQ(n1, n2)
			This.UnSpacifySection(n1, n2)
			return This

	def SectionUnSpacified(n1, n2)
		cResult = This.Copy().UnSpacifySectionQ(n1, n2).Content()
		return cResult

	  #------------------------------------------------#
	 #   UNSPACIFITYING MANY SECTIONS OF THE STRING   #
	#------------------------------------------------#

	def UnSpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		paSections = StzListOfPairsQ(paSections).SortedInAscending()
		nLen = len(paSections)

		for i = nLen to 1 step -1
			n1 = paSections[i][1]
			n2 = paSections[i][2]

			cSectionWithoutSpaces = This.SectionQ(n1, n2).Unspacified()
			This.ReplaceSection( n1, n2, :By = cSectionWithoutSpaces )

		next

		def UnSpacifySectionsQ(paSections)
			This.UnSpacifySections(paSections)
			return This

	def SectionsUnSpacified(paSections)
		cResult = This.Copy().UnSpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #    GETTING POSITION AFTER A GIVEN SUBSTRING    #
	#================================================#

	def PositionAfterCS(cSubStr, pCaseSensitive)
		return This.PositionAfterNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionAfterNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		n = This.FindNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		oStr = new stzString(cSubStr)
		return n + oStr.NumberOfChars()

	def PositionAfter(cSubStr)
		return This.PositionAfterCS(cSubStr, :CaseSensitive = TRUE)

	def PositionAfterNthOccurrence(n, cSubStr)
		return This.PositionAfterNthOccurrenceCS(n, cSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------#
	 #    GETTING POSITION BEFORE A GIVEN SUBSTRING     #
	#--------------------------------------------------#

	def PositionBeforeCS(cSubStr, pCaseSensitive)
		return This.PositionBeforeNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		return This.FindNthOccurrenceCS(cSubStr, pCaseSensitive)
	
	def PositionBefore(cSubStr)
		return This.PositionBeforeCS(cSubStr, :CaseSensitve = FALSE)

	def PositionBeforeNthOccurrence(n, cSubStr)
		return This.PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)

	  #------------------------------#
	 #   FINDING THE CENTRAL CHAR   #
	#------------------------------#
	
	// Returns the position (if any) of the central Char in the string
	def FindCentralChar()
		nResult = 0

		oNumberOfChars = new stzNumber(This.NumberOfChars())
		if oNumberOfChars.IsOdd()
			nResult = ( This.NumberOfChars() + 1 ) / 2
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindMiddleChar()
			return This.FindCentralChar()

		def PositionOfCentralChar()
			return This.FindCentralChar()

		def CentralCharposition()
			return This.FindCentralChar()

		def PositionOfMiddleChar()
			return This.FindCentralChar()

		def MiddleCharposition()
			return This.FindCentralChar()


		#>

	  #------------------------------#
	 #   GETTING THE CENTRAL CHAR   #
	#------------------------------#

	def CentralChar()
		if This.CentralCharPosition() != NULL
			return This.NthChar( This.CentralCharPosition() )
		ok

		def CentralCharQ()
			return This.CentralCharQR(:stzChar)
	
		def CentralCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar( This.CentralChar() )
			on :stzString
				return new stzString( This.CentralChar() )
			on :stzListOfBytes
				return new stzListOfBytes( This.CentralChar() )
			off

		def MiddleChar()
			return This.CentralChar()

	  #-----------------------------------------------#
	 #   DOES THE STRING CONTAIN ANY CENTRAL CHAR?   #
	#-----------------------------------------------#

	def ContainsCentralChar()
		return This.NumberOfCharsQ().IsNotEven()

		def ContainsMiddleChar()
			return This.ContainsCentralChar()

		def HasCentralChar()
			return This.ContainsCentralChar()

		def HasMiddleChar()
			return This.ContainsCentralChar()

	  #---------------------------------------------------#
	 #   DOES THE STRING CONTAIN A GIVEN CENTRAL CHAR?   #
	#---------------------------------------------------#

	def ContainsCharInTheCenter(c)
		return This.CentralChar() = c

		def ContainsCharInTheMiddle(c)
			return This.ContainsCharInTheCenter()

		def HasCharInTheCenter(c)
			return This.ContainsCharInTheCenter(c)

		def HasCharInTheMiddle(c)
			return This.ContainsCharInTheMiddle(c)

	  #----------------------------------------------------#
	 #    DOES THE STRING CONTAIN ANY MIDDLE SUBSTRING?   #
	#----------------------------------------------------#

	def ContainsMiddleSubstring()
		if This.NumberOfCharsQ().IsOdd()
			return TRUE

		else
			return FALSE
		ok

		def HasMiddleSubstring()
			return This.ContainsMiddleSubstring()

		def ContainsCentralSubString()
			return This.ContainsMiddleSubstring()

		def HasCentralSubString()
			return This.ContainsMiddleSubstring()

	  #---------------------------------------------------------#
	 #    DOES THE STRING CONTAIN A GIVEN MIDDLE SUBSTRING?    #
	#---------------------------------------------------------#

	def ContainsSubstringInTheMiddle(pcSubStr)
		if IsStzString(pcSubStr)
			pcSubStr = pcSubStr.Content()
		ok

		if This.MiddleSubstring() = pcSubStr
			return TRUE
		else
			return FALSE
		ok

		def HasSubstringInTheCenter(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

		def ContainsSubstringInTheCenter(c)
			return This.ContainsSubstringInTheMiddle(c)

		def HasSubstringInTheMiddle(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

	  #---------------------------------------------------#
	 #    GETTING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def MiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		cResult = ""

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			n1 = nNumberOfCharsOfOnePart + 1
			n2 = nNumberOfChars - nNumberOfCharsOfOnePart

			cResult = This.Section( n1, n2 )
		ok

		return cResult

		#< @FunctionALternativeForms

		def CentralSubstringWithNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringN(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringN(n)
			return This.MiddleSubstringWithNChars(n)


		#>

	  #---------------------------------------------------#
	 #    FINDING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def FindMiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		nResult = 0

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			nResult = nNumberOfCharsOfOnePart + 1
		ok

		return nResult

		#< @FunctionALternativeForms

		def FindCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#--

		def PositionOfMiddleSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#>

	  #--------------------------------#
	 #   GETTING STRING ORIENTATION   #
	#--------------------------------#

	/*
	Note that we distinguish between string 'orientation', 
	char 'orientation', and char 'unicode direction'.

	The first says if a string is left-to-right or right-to-left oriented, and
	uses the Orientation() method, here, in stzString.

	The second says the same thing for the individual chars, and uses
	the Orientation() method on stzChar.

	While the third informs us about the technical direction of the char,
	in terms of UNICODE standard, and is returned using UnicodeDirection()
	method on stzChar.
	*/

	// Returns the orientation of the string (:RightToLeft OR :LeftToRight)
	def Orientation()
		if This.IsRightToLeft()
			return :RightToLeft
		else
			return :LeftToRight
		ok

	// Verifies if the string is right-to-left (like arabic) : SEE Orientation()
	def IsRightToleft()
		bResult = @oQString.isRightToleft()

		return bResult

	// Verifies if the string is left-to-right (like english)
	def IsLeftToRight()
		IF NOT This.IsRightToLeft()
			return TRUE
		else
			return FALSE

		ok

	// Checks if the text is hybrid (containing :RightToLeft AND :LeftToRight" texts)
	def ContainsHybridOrientation()
		aStzChars = This.ToListOfStzChars()

		bIsHybrid = FALSE
		cFlag = aStzChars[1].Orientation()

		for i=2 to len(aStzChars)
			if aStzChars[i].Orientation() != cFlag
				bIsHybrid = TRUE
				exit
			ok
		next

		return bIsHybrid

	// Transforms the string to a list of chars with indication of their orientation
	def CharsWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)
			aResult + [ This.Char(i) , oTempChar.Orientation() ]
		next

		return aResult

	def CharsWithOrientationQ()
		return new stzList( This.CharsWithOrientation() )

	// Transforms the string to a list of letters with indication of their orientation
	def LettersWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)

			if oTempChar.isLetter()
				aResult + [ This.Char(i) , oTempChar.Orientation() ]
			ok
		next

		return aResult

	def LettersWithOrientationQ()
		return new stzList( This.LettersWithOrientation() )

	  #----------------------#
	 #     ONLY NUMBERS     #
	#----------------------#
		
	/* Returns (as a string) only the numbers contained in the string

	   Note: if the string contains "㊱", for example, then it is returned
	   as the number 36 contained in a string ("36")!

	   To return just numbers formed from decimal digits from 0 to 9,
	   use OnlyDecimalDigits()
	*/

	def OnlyNumbers()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsANumber()
				cResult += c
			ok
		next
		return cResult

		def OnlyNumbersQ()
			return new stzString( This.OnlyNumbers() )

	def OnlyDecimalDigits()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsDecimalDigit()
				cResult += c
			ok
		next
		return cResult

	def OnlyDecimalDigitsQ()
		return new stzList( This.OnlyDecimalDigits() )

	  #------------------------------------------#
	 #     ONLY LETTERS AND SPACES ANS CHARS    #
	#------------------------------------------#

	// Returns (as a string) only the letters contained in the string
	def OnlyLetters()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.isLetter()
				cResult += c
			ok
		next
		return cResult

	def OnlyLettersQ()
		return new stzList(This.OnlyLetters())

	#----

	def OnlyLettersAndSpaces()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			if StzCharQ(c).IsLetterOrSpace()

				cResult += c
			ok
		next

		return cResult

	def OnlyLettersAndSpacesQ()
		return new stzString( This.OnlyLettersAndSpaces() )

	#----

	def OnlyLettersAndSpacesAndChar(pcChar)

		# t0 = clock() # Takes almost 0.62s

		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsLetterOrSpaceOrChar(pcChar)
				cResult += c
			ok
		next

		# ? ( clock() - t0 ) / clockspersecond()

		return cResult

		def OnlyLettersAndSpacesAndThisChar(pcChar)
			return This.OnlyLettersAndSpacesAndChar(pcChar)

	def OnlyLettersAndSpacesAndCharQ(pcChar)
		return new stzString( This.OnlyLettersAndSpacesAndChar(pcChar) )

		def OnlyLettersAndSpacesAndThisCharQ(pcChar)
			return OnlyLettersAndSpacesAndCharQ(pcChar)

	#----

	def OnlyLettersAndSpacesAndChars(pacChars)
		return This.ItemsWhere('isLetter(@item) or isSpace(@item) or Q(@item).IsOneOfThese(pacChars)')

		def OnlyLettersAndSpacesAndCharsQ(paChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

		def OnlyLettersAndSpacesAndTheseChars(pacChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

	def IsLetterOrSpaceOrChar(pcChar)
		return This.IsLetterOrSpaceOrOneOfTheseChars([ pcChar ])

		def IsLetterOrSpaceOrThisChar(pcChar)
			return IsLetterOrSpaceOrChar(pcChar)

	def IsLetterOrSpaceOrChars(pacChar)
		bResult = FALSE

		if This.IsLetter() or This.IsSpace() or
		   This.IsOneOfThese(pacChars)

			return TRUE
		else
			return FALSE
		ok

		def IsLetterOrSpaceOrOneOfTheseChars(pacChar)
			return This.IsLetterOrSpaceOreChars(pacChar)

	  #==========================#
	 #    ALIGNING THE STRING   #
	#==========================#

	def Align(pcDirection)
		This.AlignXT( :Max, " ", pcDirection )

		#< @FunctionFluentForms

		def AlignQ(pcDirection)
			This.Align(pcDirection)
			return This

		def AlignQC(pcDirection)
			return This.Copy().Align(pcDirection)

		#>

		#< @FunctionAlternativeForms

		def AlignTo(pcDirection)
			This.Align(pcDirection)

			def AlignToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AlignToQC(cDirection)
				return This.AlignQC(cDirection)

		def Adjust(pcDirection)
			This.Align(pcDirection)

			def AdjustQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustQC(cDirection)
				return This.AlignQC(cDirection)

		def AdjustTo(pcDirection)
			This.Align(pcDirection)

			def AdjustToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustToQC(cDirection)
				return This.AlignQC(cDirection)
		#>
		
	def Aligned(cDirection)
		return This.Copy().AlignQ(cDirection).Content()

		#< @FunctionAlternativeForms

		def AlignedTo(cDirection)
			return This.Aligned(cDirection)

		def Adjusted(cDirection)
			return This.Aligned(cDirection)

		def AdjustedTo(cDirection)
			return This.Aligned(cDirection)

		#>
	  #-----------------------------------#
	 #  ALIGNING THE STRING -- EXTENDED  #
	#-----------------------------------#

	// Aligns the text in a container of width nWidth
	// Note: if the width is smaller then the string, nothing is done!

	def AlignXT(nWidth, cChar, cDirection)
		# cChar is the char to fill the 'blanks" with.

		if isList(nWidth) and Q(nWidth).IsWidthNamedParam()
			nWidth = nWidth[2]
		ok

		if isList(cChar) and ( Q(cChar).IsUsingNamedParam() or
			Q(cChar).IsCharNamedParam() )

			cChar = cChar[2]
		ok

		if isString(cChar) and cChar = ""
			cChar = " "
		ok

		if isList(cDirection) and ( Q(cDirection).IsOneOfTheseNamedParams([ :Direction, :Going ]) or
			Q(cDirection).IsToNamedParam() )

			cDirection = cDirection[2]
		ok

		switch cDirection

		on :Left
			return This.AlignLeftXT(nWidth, cChar)

		on :Right
			return This.AlignRightXT(nWidth, cChar)

		on :Center
			return This.AlignCenterXT(nWidth, cChar)

		on :Justified
			return This.JustifyXT(nWidth, cChar)

		other
			stzRaise(stzStringError(:UnsupportedStringJustificationDirection))
		end

		#< @FunctionFluentForm

		def AlignXTQ(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def AdjustXT(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)

			def AdjustXTQ(nWidth, cChar, cDirection)
				return This.AlignXTQ(nWidth, cChar, cDirection)

		#>

	def AlignedXT(nWidth, cChar, cDirection)
		cResult = This.Copy().AlignXTQ(nWidth, cChar, cDirection).Content()
		return cResult

		def AdjustedXT(nWidth, cChar, cDirection)
			return This.AlignedXT(nWidth, cChar, cDirection)

	  #-----------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT  #
	#-----------------------------------#

	def LeftAlign(nWidth)
		This.LeftAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def LeftAlignQ(nWidth)
			This.LeftAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AlignToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def LeftAdjust(nWidth)
			This.LeftAlign(nWidth)

			def LeftAdjustQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		#>

	def LeftAligned(nWidth)
		cResult = This.Copy().LeftAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		def LeftAdjusted(nWidth)
			return This.LeftAligned(nWidth)

		def AdjustedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		#>

	  #-----------------------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT -- EXTENDED  #
	#-----------------------------------------------#

	def LeftAlignXT(nWidth, cChar)

		/* NOTE

		Managing the special case of the arabic char (Shaddah)
		which can alter the justification of text, because Qt
		treats it as a spearate char with its own position in
		the resulting string, while it must set on top of chars!

		Note: The same case of arabic diacritics (7araket)
		is not managed in this version (In the future,
		an extended arabic library will manage those (and other)
		specificities of arabic language.

		WARNING: In this version, if your arabic text contains
		arabic diactritics (7arakets), then the alignment
		won't be correct!

		Also, for this alignement to work as expected, the font
		you use in to display the text on the console must be
		of "fixed size".

 		*/

		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the alignment using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			// Take in account a logical error of Qt in aligning non
			// left-to-right strings (like arabic and hebrew)

			if This.IsRightToLeft()
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def LeftAlignXTQ(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeftXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def AlignLeftXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		def LeftAdjustXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def LeftAdjustXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		#>

	def LeftAlignedXT(nWidth, cChar)
		cResult = This.Copy().LeftAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeftXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		def LeftAdjustedXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		#>

	  #------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT  #
	#------------------------------------#

	def RightAlign(nWidth)
		This.RightAlignXT(nWidth, " ")

		#< @FunctioFluentForm

		def RightAlignQ(nWidth)
			This.RightAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRight(nWidth)
			This.RightAlign(nWidth)

			def AlignRightQ(nWidth)
				return This.RightAlignQ(nWidth)

		def AlignToRight(nWidth)
			This.RightAlign(nWidth)

			def AlignToRightQ(nWidth)
				return This.RightAlignQ(nWidth)
	
		def RightAdjust(nWidth)
			This.RightAlign(nWidth)

			def RightAdjustQ(nWidth)
				return This.RightAlignQ(nWidth)

		#>

	def RightAligned(nWidth)
		cResult = This.Copy().RightAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRight(nWidth)
			return This.RightAligned(nWidth)

		def RightAdjusted(nWidth)
			return This.RightAligned(nWidth)

		def AdjustedtoRight(nWidth)
			return This.RightAligned(nWidth)

		#>

	  #------------------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT -- EXTENDED  #
	#------------------------------------------------#

	def RightAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			if This.IsRightToLeft()
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def RightAlignXTQ(nWidth, cChar)
			
			This.RightAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRightXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def AlignRightXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		def RightAdjustXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def RightAdjustXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		#>

	def RightAlignedXT(nWidth, cChar)
		cResult = This.Copy().RightAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def RightAdjustedXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def AdjustedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		#>

	  #------------------------#
	 #  CENTERING THE STRING  #
	#------------------------#

	def CenterAlign(nWidth)
		This.CenterAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def CenterAlignQ(nWidth)
			This.CenterAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AlignCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def CenterAdjust(nWidth)
			This.CenterAlign(nWidth)

			def CenterAdjustQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def Center(nWidth)
			This.CenterAlign(nWidth)

			def CenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		#>

	def CenterAligned(nWidth)
		cResult = This.Copy().CenterAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def AdjustedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def CenterAdjusted(nWidth)
			return This.CenterAligned(nWidth)

		def Centered(nWidth)
			This.CenterAligned(nWidth)

		#>

	  #------------------------------------#
	 #  CENTERING THE STRING -- EXTENDED  #
	#------------------------------------#

	def CenterAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth > This.NumberOfChars()

			n = nWidth - This.NumberOfChars()
			n1 = 0
			n2 = 0

			oNumber = new stzNumber(n)
			if oNumber.IsEven()
				n1 = n / 2
				n2 = n1
			else
				n1 = (n - 1) / 2
				n2 = n1 + 1
			ok

			cResult = StringRepeat(cChar, n1) +
				  This.String() +
				  StringRepeat(cChar, n2)

			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def CenterAlignXTQ(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AlignToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterAdjustXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterAdjustXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		#>

	def CenterAlignedXT(nWidth, cChar)
		cResult = This.Copy().CenterAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenterAdjustedXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def AdjustedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenteredXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		#>

	  #-------------------------#
	 #  JUSTIFYING THE STRING  #
	#-------------------------#

	def Justify(nWidth)
		This.JustifyXT(nWidth, " ")

		def JustifyQ(nWidth)
			This.Justify(nWidth)
			return This

		// NEW: returns a jystified copy of the string object
		// --> Useful in copy-on-right (functional) programming
		def JustifyQC(nWith)
			return This.Copy().Justify(nWidth)

	def Justified(nWidth)
		return This.Copy().JustifyQ(nWidth).Content()

	  #-------------------------------------#
	 #  JUSTIFYING THE STRING -- EXTENDED  #
	#-------------------------------------#

	def JustifyXT(nWidth, pcChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth <= This.NumberOfChars()
			return NULL
		ok

		nPoints = nWidth - This.NumberOfChars()
		aTemp = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen - 1

			cCurrentChar = This.Char(i)

			if NOT ( CharIsArabicShaddah(cChar) or CharIsArabic7arakah(cCurrentChar) )

				aTemp + cCurrentChar
			else
				if len(aTemp) != 0
					aTemp[ len(aTemp) ] = aTemp[ len(aTemp) ] + cCurrentChar
				ok
			ok
		next

		while nPoints > 0
			for i = 1 to len(aTemp)
				aTemp[i] = aTemp[i] + pcChar
				nPoints--
				if nPoints = 0 { exit }
			next
		end

		aTemp + This.LastChar()

		cResult = ""
		for str in aTemp
			cResult += str
		next

		cResult = Q(cResult).ReplaceQ(" ", pcChar).Content()
		This.Update( cResult )

		def JustifyXTQ(nWidth, pcChar)
			This.JustifyXT(nWidth, pcChar)
			return This

	def JustifiedXT(nWidth, pcChar)
		cResult = This.Copy().JustifyXTQ(nWidth, pcChar).Content()

	  #==================================#
	 #    TEXT ENCODING & CONVERTING    #
	#==================================#

	//Returns a UTF-8 representation of the string (using QByteArray)
	def ToUTF8()
		return QByteArrayToListOfUnicodes(@oQString.toUtf8())

	def ToUTF8Q()
		return new stzString( This.ToUTF8() )

	def FromUTF8(pcUTF8String)
		// TODO

	def ToLatin1()
		return @oQString.toLatin1()

	def FromLatin1(pcLatin1String)
		// TODO

	def ToLocal8Bit()
		return @oQString.toLocal8Bit()

	def ToBase64()
		return This.ToStzListOfBytes().ToBase64()

		def ToBase64Q()
			return new stzString( This.ToBase64() )

	// Transforms the content of the string to a url-like encoded string
	def ToPercentEncoding(pcExcludedFromEncoding, pcIncludedInEncoding, pcPercentAsciiChar)
		/* Example:
		o1 = new stzString("{a fishy string?}")
		? o1.ToPercentEncoding( "{}", "s" )

		--> {a%20fi%73hy%20%73tring%3F}
		*/

	// Updates the list of bytes with an url-like decoded copy of the provided string
	def FromPercentEncoding(pcPercentEncodedString, pcPercentAsciiChar) // TODO
		/* Example:
		o1 = new stzString("")
		o1.FromPercentEncoding( "{a%20fi%73hy%20%73tring%3F}", "%" )
		o1.Content()

		--> {a fishy string?}
		*/

	def ToHex()
		return str2hex( This.String() )

		def ToHexQ()
			return new stzString( This.ToHex() )

	def ToHexSpacified()
		cHex = This.ToHex()
		n = ceil( StzStringQ(cHex).NumberOfChars() / This.NumberOfBytes() )

		cResult = StzStringQ(cHex).InsertAfterEveryNCharsQ(n, " ").Content()
		return cResult

	def FromHex(cHex)
		@oQString = new QString2()
		@oQString.append(hex2str(cHex))

		def FromHexQ(cHex)
			This.FromHex(cHex)
			return This

	// Escapes HTML special Chars in the string
	def EscapeHtml()
		cResult = @oQString.toHtmlEscaped()

		return cResult

		def EscapeHtmlQ()
			return new stzString( This.EscapeHtml() )

	def HtmlEscaped()
		return This.EscapeHtmlQ().Content()
	
	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// Transforms the string to a number based on the defined format
	// --> TODO: Use the ApplyFormat() method in the stzNumber class...
	// Rething the naming!
	def ToNumberFormatted(cFormat) // TODO
		/*
		o1 = new stzString("+12500,14")
		? o1.ToNumberFormatted( :As = "+99 999.99") --> 12 500.14
		*/

		stzRaise("Function unavailable in this version!")

		def ToNumberFormattedQ(cFormat)
			return new stzNumber( This.ToNumberFormatted() )

	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// The following method is mainly used by stzChar class to
	// create a characrer object from text
	def UnicodeOfCharN(n)
		oTempQStr = new QString2()
		oTempQStr.append(This[n])
		return oTempQStr.unicode().unicode()
		/*
		The first unicode() on QString returns a QChar,
		while the seconde unicode() on this QChar returns
		the actual decimal unicode of the Char
		*/

	// Returns a list of unicodes of all the Chars in the string
	def Unicodes()
		aResult = []
		for i = 1 to This.NumberOfChars()
			aResult + This.UnicodeOfCharN(i)
		next

		return aResult

		def UnicodesQR(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Unicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Unicodes() )

			other
				stzRaise("Unsupported return type!")
			off

	def Unicode()
		if This.NumberOfChars() = 1
			return This.UnicodeOfCharN(1)

		else
			return This.Unicodes()
		ok

	def CharsAndUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.UnicodeOfCharN(i) ]
		next

		return aResult

		def CharsAndTheirUnicodes()
			return This.CharsAndUnicodes()

		def UnicodesPerChar()
			return This.CharsAndUnicodes()

	def UnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.UnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		def UnicodesAndTheirChars()
			return This.UnicodesAndChars()

		def UnicodesXT()
			return This.UnicodesAndChars()

	
		def CharsPerUnicode()
			return This.UnicodesAndChars()

	  #-------------------#
	 #    CHARS NAMES    #
	#-------------------#

	def CharsNames()
		acResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			acResult + This.CharQ(i).Name()
		next

		return acResult

		def CharNamesQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if pcReturnType = :stzList
				return new stzList(This.CharNames())

			pcReturnType = :stzListOfStrings
				return new stzListOfString(This.CharNames())

			else
				stzRaise("Unsupported return type!")
			ok

		def CharNamesQ()
			return This.CharNamesQR(:stzListOfStrings)

		def CharsAndTheirNames()
			return This.CharsNames()

	def CharName()
		return This.CharsNames()[1]

		def CharNameQ()
			return new stzString(This.CharName())

	  #===============================#
	 #    MULTINGUAL & LOCLAE INFO   #
	#===============================#

	/*
	In Softanza, a unicode code of a language, country or locale can be:
		* number : like "6" for arabic
		* name : like "arabic" for arabic
		* abbreviation : like "ar" (short form) and "ara" (long form) for arabic
	*/

	def IsLanguageIdentifier()
		return 	This.IsLanguageNumber() or
			This.IsLanguageAbbreviation() or
			This.IsLanguageName()

	def IsLanguageNumber()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if aLanguageInfo[1] = This.String()
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsLanguageCode()
			return This.IsLanguageNumber()

	def IsShortLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLongLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageAbbreviation()
		/* Could be written expressively like this:

		return This.IsLanguageShotAbbreviation() OR This.IsLanguageLongAbbreviation()

		but the following is mutch more efficient: */

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()

			if lower(aLanguageInfo[3]) = lower(This.String()) OR
			   lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageShortAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageLongAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def LanguageAbbreviationForm()

		if NOT This.IsLanguageAbbreviation()
			cForm = :NotLanguage
		
		else

			if This.IsLanguageShortAbbreviation()
				cForm = :Short

			but This.IsLanguageLongAbbreviation()
				cForm = :Long
			ok
		ok

		return cForm

	def IsLanguageName() # In english

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[2]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsNotLanguageName()
			return NOT This.IsLanguageName()

	def IsNativeLanguageName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzStringError(:UnsupportedFeatureInThisVersion)) # TODO

	def IsCountryIdentifier()
		return 	This.IsCountryNumber() or
			This.IsCountryAbbreviation() or
			This.IsCountryName() or
			This.IsCountryPhoneCode()

	def IsCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr) OR
			   UPPER(aCountryInfo[4]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsCountryName()
		if This.IsEmpty() { return FALSE }

		cName = This.String()
		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[2]) = lower(cName)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsNotCountryName()
			return NOT This.IsCountryName()

	def IsNativeCountryName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzString(:UnsupportedFeatureInThisVersion))

	def IsCountryPhoneCode()
		if This.IsEmpty() { return FALSE }

		cPhoneCode = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if aCountryInfo[5] = cPhoneCode
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def IsCountryNumber()
		if This.IsEmpty() { return FALSE }

		cNumber = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[1]) = lower(cNumber)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsCountryCode()
			return This.IsCountryNumber()

	def IsShortCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryShortAbbreviation()
			return This.IsShortCountryAbbreviation()

	def IsLongCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[4]) = UPPER(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryLongAbbreviation()
			return This.IsLongCouontryAbbreviation()

	def IsCountryAbbreviationXT()
		/*
		Returns :
		[ TRUE, :Short ] or [ :TRUE, :Long ] or [ FALSE, NULL ]
		*/

		if This.IsEmpty() { return FALSE }

		bAbbr = This.IsCountryAbbreviation()
		ctype = :Nothing

		if This.IsShortCountryAbbreviation()
			cType = :Short
		but This.IsLongCountryAbbreviation()
			cType = :Long
		ok

		return [ bAbbr, cType ]
	
	def IsScriptIdentifier()
		return 	This.IsScriptNumber() or
			This.IsScriptAbbreviation() or
			This.IsScriptName()

	# Script abbreviation can't be short or long, it is always 4 chars long!
	def IsScriptAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[3]) = lower(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsScriptName()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[2]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScript()
			return This.IsScriptName()

		def IsNotScriptName()
			return NOT This.IsScriptName()

	def IsScriptNumber()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[1]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScriptCode()
			return This.IsScriptNumber()

	def IsLocaleAbbreviation()
		cThisString = This.Copy().ReplaceQ("_", "-").Content()
		oLocalesInString = StzStringQ( LocaleAbbreviationsHostedInString() )
		bResult = oLocalesInString.ContainsCS( cThisString, :CaseSensitive = FALSE )

		return bResult
	
	def ContainsLocaleSeparator()
		return This.Contains("_") or This.Contains("-")

	def ExtractLocaleSeparator()

		if This.ContainsLocaleSeparator()
			if This.Contains("_")
				return "_"

			but This.Contains("-")
				return "-"
			ok
		ok

	def ContainsNoLocaleSeparator()
		return NOT This.ContainsLocaleSeparator()

	def ContainsOneLocaleSeparator()
		return  This.ContainsNTimes(1, "_") or
			This.ContainsNTimes(1, "_")

	def IsLocaleSeparator()
		return This.Content() = "_" or This.Content() = "-"

	def IsCurrencyName()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCurrencyInfo in CurrenciesXT()
			if lower(aCurrencyInfo[1]) = This.Lowercased()
				bResult = TRUE
				exit
			ok
		next

		return bResult	

	def IsCurrencySymbol()	# TODO
		if This.IsEmpty() { return FALSE }
		
	def IsBp64LocaleAbbreviation() # Like "ar-TN" for example
		if This.IsEmpty() { return FALSE }

		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsDayName() # In english

		return This.IsDayNameIn(:English)

	def IsDayNameIn(pcLanguageName)
		if This.IsEmpty() { return FALSE }

		return This.LowercaseQ().IsOnOfThese(NamesOfDaysIn(pcLanguageName))

	def IsNativeDayNameInLocale(pLocale) # Locale-specific
		if This.IsEmpty() { return FALSE }

		return This.IsEqualToCS(StzLocaleQ(pLocale).NativeDayName(), :CaseSensitive = FALSE)

	def IsMonthName() # In english
		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsNativeMonthName() # Locale-specific
		stzRaise(:UnsupportedFeatureInThisVersion)

	  #========================#
	 #    NUMBER IN STRING    #
	#========================#

	def RepresentsDecimalNumber()
		return This.RepresentsNumberInDecimalForm()

		def IsNumberInString()
			return This.RepresentsDecimalNumber()

		def IsANumberInString()
			return This.RepresentsDecimalNumber()

		def IsNumberInAString()
			return This.RepresentsDecimalNumber()

		def IsANumberInAString()
			return This.RepresentsDecimalNumber()

		def RepresentsADecimalNumber()
			return This.RepresentsDecimalNumber()

		def IsDecimalNumberInString()
			return This.RepresentsDecimalNumber()

		def IsDecimalNumberInAString()
			return This.RepresentsDecimalNumber()

		def IsADecimalNumberInString()
			return This.RepresentsDecimalNumber()

		def IsADecimalNumberInAString()
			return This.RepresentsDecimalNumber()

	def RepresentsBinaryNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInBinaryForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsABinaryNumber()
			return This.RepresentsBinaryNumber()

		def IsBinaryNumberInString()
			return This.RepresentsBinaryNumber()

		def IsBinaryNumberInAString()
			return This.RepresentsBinaryNumber()

		def IsABinaryNumberInString()
			return This.RepresentsBinaryNumber()

		def IsABinaryNumberInAString()
			return This.RepresentsBinaryNumber()

	def RepresentsOctalNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInOctalForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAnOctalNumber()
			return This.RepresentsOctalNumber()

		def IsOctalNumberInString()
			return This.RepresentsOctalNumber()

		def IsOctalNumberInAString()
			return This.RepresentsOctalNumber()

		def IsAnOctalNumberInString()
			return This.RepresentsOctalNumber()

		def IsAnOctalNumberInAString()
			return This.RepresentsOctalNumber()

	def RepresentsHexNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInHexForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAHexNumber()
			return This.RepresentsHexNumber()

		def IsHexNumberInString()
			return This.RepresentsHexNumber()

		def IsHexNumberInAString()
			return This.RepresentsHexNumber()

		def IsAHexNumberInString()
			return This.RepresentsHexNumber()

		def IsAHexNumberInAString()
			return This.RepresentsHexNumber()

	def RepresentsScientificNotationNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInScientificNotation()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAScientificNumber()
			return This.RepresentsScientificNumber()

		def IsScientificNumberInString()
			return This.RepresentsScientificNumber()

		def IsScientificNumberInAString()
			return This.RepresentsScientificNumber()

		def IsAScientificNumberInString()
			return This.RepresentsScientificNumber()

		def IsAScientificNumberInAString()
			return This.RepresentsScientificNumber()

	def NumberForm()
		if NOT This.RepresentsNumber()
			return :NotNumber

		else
 			if This.RepresentsNumberInDecimalForm()
				return :Decimal

		   	but This.RepresentsNumberInBinaryForm()
				return :Binary

		   	but This.RepresentsNumberInOctalForm()
				return :Octal

		   	but This.RepresentsNumberInHexForm()
				return :Hex

			but This.RepresentsNumberInScientificNotation()
				return :ScientificNotation
			ok
		ok

	def RepresentsNumber()

		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInDecimalForm() or
		   oCopy.RepresentsNumberInBinaryForm() or
		   oCopy.RepresentsNumberInOctalForm() or
		   oCopy.RepresentsNumberInHexForm() or
		   oCopy.RepresentsNumberInScientificNotation()
			
			return TRUE

		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumber()
			return This.RepresentsNumber()

		def RepresentsNumberInString()
			return This.RepresentsNumber()

		def RepresentsNumberInAString()
			return This.RepresentsNumber()

		def RepresentsANumberInString()
			return This.RepresentsNumber()

		def RepresentsANumberInAString()
			return This.RepresentsNumber()

		#>
	
	def RepresentsSignedNumber()
		if This.RepresentsNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedNumber()
			return This.RepresentsSignedNumber()

	def RepresentsUnsignedNumber()
		if This.RepresentsNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()		

	def RepresentsCalculableNumber() 

		if This.RepresentsCalculableInteger() or
		   This.RepresentsCalculableRealNumber()

			return TRUE

		else
			return FALSE
		ok
				 
		/* INFO
		Non calculable numbers are: 
		-  other numbers in Uniocde, like circled number icons,
		   roman and indian numbers and others

		- numbers in any form (decimal, binary, octal, hex, scientific)
		  that can not be calculated "precisily" with Ring, as defined by
		  MinCalculableNumber() and MaxCalculableNumber()
		*/

		def RepresentsACalculableNumber() 
			return This.RepresentsCalculableNumber() 

	def RepresentsInteger()
		if This.RepresentsNumber() and This.ContainsNo(".")
			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnInteger()
			return This.RepresentsInteger()

	def RepresentsSignedInteger()
		if This.RepresentsInteger() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedInteger()
			return This.RepresentsSignedInteger()

	def RepresentsUnsignedInteger()
		if This.RepresentsInteger() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

	def RepresentsCalculableInteger()

		if This.representsInteger()

			# Step 1: we define the number of digits of
			# the integer and the maximum number of digits
			# allowed by Ring for integers
			
			if This.RepresentsSignedInteger()

				nNumberOfDigits = This.NumberOfChars() - 1
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedInteger()

			else

				nNumberOfDigits = This.NumberOfChars()
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedInteger()
			ok

			# Step 2: we compare between them to kwow if this
			# integer is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		def RepresentsACalculableInteger()
			return This.RepresentsCalculableInteger()

	def RepresentsRealNumber()
		if This.RepresentsNumber() and This.Contains(".")
			return TRUE
		else
			return FALSE
		ok

		def RepresentsARealNumber()
			return This.RepresentsRealNumber()		

	def RepresentsSignedRealNumber()
		if This.RepresentsRealNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

	def RepresentsUnsignedRealNumber()
		if This.RepresentsRealNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

	def RepresentsCalculableRealNumber()
		
		if This.RepresentsRealNumber()

			# Step1: We split the string to get integer and
			# decimal parts and calculate the number of
			# digits in the real number

			cIntegerPart = This.Split(".")[1]
			nNumberOfDigitsIncIntegerPart = len(cIntegerPart)

		 	if ring_left(cIntegerPart, 1) = "+" or
			   ring_left(cIntegerPart, 1) = "-"
				nNumberOfDigitsIncIntegerPart--
			ok

			cFractionalPart = This.Split(".")[2]
			nNumberInDigitsInFractionalPart = len(cFractionalPart)

			nNumberOfDigits = nNumberOfDigitsIncIntegerPart +
					  nNumberInDigitsInFractionalPart

			# Step 2: We compute the maximum number of digits allowed
			# depending on the real number being singed or unsigned

			nMaxNumberOfDigits = 0
			if This.RepresentsSignedRealNumber()
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedRealNumber()
			else
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedRealNumber()
			ok

			# Step 3: we compare between them to kwow if this real
			# number is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		def RepresentsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

	def RepresentsNumberInDecimalForm()

		# Rule 1: String shouldn't be null

		if This.Content() = ""
			return FALSE
		ok

		# Rule 2: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" or
		    This.Content() = " ")

			return FALSE
		ok

		# Rule 3: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 4: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 5: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 6: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( "0":"9" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInDecimalForm()
			return This.RepresentsNumberInDecimalForm()

	// Checks if the string corresponds to a binary number started by the
	// prefix defined in BinaryNumberPrefix() and composed of 0s and 1s

	def RepresentsNumberInBinaryForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must contains 0s or 1s

		if This.ContainsNo("0") and This.ContainsNo("1")
			return FALSE
		ok

		# Rule 3: String should be prefixed with a binary prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cBinPrefix in BinaryPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cBinPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 4: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_")

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( "0":"1" + "b" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInBinaryForm()
			return This.RepresentsNumberInBinaryForm()

	// Checks if the string corresponds to a hex number form
	def RepresentsNumberInHexForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain just a hex prefix

		if This.IsEqualToOneOfTheseCS(HexPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 3: String should be prefixed with a hex prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cHexPrefix in HexPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cHexPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 4: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that chars correspond to digits, signs or separators

		oPossibleChars = new stzList( HexChars() + "x" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)	

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a hex number

		return TRUE

		def RepresentsANumberInHexForm()
			return This.RepresentsNumberInHexForm()

	def RepresentsNumberInUnicodeHexForm()
		if NOT This.LeftNCharsQ(2).Uppercased() = "U+"
			return FALSE
		ok
	
		if This.IsEqualToOneOfTheseCS("U", "U+")
			return FALSE
		ok

		cNumber = This.LeftNCharsRemoved(2)
	
		if IsHexNumber( HexPrefix() + cNumber )
			return TRUE
		else
			return FALSE
		ok

		def RepresentsANumberInUnicodeHexForm()
			return This.RepresentsNumberInUnicodeHexForm()

	// Checks if the string corresponds to an octal number
	def RepresentsNumberInOctalForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain only an octal prefix

		if This.IsEqualToOneOfTheseCS(OctalPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 4: String should be prefixed with an octal prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cOctalPrefix in OctalPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cOctalPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 5: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 6: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 7: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 8: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 9: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( OctalChars() + "o" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInOctalForm()
			return This.RepresentsNumberInOctalForm()

	def RepresentsNumberInScientificNotation()
		// TODO
		StzRaise("Unsupported feature yet!")

		def RepresentsANumberInScientificNotation()
			return This.RepresentsNumberInScientificNotation()

	def IsNumberFraction() # of the form "1/2" or "۱/٢" or "Ⅰ/Ⅱ" or
					  # even "一/二" (in mandarin numerals)
		bResult = FALSE

		if This.NumberOfChars() = 3
			aStzChars = This.ToListOfStzChars()
			if aStzChars[1].IsANumber() and
			   (aStzChars[2].Content() = "/" or aStzChars[2].Content() = ":") and
			   aStzChars[3].IsANumber()

				bResult = TRUE
			ok
		ok

		def IsANumberFraction()
			return This.IsNumberFraction()

		def IsNumberFractionInString()
			return This.IsNumberFraction()

		def IsANumberFractionInString()
			return This.IsNumberFraction()

	  #==============#
	 #    CHARS     #
	#==============#

	// Returns the string as a list of Chars
	def Chars()

		acResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			acResult + This.NthChar(i)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsQ()
			return This.CharsQR(:stzList)

		def CharsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Chars() )

			on :stzListOfChars
				return new stzListOfChars( This.Chars() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Chars() )
			other
				stzRaise([
					:Where = "stzString (13237) > CharsQR()",
					:What  = "Unsupported type!"
				])
			off

		#>

		#< @FunctionAlternativeForms

		def ToListOfChars()
			return This.Chars()

			#< @FunctionFluentForm

			def ToListOfCharsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.Chars() )

				on :stzListOfChars
					return new stzListOfChars( This.Chars() )

				on :stzListOfStrings
					return new stzListOfStrings( This.Chars() )

				other
					stzRaise("Unsupported type!")
				off 

			def ToListOfCharsQ()
				return This.ToListOfCharsQR(:stzListOfChars)

			def ToStzListOfChars()
				return This.ToListOfCharsQR(:stzListOfChars)


			#>
	
		#>
			
	def ToListOfStzChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
		# Warning: Note that using 'for in' yields erronous
		# result for strings coded on more then 1 byte
			aResult + This.CharQ(i)
		next
		return aResult

		#< @FunctionFluentForm

		def ToListOfStzCharsQ()
			return new stzList( This.ToListOfStzChars() )

		#>

	  #=====================================================#
	 #  CHECKING IF THE STRING IS THE NAME OF A FUNCTION   #
	#=====================================================#
	/*
	TODO: Distinguish between Ring, Softanza, Qt, and other
	libraries functions, classes, and attributes.
	*/

	def IsAFunction()
		if ring_find( functions(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok
 
		def IsAFunctionName()
			return This.IsAFunction()

		def IsFunction()
			return This.IsAFunction()

		def IsFunctionName()
			return This.IsAFunction()

		#--

		def IsFunc()
			return This.IsAFunction()

		def IsFunctName()
			return This.IsAFunction()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A CLASS   #
	#--------------------------------------------------#

	def IsAClass()
		if ring_find( classes(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok

		def IsAClassName()
			return This.IsAClass()

		def IsClass()
			return This.IsAClass()

		def IsClassName()
			return This.IsAClass()

	  #------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF AN ATTRIBUTE  #
	#------------------------------------------------------#

	def IsAnAttributeOfClass(pcClass)
		acTheseAttributes = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Attributes )
		bResult = This.ExistsInCS( acTheseAttributes, :CS = FALSE )
		return bResult

		def IsAnAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOfClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A METHOD  #
	#--------------------------------------------------#

	def IsAMethodOfClass(pcClass)
		acTheseMethods = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Methods )
		bResult = This.ExistsInCS( acTheseMethods, :CS = FALSE )
		return bResult

		def IsAMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOfClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

	  #========================================#
	 #      CHECKING IF ALL CHARS ARE ...     #
	#========================================#

	def AllCharsAreNumbers()
		nLen = This.NumberOfChars()

		if nLen = 0 or (nLen = 1 and NOT This.FirstCharQ().IsANumber() )
			return FALSE
		ok

		bResult = TRUE
		
		for i = 1 to nLen
			if NOT This.CharQ(i).IsANumber()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def IsMadeOfNumbers()
			return This.AllCharsAreNumbers()

	def AllCharsAre(pDescriptor)
		/* EXAMPLE

		? Q("248").AllCharsAre([ :Even, :Positive, :Numbers ])
		#--> TRUE

		? Q("248").AllCharsAre([ :Even, W('Q(@char).IsANumber()'), :Numbers ])
		#--> TRUE

		? Q(",:;").AllCharsAre(:Punctuations)

		*/

		if isString(pDescriptor)
			return This.AllCharsAreXT([ pDescriptor ], :EvalDirection = :Nothing)

		but isList(pDescriptor) and Q(pDescriptor).IsListOfStrings()
			return This.AllCharsAreXT(pDescriptor, :EvalDirection = :Nothing)

		ok	

	def AllCharsAreXT(pacDescriptors, paEvalDirection)

		if NOT ( isList(pacDescriptors) and Q(pacDescriptors).IsListOfStrings() )
			stzRaise("Incorrect param type! pacDescriptors must be a list of strings.")
		ok

		if isList(paEvalDirection) and
		   Q(paEvalDirection).IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if NOT Q(paEvalDirection).IsOneOfTheseCS([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], :CS = FALSE)

			stzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if Q(paEvalDirection).IsEither(:Default, :Or = :Nothing)
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		acDescriptors = pacDescriptors
		if Q(paEvalDirection).IsOneOfTheseCS([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			], :CS = FALSE)

			acDescriptors = Q(acDescriptors).Reversed()
		ok

		if len(acDescriptors) = 1
			if acDescriptors[1] = :Number or acDescriptors[1] = :Numbers
				cMethod = :IsANumber

			but acDescriptors[1] = :String or acDescriptors[1] = :Strings
				cMethod = :IsAString

			but acDescriptors[1] = :List or acDescriptors[1] = :Lists
				Method = :IsAList

			but acDescriptors[1] = :Object or acDescriptors[1] = :Objects
				cMethod = :IsAnObject

			but Q(acDescriptors[1]).FirstChar() = "{" and
			    Q(acDescriptors[1]).LastChar() = "}"

				bResult = This.Check( :That = acDescriptors[1] )
				return bResult
			
			else

				cMethod = Q(acDescriptors[1]).InfereMethod(:From = :stzChar)

			ok

			bResult = This.Check( :That = 'StzCharQ(@char).' + cMethod + "()" )

		else

			cType = Q(acDescriptors[1]).InfereType()
			if Q(cType).StartsWithCS("stz", :CS = FALSE)
				cType = Q(cType).FirstNCharsRemoved(3)
			ok

			bResult = TRUE
	
			for i = 2 to len(acDescriptors)

 				if Q(acDescriptors[i]).FirstChar() = "{" and
			   	   Q(acDescriptors[i]).LastChar() = "}"

					bOk = This.Check( :That = acDescriptors[i] )
				
				else

					cMethod = Q(acDescriptors[i]).InfereMethod( :From = 'stz' + cType )
					bOk = This.Check( :That = 'Stz' + cType + 'Q(@item).' + cMethod + "()" )
				ok

				if bOk = FALSE
					bResult = FALSE
					exit
				ok
			next
		ok

		return bResult

	  #========================================#
	 #   CHARS VERIFYING A GIVEN CONDITION    #
	#========================================#
	
	def CharsW(pcCondition)
		aResult = This.YieldW('@char', pcCondition)
		return aResult

		def CharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsW(pcCondition)
			return This.CharsW(pcCondition)

		def OnlyW(pcCondition)
			return This.CharsW(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsW(pcCondition)
			return This.CharsW(pcCondition)

		def ItemsWhere(pcCondition)
			return This.CharsW(pcCondition)

	  #-------------------------------------------------------#
	 #      NUMBER OF CHARS VERIFYING A GIVEN CONDITION      #
	#-------------------------------------------------------#

	def NumberOfCharsW(pcCondition)
		return len( This.CharsW(pcCondition) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def NumberOfItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		#>

	  #-----------------------#
	 #   STRING IS A CHAR?   #
	#-----------------------#

	def IsChar()
		if This.NumberOfChars() = 1
			return TRUE
		else
				
			return FALSE
		ok

		def IsAChar()
			return This.IsChar()

	def IsNullOrChar()
		return isNull(This.Content()) or This.IsChar()

		def IsCharOrNull()
			return This.IsNullOrChar()

		def IsEmptyOrChar()
			return This.IsNullOrChar()

		def IsCharOrEmpty()
			return This.IsNullOrChar()

	def IsAsciiChar()
		if This.Unicode() <= 255
			return TRUE
		else
			return FALSE
		ok

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		def IsAnAsciiChar()
			return This.IsAsciiChar()

	def IsCharName()
		return StzunicodeDataQ().ContainsCharName( This.Uppercased() )

		def IsACharName()
			return This.IsCharName()

	  #---------------------------#
	 #   STRING MADE OF CHARS?   #
	#---------------------------#

	def IsMadeOfChar(c)
		if ( NOT This.IsEmpty() ) and  StringIsChar(c)
			return This.IsMadeOf([ c ])
		else
			return FALSE
		ok

	def IsMadeOfSome(acSubstrings)
		oCopy = This.Copy()
		
		# TODO: Replace for/in with for --> better performance
		for cSubstr in acSubstrings
			if This.Contains(cSubStr)
				oCopy.RemoveAll(cSubStr)
			ok
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		return FALSE

		def IsMadeOfSomeOfThese(acSubstrings)
			return This.IsMadeOfSome(acSubstrings)

		def IsMadeOfSomeOfTheseSubstrings(acSubstrings)
			return This.IsMadeOfSome(acSubstrings)

	def IsMadeOfSomeOfTheseChars(acChars)
		if ListIsListOfChars(acChars)
			return This.IsMadeOfSome(acChars)
		else
			stzRaise("You must provide a list of chars!")
		ok

	   #------------------------------------------------#
	 #   STRING IS A CHAR IN A COMPUTABLE FORM ("c")   #
	#-------------------------------------------------#

	def IsCharInComputableForm()
		if This.IsChar() and This.IsInComputableForm()
			return TRUE
		else
			return FALSE
		ok

	def IsAsciiCharInString()
		if This.NumberOfChars() = 3 and
		   (This.IsBoundedBy("'", "'") or
		   This.IsBoundedBy('"', '"'))
			return StzStringQ(This[2]).IsAsciiChar()
		else
			return FALSE
		ok

	  #------------------#
	 #   UNIQUE CHARS   #
	#------------------#

	def UniqueCharsCS(pCaseSensitive)
		acResult = This.CharsQR(:stzListOfStrings).DuplicatesRemovedCS(pCaseSensitive)
		return acResult

		#< @FunctionFluentForms

		def UniqueCharsCSQ(pCaseSensitive)
			return This.UniqueCharsQRCS(:stzList, pCaseSensitive)

		def UniqueCharsQRCS(pcReturnTyp, pCaseSensitivee)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueCharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionALternativeForm

		def ToSetOfCharsCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)
	
			def ToSetOfCharsCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)
	
			def ToSetOfCharsCSQR(pcReturnType, pCaseSensitive)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)
	
		def CharsUCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsUCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsUCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)

		def CharsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicationCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicationCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)

		#>

	  #-----------------------------#
	 #  REMOVING DUPLICATED CHARS  #
	#-----------------------------#

	def RemoveDuplicatedChars()
		cNewString = This.UniqueCharsQR(:stzListOfStrings).Concatenated()
		This.Update(cNewString)

		def RemoveDuplicatedCharsQ()
			This.RemoveDuplicatedChars()
			return This
	
	def DuplicatedCharsRemoved()
		cResult = This.Copy().RemoveDuplicatedCharsQ().Content()
		return cResult

	  #---------------------------------------#
	 #   GETTING CHAR AT A GIVEN POSITION    #
	#---------------------------------------#
	
	def NthChar(n)
		#< QtBased | Uses QString.mid() >

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		cResult = ""
		nLen = This.NumberOfChars()

		if n = 0 or n > nLen
			return cResult
		ok

		if n < 0
			n = nLen + n + 1
		ok

		cResult = @oQString.mid(n-1, 1)
		return cResult

		#< @FunctionFluentForm
		
		def NthCharQ(n)
			return This.NthCharQR(n, :stzString)

		def NthCharQR(n, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NthChar(n) )
			on :stzChar
				return new stzChar( This.NthChar(n) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
		#< @FunctionAlternativeForms

		def CharAt(n)
			return This.NthChar(n)

			def CharAtQR(n, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.NthCharQR(n, pcReturnType)
	
			def CharAtQ(n)
				return This.CharAtQR(n, :stzString)

		def CharAtPosition(n)
			return This.NthChar(n)

			def CharAtPositionQR(n, pcReturnType)
				return This.CharAtQR(n, pcReturnType)

			def CharAtPositionQ(n)
				return This.CharAtPositionQR(n, :stzString)

		def CharN(n)
			return This.NthChar(n)

			def CharNQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharNQ(n)
				return This.CharAtQR(n, :stzString)

		def Char(n)
			return This.NthChar(n)

			def CharQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharQ(n)
				return This.CharAtQR(n, :stzString)

		#>

	  #-------------------------------------------------#
	 #   NTH CHAR TO THE LAST (OR TO THE FIRST) CHAR   #
	#-------------------------------------------------#

	def NthToLast(n)
		return This.CharAtPosition( This.NumberOfChars() - n )

	def NthToFirst(n)
		return This.CharAtPosition(n + 1)

	  #--------------------------------#
	 #   CHARS AT A GIVEN POSITIONS   #
	#--------------------------------#
	
	def CharsAtPositions(panPositions)
		if NOT ( isList(panPositions) and Q(panPositions).IsListofNumbers() )
			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		acResult = []

		# TODO: Replace for/in with for --> better performance
		for n in panPositions
			acResult + This.CharAt(n)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsAtPositionsQ(panPosirtions)
			return This.CharsAtPositionsQR(panPositions, :stzList)

		def CharsAtPositionsQR(panPositions, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def CharsAtThesePositons(panPositions)
			return This.CharsAtPositions(panPositions)

			def CharsAtThesePositionsQ(panPositions)
				return This.CharsAtQR(panPositions, :stzList)

			def CharsAtThesePositionsQR(panPositions, pcReturnType)
				return This.CharsAtPositionsQR(panPositions, pcReturnType)

		def CharsAt(panPositions)
			return This.CharsAtPositions(panPositions)

			def CharsAtQ(panPositions)
				return This.CharsAtQR(panPositions, :stzList)

			def CharsAtQR(panPositions, pcReturnType)
				return This.CharsAtPositionsQR(panPositions, pcReturnType)

		#>

	  #---------------------------#
	 #   FIRST AND LAST CHARS    #
	#---------------------------#
		
	def FirstChar()
		return This[1]

		#< @FunctionFluentForm

		def FirstCharQ()
			return This.FirstCharQR(:stzString)

		def FirstCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.FirstChar() )
			on :stzChar
				return new stzChar( This.FirstChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def SecondChar()
		return This.Char(2)

		def SecondCharQ()
			return This.SecondCharQR(:stzString)

		def SecondCharQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNameSpace()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsAStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcreturnType
			on :stzString
				return new stzString( This.SecondChar() )

			on :stzChar
				return new stzChar( This.SecondChar() )

			other
				StzRaise("Unsupported return type!")
			off

	def LastChar()
		return This[ This.NumberOfChars() ]

		#< @FunctionFluentForm

		def LastCharQ()
			return This.LastCharQR(:stzString)

		def LastCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LastChar() )
			on :stzChar
				return new stzChar( This.LastChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForms

		def الحرف_الأخير()
			return This.LastChar()

			def oالحرف_الأخير()
				return This.LastChar()
	
		def DernierCaractère()
			return This.LastChar()


		def 字符数()
			return This.LastChar()

		#>

	  #---------------------------#
	 #   LEFT AND RIGHT CHARS    #
	#---------------------------#
		
	def LeftChar()
		if This.IsLeftToRight()
			return This.FirstChar()
		else
			return This.LastChar()
		ok

		#< @FunctionFluentForm

		def LeftCharQ()
			return This.LeftCharQR(:stzString)

		def LeftCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LeftChar() )
			on :stzChar
				return new stzChar( This.LeftChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def RightChar()
		if This.IsLeftToRight()
			return This.LastChar()
		else
			return This.FirstChar()
		ok

		#< @FunctionFluentForm

		def RightCharQ()
			return This.RightCharQR(:stzString)

		def RightCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.RightChar() )
			on :stzChar
				return new stzChar( This.RightChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

	  #-----------------------#
	 #   NUMBER OF CHARS     #
	#-----------------------#

	/* TODO
	Reimplement these functions using QTextBoundaryFinder
	https://doc.qt.io/qt-5/qtextboundaryfinder.html#details
	*/

	def NumberOfCharsCS(pCaseSensitive)
		#< QtBased | Uses QString.count() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		if pCaseSensitive = TRUE
			return @oQString.count()

		else
			return len( This.UniqueChars() )
		ok

		#< @FunctionFluentForm

		def NumberOfCharsCSQ(pCaseSensitive)
			return new stzNumber(This.NumberOfCharsCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def SizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def NumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def CountCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def HowManyCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def HowManyCharCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NuberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfChars()
		return This.NumberOfCharsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumberOfCharsQ()
			return new stzNumber(This.NumberOfChars())

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfChars()

		def SizeInChars()
			return This.NumberOfChars()

		def LengthInChars()
			return This.NumberOfBytes()


		def NumberOfItems()
			return This.NumberOfChars()

		def Length()
			return This.NumberOfChars()

		def CountChars()
			return This.NumberOfChars()

		def HowManyChars()
			return This.NumberOfChars()

		def HowManyChar()
			return This.NumberOfChars()

		#>

		#< @FunctionMisspelledForm

		def NuberOfChars()
			return This.NumberOfChars()

		#>

	  #-----------------------#
	 #   NUMBER OF LETTERS   #
	#-----------------------#

	def NumberOfLetters()
		return len(This.OnlyLetters())
	
		#< @FunctionAlternativeForms

		def CountLetters()
			return This.NumberOfLetters()

		def HowManyLetters()
			return This.NumberOfLetters()

		def HowManyLetter()
			return This.NumberOfLetters()

		#>

	  #-----------------------#
	 #   NUMBER OF SPACES    #
	#-----------------------#

	def NumberOfSpaces()
		return len(This.FindAll(" "))

		#< @FunctionAlternativeForms

		def CountSpaces()
			return This.NumberOfSpaces()

		def HowManySpaces()
			return This.NumberOfSpaces()

		def HowManySpace()
			return This.NumberOfSpaces()

		#>

	  #---------------------------------------#
	 #   ِCHEKING IF THE STRING IS A LETTER   #
	#---------------------------------------#

	def IsLetter()
		if This.IsChar() and StzCharQ(This.Content()).IsLetter()
			return TRUE
		else
			return FALSE
		ok
		
		#< @FunctionAlternativeForms

		def IsALetter()
			return This.IsLetter()

		def ContainsJustALetter()
			return This.IsLetter()

		def ContainsOnlyALetter()
			return This.IsLetter()

		#>

		#< @FunctionNegativeForm

		def IsNotLetter()
			return NOT This.IsLetter()

		def IsNotALetter()
			return NOT This.IsLetter()

		#>

	  #----------------------------------------------------------#
	 #   ِCHEKING IF THE STRING IS A LETTER OF AN OTHER STRING   #
	#----------------------------------------------------------#

	def IsLetterOf(pcOtherStr)
		if This.IsLetter() and Q(pcOtherStr).ContainsLetter(This.Content())
			return TRUE
		else
			return FALSE
		ok

		def IsALetterOf(pcOtherStr)
			return This.IsLetterOf(pcOtherStr)

	  #-----------------------------------------------#
	 #   ِGETTING THE LIST OF LETTERS IN THE STRING   #
	#-----------------------------------------------#

	def Letters()
		aoChars = This.CharsQ().ToListOfStzStrings()
		nLen = len(acChars)
		aResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				aResult + aoChars[i].Content()
			ok
		next

		return aResult

		def LettersQ()
			return This.LettersQR(:stzList)

		def LettersQR(pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.Letters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Letters() )

			on :stzListOfChars
				return new stzListOfChars( This.Letters() )
			off

	  #----------------------------------------------------------------------#
	 #   ِGETTING THE LIST OF LETTERS IN THE STRING  -- WITHOUT DUPLICATION  #
	#----------------------------------------------------------------------#

	def UniqueLetters()
		acResult = This.LettersQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForms

		def UniqueLettersQ()
			return This.UniqueLettersQR(:stzList)

		def UniqueLettersQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueLetters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueLetters() )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueLetters() )
			off

		#>

		#< @FunctionAlternativeForms

		def LettersU()
			return This.UniqueLetters()

			def LettersUQ()
				return This.LettersUQR(:stzList)

			def LettersUQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
	
		def LettersWithoutDuplication()
			return This.UniqueLetters()

			def LettersWithoutDuplicationQ()
				return This.LettersWithoutDuplicationQR(:stzList)

			def LettersWithoutDuplicationQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
		#

	  #----------------------------------------------------------------------#
	 #    CHECKING IF THE STRING IS IN A COMPUTABLE FORM ("str" or 'str')   #
	#----------------------------------------------------------------------#

	def IsInComputableForm()
		if This.NumberOfChars() > 2 and
		   (This.IsBoundedBy("'", "'") or
		    This.IsBoundedBy('"', '"'))

			return TRUE
		else
			return FALSE
		ok
	
		def IsWellFormed()
			return This.IsInComputableForm()

	  #------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN SUBSTRINGS   #
	#------------------------------------------------------------#

	def IsMadeOfCS(acSubStr, pCaseSensitive)
		IF NOT ( isList(acSubStr) and Q(acSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! acSubStr must be a list of strings.")
		ok

		oCopy = This.Copy()
		
		nLen = len(acSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(acSubStr[i], pCaseSensitive)
				return FALSE
			ok

			oCopy.RemoveAllCS(cSubStr, pCaseSensitive)
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		def IsMadeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			This.IsMadeOfCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOf(acSubStr)
		return This.IsMadeOfCS(acSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfThese(acSubStr)
			return This.IsMadeOf(acSubStr)

		def IsMadeOfTheseSubstrings(acSubStr)
			This.IsMadeOf(acSubStr)

		#>

	  #-------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN CHARS   #
	#-------------------------------------------------------#

	def IsMadeOfTheseCharsCS(acChars, pCaseSensitive)
		if ListIsListOfChars(acChars)
			return This.IsMadeOfCS(acChars, pCaseSensitive)
		else
			stzRaise("You must provide a list of chars!")
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfTheseChars(acChars)
		return This.IsMadeOfTheseCharsCS(acChars, :CaseSensitive = TRUE)

	  #---------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF LETTERS  #
	#---------------------------------------------#

	def IsMadeOfLetters()
		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			if This.CharQ(i).IsNotALetter()
				bResult = FALSE
				exit
			ok
		next

		return bResult

	  #-----------------------------------------------#
	 #   CHEKCIKNG IF THE STRING IS MADE OF SPACES   #
	#-----------------------------------------------#
	
	def IsMadeOfSpaces()
		if This.NumberOfSpaces() = This.NumberOfChars()
			return TRUE
		else
			return FALSE
		ok

		def IsBlank()
			return This.IsMadeOfSpaces()

	  #-----------------#
	 #   MULTIPLY BY   #	TODO: reclassify it with other calculations
	#-----------------#

	def Multiply(paByValue)
		if isList(paByValue) and Q(paByValue).IsByNamedParam()
			paByValue = paByValue[2]
		ok

		This.MultiplyBy(paByValue)

	def MultiplyBy(pValue)
		cResult = NULL

		if ring_type(pValue) = "NUMBER"
			cResult = This.RepeatedNTimes(pValue)
		
		but ring_type(pValue) = "STRING"

			if pValue = NULL { return NULL }

			cResult = NULL
			cTemp = NULL

			for i = 1 to This.NumberOfChars()
				cTemp = @oQString.mid(i-1,1) + pValue
				cResult += cTemp
			next
		
		but ring_type(pValue) = "LIST"
			aValue = pValue // just for expressivity
			cResult = ""
			cTemp = ""
				
			for i = 1 to This.NumberOfChars()
				for v = 1 to len(aValue)
					cTemp = @oQString.mid(i-1,1) + aValue[v]
					cResult += cTemp 
				next
										
				if i != NumberOfChars() // avoiding adding space at the end
					cResult += " "
				ok
			next
		ok

		This.Update( cResult )

		#< @FunctionFluentForm

		def MultiplyByQ(pValue)
			This.MultiplyBy(pValue)
			return This

		#>

	  #========================================#
	 #     BOXING THE STRING AND ITS CHARS    #
	#========================================#
	
	def Box() # Undersatnd it as a verb action on the string (boxing the string)

		return This.BoxXT([])

		#< @FunctionFluentForm

		def BoxQ()
			return new stzString( This.Box() )
		#>

		def Boxed()
			return This.BoxQ().Content()

	def BoxDashed()
		return This.BoxXT([ :Line = :Dashed ])

		#< @FunctionFluentForm

		def BoxDashedQ()
			return new stzString( This.BoxDashed() )
		#>

		def BoxedDashed()
			return This.BoxDashedQ().Content()

	def BoxRound()
		return This.BoxXT([ :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundQ()
			return new stzString( This.BoxRound() )
		#>

		def BoxedRound()
			return This.BoxRoundQ().Content()

	def BoxRoundDashed()
		return This.BoxXT([ :Line = :Dashed, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundDashedQ()
			return new stzString( This.BoxRoundDashed() )
		#>

		def BoxedRoundDashed()
			return This.BoxRoundDashedQ().Content()

	def BoxDashedRound()
		return This.BoxRoundDashed()

		#< @FunctionFluentForm

		def BoxDashedRoundQ()
			return new stzString( This.BoxDashedRound() )
		#>

		def BoxedDashedRound()
			return This.BoxDashedRoundQ().Content()

	def BoxEachChar()
		return This.BoxXT([ :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharQ()
			return new stzString( This.BoxEachChar() )
		#>

		def EachCharBoxed()
			return This.BoxEachCharQ().Content()

	def BoxEachCharRound()
		return This.BoxXT( [ :AllCorners = :Round, :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharRoundQ()
			return new stzString( This.BoxEachCharRound() )
		#>

		def EachCharboxedRound()
			return This.BoxEachCharRoundQ().Content()

	def BoxEachCharXT(paBoxOptions)
		if StzHashListQ(paBoxOptions).ContainsKey( :EachChar )
			paBoxOptions = StzHashListQ(paBoxOptions).UpdateValueByKeyQ( :EachChar, TRUE ).Content()
		else
			paBoxOptions = StzHashListQ(paBoxOptions).AddPairQ( :EachChar = TRUE ).Content()
		ok

		return This.BoxedXT(paBoxOptions)

		#< @FunctionFluentForm

		def BoxEachCharXTQ(paBoxOptions)
			return new stzString( This.BoxedEachCharXT(paBoxOptions) )

		#>

		def EachCharBoxedXT(paBoxOptions)
			return This.BoxEachCharXTQ(paBoxOptions).Content()

	def BoxXT(paBoxOptions)

		/*
		Example:

		? StzStringQ("TEXT1").BoxXT([

			:Line = :Thin,	# or :Dashed
		
			:AllCorners = :Round, # can also be :Rectangualr
			# :Corners = [ :Round, :Rectangular, :Round, :Rectangular ],
		
			:TextAdjustedTo = :Center # or :Left or :Right or :Justified

		]).Content()

		--> Gives:
		╭───────────────╮
		│     TEXT1     │ 
		╰───────────────╯

		The list of possible options, as you find inforced in
		stzList.IsTextBoxedOptionsNamedParam(), are:

			aListOfBoxOptions = [
				# General options
				:Line,
				:AllCorners,
				:Corners,
				:Width,
				:TextAdjustedTo,

				# Options speciefic to list of chars and words
				:EachChar,
				:EachWord,
				:Hilighted,
				:HilightedIf,
				:Numbered
			]

		*/

		if StzListQ(paBoxOptions).IsTextBoxedOptionsNamedParam()

			# Reading the type of line (thin or dashed)

			cLine = :Thin # By default

			if paBoxOptions[ :Line ] = :Dashed
				cLine = :Dashed
			ok

			# Reading the type of corners (rectangualr or round)

			cAllCorners = :Rectangular # By default

			if paBoxOptions[ :AllCorners ] = :Round
				cAllCorners = :Round
			ok

			aCorners = []
			if cAllCorners = :Rectangular
				 # By default
				aCorners = [ :Rectangular, :Rectangular, :Rectangular, :Rectangular ]

			but cAllCorners = :Round
				aCorners = [ :Round, :Round, :Round, :Round ]

			ok

			if len(paBoxOptions[:Corners]) = 4 and
			   StzListQ( paBoxOptions[:Corners] ).IsMadeOfSome([ :Rectangular, :Round ])
	
				aCorners = paBoxOptions[:Corners]

			ok

			# If the boxing happens at the char level, delegate it
			# to the stzListOfChars class

			if paBoxOptions[ :EachChar ] = TRUE

				return StzListOfCharsQ( This.String() ).BoxedXT(paBoxOptions)
			ok

			# If the boxing happens at the word level, delegate it
			# to the stzListOfStrings class

			if paBoxOptions[ :EachWord ] = TRUE
				return This.ToListOfStringsQ().Boxed(paBoxOptions)
			ok

			# Reading the width of the box in number of chars

			nWidth = This.NumberOfChars() + 2 # By default

			if isNumber(paBoxOptions[:Width]) and
			   paBoxOptions[:Width] > This.NumberOfChars() + 2

				nWidth = paBoxOptions[:Width]
			ok

			# Reading the text adjustment option

			cTextAdjustedTo = :Center # By default

			oString = new stzString( paBoxOptions[ :TextAdjustedTo ] )
			if oString.IsOneOfThese([ :Left, :Center, :Right, :Justified ])

				cTextAdjustedTo = paBoxOptions[ :TextAdjustedTo ]
			ok
 
			# Composing the box

			cVTrait  = "│"

			cHTrait  = "─"

			if cLine = :Dashed
				cHTrait = "╌"
				cVTrait = "┊"
			ok
			
			
			cCorner1 = "┌"
			cCorner2 = "┐"
			cCorner3 = "┘"
			cCorner4 = "└"

			if  aCorners[1] = :Round
				cCorner1 = "╭"
			ok

			if aCorners[2] = :Round
				cCorner2 = "╮"
			ok

			if aCorners[3] = :Round
				cCorner3 = "╯"
			ok

			if aCorners[4] = :Round
				cCorner4 = "╰"
			ok

			cUpLine = cCorner1 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner2 

			
			cMidLine = cVTrait + " " +
				   This.AlignXTQ(nWidth - 2, " ", cTextAdjustedTo).Content() +
				   " " +
				   cVTrait

			cDownLine = cCorner4 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner3 

			return cUpLine + NL + cMidLine + NL + cDownLine

		but isList(paBoxOptions) and len(paBoxOptions) = 0
			# Do nothing, takes default options for boxing

		else
			stzRaise(stzStringError(:CanNotBoxTheString))
		ok

		#< @FunctionFluentForm

		def BoxedXTQ(paBoxOptions)
			return new stzString( This.BoxXT(paBoxOptions) )

		#>

		def BoxedXT(paBoxOptions)
			return This.BoxXT(paBoxOptions)

	  #=================================================#
	 #   STRING EXISTENCE AS AN ITEM IN A GIVEN LIST   #
	#=================================================#

	def ExistsInListCS(paList, pCaseSensitive)

		if NOT isList(paList)
			stzRaise("Incorrect param! paList must be a list.")
		ok

		bResult = FALSE
		nLen = len(paList)

		for i = 1 to nLen
			item = paList[i]
			if isString(item) and Q(item).IsEqualToCS( This.String(), pCaseSensitive )
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ExistsAsItemInListCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheseCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

	#--

	def ExistsInList(paList)
		return This.ExistsInListCS(paList, :CaseSensitive = TRUE)

		def ExistsAsItemInList(paList)
			return This.ExistsInList(paList)

		def IsOneOfThese(paList)
			return This.ExistsInList(paList)

		def IsOneOf(paList)
			return This.ExistsInList(paList)

		def IsOneOfThe(paList)
			return This.ExistsInList(paList)

	  #====================================================#
	 #  CHECHKING IF THE STRING IS EQUAL TO VAL1 OR VAL2  #
	#====================================================#
	// TODO: Add same function to other classes

	def IsEitherCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and Q(pcStr2).IsOrNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.IsOneOfTheseCS([ pcStr1, pcStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsEither(pcStr1, pcStr2)
		return This.IsEitherCS(pcStr1, pcStr2, :CaseSensitive = TRUE)

	  #=============================================#
	 #  MOVING CHAR AT POSITION N1 TO POSITION N2  #
	#=============================================#
	# TODO: Should be generalized to move hole substrings not only chars

	def Move(n1, n2)

		# Checking params correctness

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedParams([
			:From, :FromPosition,
			:At, :AtPosition,
			:Char, :CharAt, :CharAtPosition,
			:FromCharAt, :FromCharAtPosition,
			:CharFrom, :CharFromPosition
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToChar, :ToPosition, :ToPositionOfChar,
				:ToCharAt, :ToCharAtPosition ])

			n2 = n2[2]
		ok

		if isString(n1) and
		   Q(n1).IsOneOfThese([ :First, :FirstPosition, :FirstChar ])
				    
			n1 = 1
		ok

		if isString(n2) and
		   Q(n1).IsOneOfThese([ :Last, :LastPosition, :LastChar ])

			n2 = This.NumberOfItems()
		ok

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		# Doing the job
		
		if n1 > n2
		# . . . 2 . . 1 . .
		#       ^     |
		#       |_____|

			cTempChar = This[n1]
			This.RemoveCharAtPosition(n1)
			This.InsertBefore(n2, cTempChar)

		but n1 < n2
		# . . . 1 . . 2 . .
		#       |     ^
		#       |_____|

			cTempChar = This[n1]

			if n2 = This.NumberOfItems()
				This.AddChar(cTempChar)
			else
				This.InSertAfter(n2, cTempChar)
			ok

			This.RemoveCharAt(n1)
		ok

		#< @FunctionAlternativeForm

		def MoveChar(n1, n2)
			This.Move(n1, n2)

		#>

	  #=========================================#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if BothAreStrings(n1, n2)
			This.SwapSubStrings(n1, n2)
			return
		ok

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedPArams([
			:Between, :BetweenPosition, :BetweenPositions,
			:BetweenChar, :BetweenChars,
			:BetweenCharAt, :BetweenCharAtPosition, :BetweenCharAtPositions,
			:Position, :Positions, :CharAt, :CharAtPosition, :CharAtPositions,
			:CharsAt, :CharsAtPosition, :CharAtPositions
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedPArams([
			:And, :AndPosition, :AndCharAt, :AndCharAtPosition, :AndChar ])

			n2 = n2[2]
		ok

		copy = This[n2]
		This.ReplaceCharAtPosition(n2, :By = This[n1])
		This.ReplaceCharAtPosition(n1, :By = copy)

		#< @FunctionFluentForm

		def SwapQ(n1, n2)
			This.Swap(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenQ(n1, n2)
				This.SwapBetween(n1, n2)
				return This

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenPositionsQ(n1, n2)
				This.SwapBetweenPositions(n1, n2)
				return This

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapItemsQ(n1, n2)
				This.SwapItems(n1, n2)
				return This

		def SwapChar(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndCharAt, :AndCharAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapCharQ(n1, n2)
				This.SwapChar(n1, n2)
				return This

		def SwapChars(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsQ(n1, n2)
				This.SwapChars(n1, n2)
				return This

		def SwapCharsAtPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsAtPositionsQ(n1, n2)
				This.SwapCharsAtPositions(n1, n2)
				return This

		#>

	  #-----------------------------------------#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TWO, ONE, THREE!")
		o1.SwapSubStrings("TWO", "ONE")

		? o1.Content()
		#--> ONE, TWO, THREE!

		*/

		if isList(pcSubStr2) and Q(pcSubStr2).IsOneOfThese([ :And, :With, :By ])
			pcSubStr2 = pcSubStr2[2]
		ok

		if NOT This.ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			StzRaisr("Incorrect param types! Both pcSubStr1 and pcSubStr2 must be strings.")
		ok

		# NOTE: if the string contains more then one occurrence form a substring,
		# then only the first occurence is considered

		aSectionSubStr1 = This.FindAsSectionsCS(pcSubStr1, pCaseSensitive)[1]
		aSectionSubStr2 = This.FindAsSectionsCS(pcSubStr2, pCaseSensitive)[1]

		This.ReplaceSection(aSectionSubStr1[1], aSectionSubStr1[2], pcSubStr2)
		This.ReplaceSection(aSectionSubStr2[1], aSectionSubStr2[2], pcSubStr1)

		def SwapSubStringsCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			This.SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStrings(pcSubStr1, pcSubStr2)
		This.SwapSubStringsCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def SwapSubStringsQ(pcSubStr1, pcSubStr2)
			This.SwapSubStrings(pcSubStr1, pcSubStr2)
			return This

	  #==================================#
	 #   REVERSING THE ORDER OF CHARS   #
	#==================================#

	def ReverseCharsOrder()
		cInversed = ""
		nLen = This.NumberOfChars()
		acReversed = []

		for i = nLen to 1 step -1
			cInversed += This.@oQString.mid(i-1, 1)
		next

		This.Update( cInversed )

		#< @FunctionFluentForm

		def ReverseCharsOrderQ()
			This.ReverseCharsOrder()
			return This
	
		#>

		#< @FunctionAlternativeForm

		def Reverse() # To stay consistent with Ring that has reverse() function
			This.ReversecharsOrder()

			def ReverseQ()
				This.Reverse()
				return This

		def ReverseChars()
			This.ReversecharsOrder()

			def ReverseCharsQ()
				This.ReverseChars()
				return This

		def ReverseOrder()
			This.ReversecharsOrder()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		#>

	def CharsOrderReversed()
		cResult = This.Copy().ReverseCharsOrderQ().Content()
		return cResult


		#< @FunctionAlternativeForm

		def Reversed()
			return This.CharsOrderReversed()

		def CharsReversed()
			return This.CharsOrderReversed()

		def OrderReversed()
			return This.CharsOrderReversed()

		#>

	  #-----------------------------------------------------------#
	 #   INVERTING CHARS OF THE STRING (IF POSSIBLE IN UNICODE)  #
	#-----------------------------------------------------------#

	# Inverting (or turning) chars and strings
	# NOTE: In the meantime, Softanza uses Invert()
	# and Turn() as alternatives, but this should
	# change in the future to cope with their exact
	# meaning in Unicode!

	# NOTE: This is different from REVERSE() that Softanza
	# uses conforming to its Ring meaning (reversing the order
	# of the chars). See examples below to see how...

	def Invert()
		/*
		Example:
		? StzStringQ("LIFE").Turned()
		#--> ƎℲI⅂
		*/

		# NOTE: Applies to latin script only

		if NOT This.ToStzText().ScriptIs(:Latin)
			return This.String()
		ok

		cResult = ""

		for i = 1 to This.NumberOfChars()
			cResult += StzCharQ( This.NthChar(i) ).Inverted()
		next

		This.Update( cResult )

		#< @FunctionFluentForm

		def InvertQ()
			This.Invert()
			return This

		def InvertChars()
			This.Invert()

			def InvertCharsQ()
				This.InvertChars()
				return This
		#>

		#< @FunctionAlternativeForm

		def Turn()
			This.Invert()

			def TurnQ()
				This.Turn()
				return This

		def TurnChars()
			This.Invert()

			def TurnCharsQ()
				This.TurnChars()
				return This

		#>

	def Inverted()
		return This.Copy().InvertQ().Content()

		#< @FunctionAlternativeForms

		def CharsInverted()
			return This.Inverted()

		def Turned()
			return This.Inverted()

		def CharsTurned()
			return This.Inverted()

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF INVERTED (TURNED) CHARS  #
	#-------------------------------------------------------------#

	def IsInverted()
		bResult = TRUE

		for c in This.String()
			if NOT StzCharQ(c).IsInverted()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def CharsAreInverted()
			return This.IsInverted()

		def IsTurned()
			return This.IsInverted()

		def CharsAreturned()
			return This.IsInverted()

		#>

	  #========================#
	 #   HASHING THE STRING   #
	#========================#
	
	# Currently we use the native hashing functions of Ring StdLib
	# TODO: other algortithms can be added through RingQt

	def Hash(pcHashingAlgo)
		if isList(pcHashingAlgo) and Q(pcHashingAlgo).IsWithOrUsingOrByNamedParam()
			pcHashingAlgo = pcHashingAlgo[2]
		ok

		if NOT isString(pcHashingAlgo)
			StzRaise("Incorrect param type! pcHashingAlgo must be a string.")
		ok

		if NOT Q(pcHashingAlgo).IsOneOfThese([ :MD5, :SHA1, :SHA256, :SHA512, :SHA384, :SHA224 ])
			StzRaise("Unsupported hashing algorithm! Allowed values are :MD5, :SHA1, :SHA256, :SHA512, :SHA384 and :SHA224.")
		ok

		cHashed = ""

		switch pcHashingAlgo

		on :MD5
			cHashed = md5( This.String() )

		on :SHA1
			cHashed = sha1( This.String() )

		on :SHA256
			cHashed = sha256( This.String() )

		on :SHA512
			cHashed = sha512( This.String() )

		on :SHA384
			cHashed = sha384( This.String() )

		on :SHA224
			cHashed = sha224( This.String() )

		other
			stzRaise("syntax error or unsupported hashing algorithm!")
		off

		This.Update( cHashed )

		#< @FunctionFluidVersion

		def HashQ(pcHashingAlgo)
			return new stzString( This.Hash(pcHashingAlgo) )

		#>

		#< @FunctionAlternativeForms

		def HashWithAlgo(pcHashingAlgo)
			return This.Hash(pcHashingAlgo)

			def HashWithAlgoQ(pcHashingAlgo)
				return new stzString( This.HashWithAlgo(pcHashingAlgo) )
		#>

	def HashWithMD5()
		This.Hash(:MD5)

		def HashWithMD5Q()
			This.HashWithMD5()
			return This

	def HashWithSHA1()
		This.Hash(:SHA1)

		def HashWithSHA1Q()
			This.HashWithSHA1()
			return This

	def HashWithSHA256()
		This.Hash(:SHA256)

		def HashWithSHA256Q()
			This.HashWithSHA256()
			return This

	def HashWithSHA384()
		This.Hash(:SHA384)

		def HashWithSHA384Q()
			This.HashWithSHA384()
			return This

	def HashWithSHA224()
		This.Hash(:SHA224)

		def HashWithSHA224Q()
			This.HashWithSHA224()
			return This

	  #------------------------------------------#
	 #   ENCRYPTING AND DECRYPTING THE STRING   #
	#------------------------------------------#
	
	# Encrypts the string using the blowfish algorithm:
	#--> returns what's called a cipher in a binary string

	#--> TODO: - what the cIV param means?
	# 	    - check: key must be between 4 and 56 bytes long 

	def EncryptWithBlowfish(cSecretKey, cIV)
		cEncrypted = encrypt( This.String(), cSecretKey, cIV)
		This.Update( cEncrypted )

		#< @FunctionAlternativeForms

		def EncryptWithBlowfishQ(cSecretKey, cIV)
			return new stzListOfBytes( This.EncryptWithBlowfish(cSecretKey, cIV) )

		#>

	# Updates the string from a cipher encrypted with the blowfish algorithm
	#--> cCypher should be in binary form (list of bytes)
	def FromDecryptedWithBlowfish(cCypher, cSecret, cIV)
		This.Update( decrypt(cCypher, cSecret, cIV) )

		#< @FunctionAlternativeForms

		def FromBlowfishCipher(cCypher, cSecret, cIV)
			This.FromDecryptedWithBlowfish(cCypher, cSecret, cIV)

		#>

	  #==============================#
	 #   GETTING TEXT FROM A URL    #
	#==============================#

	def UpdateFromURL(cURL)
		This.Update( download(cURL) )

		def UpdateFromURLQ(cURL)
			This.UpdateFromURLL(cURL)
			return This

		def FromURL(cURL)
			This.UpdateFromURL(cURL)

			def FromURLQ(cURL)
				This.FromURL(cURL)
				return This

	def UpdatedFromURL(cURL)
		cResult = This.Copy().UpdateFromURLQ(cURL).Content()
		return cResult

	  #====================================================#
	 #     WALKING THE STRING AND RETURNING SOMETHING     #
	#====================================================#
	// TODO: use stzWalker?

	def WalkXT(paOptions)

		if NOT ( isList(paOptions) and Q(paOptions).IsHashList() )

			stzRaise("Incorrect param! paOptions must be a hashlist.")
		ok

		if NOT ( len(paOptions) = 0 or

			  StzHashListQ(paOptions).
			  KeysQR(:stzListOfStrings).IsMadeOfSomeCS([
				:From, :FromPosition, :To, :ToPosition, :Step, :Return
			  ], :CS = FALSE) )

			stzRaise("Incorrect value!")
		ok

		oKeys = StzHashListQ(paOptions).KeysQR(:stzListOfStrings)

		if oKeys.ContainsBothCS(:From, :FromPosition, :CS = FALSE)
			stzRaise("Incorrect value! paOptions must not contain both :From and :FromPosition keys.")
		ok

		if oKeys.ContainsBothCS(:To, :ToPosition, :CS = FALSE)
			stzRaise("Incorrect value! paOptions must not contain both :To and :ToPosition keys.")
		ok

		if oKeys.ContainsCS(:From, :CS = FALSE)
			n = StzHashListQ(paOptions).FindKey(:From)
			paOptions[n][1] = :FromPosition
		ok

		if oKeys.ContainsCS(:To, :CS = FALSE)
			n = StzHashListQ(paOptions).FindKey(:To)
			paOptions[n][1] = :ToPosition
		ok

		pnFromPosition = 1
		if paOptions[ :FromPosition ] != NULL
			pnFromPosition = paOptions[ :FromPosition ]
		ok

		pnToPosition = This.NumberOfChars()
		if paOptions[ :ToPosition ] != NULL
			pnToPosition = paOptions[ :ToPosition ]
		ok

		if isString(pnFromPosition) and
		   Q(pnFromPosition).IsOneOfTheseCS([ :First, :FirstChar ], :CS = FALSE)
	
			pnFromPosition = 1

		ok

		if isString(pnToPosition) and
		   Q(pnToPosition).IsOneOfTheseCS([ :Last, :LastChar ], :CS = FALSE)

				pnFromPosition = This.NumberOfChars()
		ok

		pnStep = 1
		if paOptions[ :Step ] != NULL
			pnstep = paOptions[ :Step ]
		ok

		pcReturn = :WalkedPositions
		if paOptions[ :Return ] != NULL
			pcReturn = paOptions[ :Return ]
		ok

		# Doing the job

		anPositions = []
		acChars = []

		for i = pnFromPosition to pnToPosition step pnStep
			anPositions + i
			acChars + This.Char(i)
		next

		aResult = []


		if pcReturn = :WalkedPositions
			aResult = anPositions

		but pcReturn = :WalkedChars
			aResult = acChars
		ok

		return aResult

	def Walk( pnFromPosition, pnToPosition, pnStep, pcReturn )
		return This.WalkXT([ pnFromPosition, pnToPosition, pnStep, pcReturn ])

	  #--------------------------------------------#
	 #   WALKING STARTING FROM N UNTIL CHAR IS    # TODO: Redo with stzWalker
	#--------------------------------------------#

	def WalkBackwardW( paStartingAt, pcCondition )
		/*
		str = "Ring Programming Languge"
		StzStringQ(str).WalkBackwardW( :StartingAt = 12, :Until = '{ @char = " " }' )

		--> Returns 5
		*/

		cResult = ""
		bStopWalking = FALSE
		nCurrentPosition = paStartingAt[2] + 1

		while NOT bStopWalking

			nCurrentPosition--
			if nCurrentPosition = 1
				exit
			ok

			@char = This[ nCurrentPosition ]
			@i = nCurrentPosition

			cCondition = StzStringQ(pcCondition[2]).TrimQ().
					RemoveTheseBoundsQ("{","}").Content()

			cCode = "if " + cCondition + NL +
				TAB + "exit" + NL +
			"ok"

			eval(cCode)
		end

		return nCurrentPosition

	def WalkUntil(pcCondition)
		return This.WalkForeward(:StartingAt = 1, :Until = pcCondition)

	def WalkForewardW( paStartingAt, pcCondition )
		/*
		str = "Ring Programming Languge"
		StzStringQ(str).WalkForewardW( :StartingAt = 6, :UntilBefore = '{ @char = "r" }' )

		--> Returns 9
		*/

		cResult = ""
		bStopWalking = FALSE
		nCurrentPosition = paStartingAt[2] + 1

		while NOT bStopWalking
			nCurrentPosition++
			if nCurrentPosition = This.NumberOfChars()
				exit
			ok

			@char = This[ nCurrentPosition ]
			@i = nCurrentPosition

			cCondition = StzStringQ(pcCondition[2]).
				     TrimQ().RemoveTheseBoundsQ("{", "}").Content()

			cCode = "if " + cCondition + NL +
				TAB + "exit" + NL +
			"ok"

			eval(cCode)			
		end

		if nCurrentPosition = This.NumberOfChars()
			nResult = 0
		else
			nResult = nCurrentPosition-1
		ok

		return nResult

	  #=================================#
	 #  REPEATING THE STRING N TIMES   #
	#=================================#

	def RepeatNTimes(n)
		/* NOTE

		This method exists already in the parent stzObject.
		Here we make it specific to strings.

		In fact, Q("Hi!").RepeatNTimes(3) when applied to
		the string "Hi!" will update it to become "Hi!Hi!Hi!".

		In all other types (stzList, stzNumber, and stzObject)
		Q(5).RepeatNTimes(3) will produce the list [5, 5, 5],
		and Q(1:3).RepeatNTimes(3) will produce the list
		[ 1:3, 1:3, 1:3 ].

		You may ask why we opted for a different behavior for
		strings compared to other types?

		Well, because I think it's more obvious to update the
		string when we ask to repeat it, and have a string as a
		result not a list!

		If you want to avoid any confusion due to this choice,
		use RproduceIn() instead, and specify explicitly what
		you hant to have, like this:

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InString)
		#--> "Hi!Hi:Hi!

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InList)
		"--> [ "Hi!", "Hi!", "Hi!" ]

		*/

		cResult = ""
		for i = 1 to n
			cResult += This.Content()
		next
		This.Update( cResult )

		#< @FunctionFluentForms

		def RepeatNTimesQ(n)
			This.RepeatNTimes(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def Repeat(n)
			This.RepeatNTimes(n)

			def RepeatQ(n)
				This.Repeat(n)
				return This

		#>


	# RETURNING THE OUTPUT DATA

	def RepeatedNTimes(n)
		return This.Copy().RepeatNTimesQ(n).Content()

		def Repeated(n)
			return This.RepeatedNTimes(n)

	  #====================================================#
	 #     COMPRESSING THE STRING WITH A BINARY SCHEMA    #
	#====================================================#

	// Example : ABCDEFGH > 10011011 => ADEGH
	def CompressUsingBinary(cBinary)

		oBinary = new stzString(cBinary)
		if NOT oBinary.IsMadeOf(["0", "1"])
			stzRaise(stzStringError(:CanNotCompressStringUsingBinary))
		ok

		cCompressed = ""
		nLenBinary = len(cBinary)
		nLen = This.NumberOfChars()

		for i = 1 to nLenBinary
			if cBinary[i] = "1" and i <= nLen					
				cCompressed += This.Char(i)
			ok
		next
			
		if nLen > nLenBinary
			for i = NLenBinary + 1 to nLen
				cCompressed += This.CHar(i) 
			next
		ok

		This.Update( cCompressed )

		#< @FunctionFluentForm

		def CompressUsingBinaryQ(cBinary)
			This.CompressUsingBinary(cBinary)
			return This

		#>

	  #=================================#
	 #    CHECKING A LIST IN STRING    #
	#=================================#

	def IsListInString()
		/* EXAMPLES
	
		o1 = new stzString('[ "A","B", "C", "D" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "A":"D" ')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString('[ "ا", "ب", "ج" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "ا":"ج": ')
		? o1.IsListInString() #--> TRUE
		*/

		oCopy = This.RemoveSpacesQ().RemoveTheseBoundsQ( "{", "}" ).

		# A list can not be written with less then 2 chars

		if oCopy.NumberOfChars() < 2
			return FALSE
		ok

		bResult = FALSE

		# Case 1 : The list is in normal [_,_,_] form

		if oCopy.IsBoundedBy([ "[","]" ]) and
			oCopy.Contains(",")

			cCode = "aTempList = " + oCopy.Content()
			eval(cCode)

			bResult = isList(aTempList)

		else

		# Case 2 : The list is in short _:_ form

			if oCopy.ContainsOneOccurrence(":")

				# the : separator in _:_ can not be at the
				# beginning or the end of the list in string

				n = oCopy.FindFirst(":")
				if NOT ( n > 1 and n < oCopy.NumberOfChars() )

					bResult = FALSE

				ok

				# The list is in short form, let's analyze it
				# and tranform it to a normal syntax
	
				aListMembers = QStringListToList( oCopy.QStringObject().split( ":", 0, 0 ) )
				# NOTE: could be written { aListMembers = oCopy.Split( :Using = ":" ) } atfer
				# terminating Split() funtion in Softanza.

				cMember1 = aListMembers[1]
				cMember2 = aListMembers[2]

				cCode = "pMember1 = " + cMember1

				eval(cCode)
	
				cCode = "pMember2 = " + cMember2
				eval(cCode)
	
				cNormalSyntax = "[ "
	
				if ( isString(pMember1) and StringIsChar(pMember1) ) and
				   ( isString(pMember2) and StringIsChar(pMember2) )
					
					n1 = CharUnicode(pMember1)
					n2 = CharUnicode(pMember2)
		
					if n1 <= n2
						for n = n1 to n2
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2
						for n = n1 to n2 step -1
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n > n2
								cNormalSyntax += ", "
							ok
						next
					ok
		
					cNormalSyntax += " ]"
	
				but isNumber(pMember1) and isNumber(pMember2)

					n1 = pMember1
					n2 = pMember2
		
					if n1 <= n2

						for n = n1 to n2
							cNormalSyntax += (""+ n)
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2

						for n = n1 to n2 stzp -1
							cNormalSyntax += (""+ n)
							if n > n2
								cNormalSyntax += ", "
							ok
						next
		
					ok
		
				ok

				if Q(cNormalSyntax).LastChar() != "]"
					cNormalSyntax += " ]"
				ok

				cCode = "aTempList = " + cNormalSyntax

				eval(cCode)

				bResult = isList(aTempList)

			ok  
		ok

		return bResult

	def IsListInNormalForm()
		if NOT This.IsListInString()
			return FALSE
		ok

		if This.TrimQ().IsBoundedBy([ "[","]" ])
			return TRUE
		else
			return FALSE
		ok

	def IsListInShortForm()
		if This.IsListInString() and
		  ( NOT This.IsListInNormalForm() )

			return TRUE
		else
			return FALSE
		ok

	  #--------------------------------------------#
	 #    CHECKING A CONTIGUOUS LIST IN STRING    #
	#--------------------------------------------#

	def IsContiguousListInString()

		cCode = "aTempList = " + This.ToListInNormalForm()
		eval(cCode)
		bResult = StzListQ(aTempList).IsContiguous()

		return bResult

		def IsContinuousListInString()
			return This.IsContiguousListInString()

	def IsContiguousListInNormalForm()
	
		if This.IsContiguousListInString() and
		   This.IsListInNormalForm()
		  
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInNormalForm()
			return This.IsContiguousListInNormalForm()

	def IsContiguousListInShortForm()

		if This.IsContiguousListInString() and
		   This.IsListInShortForm()
		   
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInShortForm()
			return This.IsContiguousListInShortForm()

	  #----------------------------------------------------------------#
	 #   CPNVERTING CONTINUOUS LISTS BETWEEN NORMAL AND SHORT FORMS   #
	#----------------------------------------------------------------#

	def ToListInShortForm()
	
		if NOT This.IsContiguousListInString()
			stzRaise([
				:Where = "stzString > ToListInShortForm()",
				:What  = "Can't convert the list in string to short form!",
				:Why   = "The list in string is not contiguous list."
			])
		ok

		cResult = ""

		if This.IsListInShortForm()
			cResult  =  This.Copy().
					RemoveSpacesQ().
					ReplaceQ(":", " : ").
					Content()

		but This.IsListInNormalForm()

			cCode = "aTempList = " + This.String()
			eval(cCode)

			if StzListQ(aTempList).IsContiguous()

				This.TrimQ().RemoveTheseBoundsQ( "[","]" )
				acMembers = QStringObject().split(",", 0, 0)
				acMembers = QStringListToList(acMembers)
				acMembers = StzListQ(acMembers).FirstAndLastItems()

				/*
				TODO : replace with this when Split() is finished.

				acMembers = This.TrimQ().
						RemoveTheeBoundsQ("[","]").
						SplitQ(",").
						FirstAndLastItems()
				*/

						
				cMember1 = StzStringQ(acMembers[1]).Simplified()
				cMember2 = StzStringQ(acMembers[len(acMembers)]).Simplified()

				cResult = cMember1 + ":" + cMember2

			else
				cResult = This.Simplified()
			ok
		ok

		return cResult

		def ToListInShortFormQ()
			return new stzString( This.ToListInShortForm() )

		def ToListInStringInShortForm()
			return This.ToListInShortForm()

			def ToListInStringInShortFormQ()
				return new stzString( This.ToListInStringInShortForm() )

	def ToListInNormalForm()

		If NOT This.IsListInString()
			stzRaise([
				:Where = "stzString > ToListInNormalForm()",
				:What  = "Can't convert the string to short form list!",
				:Why   = "The string is not a list in string."
			])
		ok

		if This.IsListInNormalForm()
			cResult = This.Simplified()

		but This.IsListInShortForm()

			# The list is in short form, let's analyze it
			# and tranform it to a normal syntax

			aListMembers = QStringListToList( This.QStringObject().split( ":", 0, 0 ) )
			# NOTE: could be written { aListMembers = This.Split( :Using = ":" ) } atfer
			# terminating Split() funtion in Softanza.
					
			cMember1 = aListMembers[1]
			cMember2 = aListMembers[2]

			cCode = "pMember1 = " + cMember1
			eval(cCode)
		
			cCode = "pMember2 = " + cMember2
			eval(cCode)
	
			cNormalSyntax = "[ "
	
			if ( isString(pMember1) and StringIsChar(pMember1) ) and
			   ( isString(pMember2) and StringIsChar(pMember2) )
						
				n1 = CharUnicode(pMember1)
				n2 = CharUnicode(pMember2)
		
				if n1 <= n2
					for n = n1 to n2
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2
					for n = n1 to n2 step -1
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n > n2
							cNormalSyntax += ", "
						ok
					next
				ok
		
				cNormalSyntax += " ]"
		
			but isNumber(pMember1) and isNumber(pMember2)

				n1 = pMember1
				n2 = pMember2
		
				if n1 <= n2

					for n = n1 to n2
						cNormalSyntax += (""+ n)
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2

					for n = n1 to n2 stzp -1
						cNormalSyntax += (""+ n)
						if n > n2
							cNormalSyntax += ", "
						ok
					next
		
				ok
		
				cNormalSyntax += " ]"
			ok

			cResult = cNormalSyntax

		ok  

		return cResult

		def ToListInNormalFormQ()
			return new stzString( This.ToListInNormalForm() )

		def ToListInStringInNormalForm()
			return This.ToListInNormalForm()

			def ToListInStringInNormalFormQ()
				return new stzString( This.ToListInStringInNormalForm() )

	def ToListInstring()
		return This.ToListInNormalForm()

		def ToListInStringQ()
			return new stzString( This.ToListInString() )

	def ToListInStringSF()
		return This.ToListInShortForm()

		def ToListInStringSFQ()
			return new stzString( This.ToListInStringSF() )

	def ToList()
		/*
		NOTE: Currently, it works only for a case like this:
		Q("#1 : #3").ToList() and gives [ "#1", "#2", "#3" ]

		but not for this:
		Q("#12 : #23") --> more then 1 digit

		TODO: Generalise it!
		*/

		This.TrimQ().RemoveTheseBounds("{", "}")

		# Case where we have a normal list syntax

		if This.TrimQ().IsBoundedBy([ "[", "]" ])
			cCode = "aResult = " + This.Content()
			eval(cCode)
			return aResult
		ok

		# Case where we have a continuous list syntax:
		#  ? StzStringQ(' "Thing 1" : "Thing 3" ').ToList()

		cPart = NULL

		cPart1 = NULL
		cLastChar1 = NULL

		cPart2 = NULL
		cLastChar2 = NULL

		oThisWS = This.ReplaceManyQ([": ", " :"], " : ").SimplifyQ()
		
		if oThisWS.NumberOfOccurrence(":") = 1 and oThisWS.MiddleChar() = ":"

			aListMembers = QStringListToList( QStringObject().split(":", 0, 0) )
			oMember1 = StzStringQ(aListMembers[1]).TrimQ()
			oMember2 = StzStringQ(aListMembers[2]).TrimQ()

			cMember1 = oMember1.Content()
			cMember2 = oMember2.Content()

			if BothAreNumbersInStrings(cMember1, cMember2)
				cLastChar1 = cMember1
				cLastChar2 = cMember2

			but BothAreCharsInComputableForm(cMember1, cMember2)
				cLastChar1 = cMember1
				cLastChar2 = cMember2

			but BothAreStringsInComputableForm(cMember1, cMember2)

				c1 = '"'
				c2 = "'"

				oMember1.RemoveManyQ([c1, c2])
				oMember2.RemoveManyQ([c1, c2])

				cLastChar1 = oMember1.LastChar()
				cLastChar2 = oMember2.LastChar()
	
				nLenMember1 = oMember1.NumberOfChars()
				
				if nLenMember1 > 1
					cPart1 = oMember1.Section(1, nLenMember1 - 1)
				ok
	
				nLenMember2 = oMember2.NumberOfChars()
	
				if nLenMember2 > 1
					cPart2 = oMember2.Section(1, nLenMember2 - 1)
				ok

				if ( cPart1 = NULL     or cPart2 = NULL ) and
				   ( cLastChar1 = NULL or cLastChar2 = NULL )

					stzRaise("Syntax error! parts must not be null.")
				ok

				if cPart1 != cPart2
					stzRaise("Syntax error! The two parts must be the same.")
				ok
	
				cPart = cPart1
			else

				stzRaise("Syntax error! Can't transoform the string into list.")
			ok

		else

			stzRaise("Syntax error! Can't transoform the string into list.")

		ok
		
		# Composing the contiguous list for cLastChar1 to cLastChar2
	
		oString = StzStringQ( cLastChar1 + " : " + cLastChar2 )

		cCode = "aList = " + oString.ToListInNormalForm()
		eval(cCode)
	
		# Adding the other parts
	
		if cPart != NULL
			for item in aList
				item = cPart + item
			next
		ok

		return aList

		def ToListQ()
			return new stzList( This.ToList() )

  	  #==========================================================#
	 #   CHECKING IF ALL THE STRINGS VERIFY A GIVEN CONDITION   #
	#==========================================================#

	def CheckW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWithNamedParam()
			pcCondition = pcCondition[2]
		ok

		pcCondition = StzCCodeQ(pcCondition).Transpiled()
		return This.CharsQ().CheckW(pcCondition)

		#< @FunctionAlternativeForms

		def Check(pcCondition)
			return This.CheckW(pcCondition)

		def Verify(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringVerify(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringItemVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringItemVerify(pcCondition)
			return This.CheckW(pcCondition)

		#>

	  #-------------------------------------------------------------------#
	 #   CHECKING IF STRINGS AT GIVEN POSITIONS VERIFY A GIVEN CONDITION   #
	#-------------------------------------------------------------------#

	def CheckOnW(panPositions, pcCondition)

		return This.CharsQ().CheckOnW(panPositions, pcCondition)

		#< @FunctionAlternativeForms

		def VerifyOnW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOn(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyOn(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnPositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifiyOnPositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnThesePositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyThesePositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnPositions(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyOnPositions(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)
		#>

	  #------------------------------------------------------------------#
	 #   CHECKING IF STRINGS AT GIVEN SECTIONS VERIFY A GIVEN CONDITION   #
	#------------------------------------------------------------------#

	def CheckOnSectionsW(paSections, pcCondition)
		return This.CharsQ().CheckOnSectionsW(paSections, pcCondition)

		#< @FunctionAlternativeForm

		def VerifyOnSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		#>

	  #=========================================#
	 #   YIELDING INFORMATION FROM EACH CHAR   #
	#=========================================#

	def Yield(pcCode)
		return This.CharsQ().YieldFrom( 1:This.NumberOfChars(), pcCode )

		#< @FunctionFluentForm

		def YieldQ(pcCode)
			return This.YieldQR(pcCode, :stzList)
	
		def YieldQR(pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Yield(pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.Yield(pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.Yield(pcCode) )

			on :stzHashList
				return new stzHashList( This.Yield(pcCode) )
		
		other
				stzRaise("Unsupported return type!")
		off

		#>

		#< @FunctionAlternativeForms

		def YieldFromEachChar(pcCode)
			return This.Yield(pcCode)

			def YieldFromEachCharQ(pcCode)
				return This.YieldFromEachCharQR(pcCode, :stzList)
		
			def YieldFromEachCharQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromEachChar(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromEachChar(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromEachChar(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromEachChar(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def Harvest(pcCode)
			return This.Yield(pcCode)

			def HervestQ(pcCode)
				return This.YieldFromEachCharQR(pcCode, :stzList)
		
			def HarvestQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.Harvest(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.Harvest(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.Harvest(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.Harvest(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def HarvestFromEachChar(pcCode)
			return This.Yield(pcCode)

			def HarvestFromEachCharQ(pcCode)
				return This.HarvestFromEachCharQR(pcCode, :stzList)
		
			def HarvestFromEachCharQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromEachChar(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromEachChar(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromEachChar(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.HarvestFromEachChar(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off
		#>

	  #--------------------------------------------------------#
	 #   YIELDING INFORMATION FROM CHARS AT GIVEN POSITIONS   #
	#--------------------------------------------------------#

	def YieldFrom(panPositions, pcCode)
		return This.CharsQ().YieldFrom(panPositions, pcCode)

		#< @FunctionFluentForm

		def YieldFromQ(paPositions, pcCode)
			return This.YieldFromQR(paPositions, pcCode, :stzList)
	
		def YieldFromQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFrom(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFrom(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFrom(paPositions, pcCode) )
		
			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def YieldFromPositions(panPositions, pcCode)
			return This.YieldFrom(panPositions, pcCode)

			def YieldFromPositionsQ(paPositions, pcCode)
				return This.YieldFromPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def YieldFromCharsAt(panPositions, pcCode)
			return This.YieldFrom(panPositions, pcCode)

			def YieldFromCharsAtQ(paPositions, pcCode)
				return This.YieldFromCharsAtQR(paPositions, pcCode, :stzList)
		
			def YieldFromCharsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromCharsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromCharsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromCharsAt(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def YieldFromCharsAtPositions(panPositions, pcCode)
			return This.YieldOn(panPositions, pcCode)

			def YieldFromCharsAtPositionsQ(paPositions, pcCode)
				return This.YieldFromCharsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromCharsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromCharsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromCharsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromCharsAtPositions(paPositions, pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromCharsAtPositions(paPositions, pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def HarvestFromPositions(panPositions, pcCode)
			return This.HarvestFrom(panPositions, pcCode)

			def HarvestFromPositionsQ(paPositions, pcCode)
				return This.HarvestFromPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def HarvestFromCharsAt(panPositions, pcCode)
			return This.HarvestFrom(panPositions, pcCode)

			def HarvestFromCharsAtQ(paPositions, pcCode)
				return This.HarvestFromCharsAtQR(paPositions, pcCode, :stzList)
		
			def HarvestFromCharsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromCharsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromCharsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromCharsAt(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def HarvestFromCharsAtPositions(panPositions, pcCode)
			return This.HarvestOn(panPositions, pcCode)

			def HarvestFromCharsAtPositionsQ(paPositions, pcCode)
				return This.HarvestFromCharsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromCharsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off
		#>

	  #------------------------------------------------------#
	 #   YIELDING INFORMATION ON CHARS IN GIVEN SECTIONS    #
	#------------------------------------------------------#

	def YieldFromSections(paSections, pcCode)
		return This.CharsQ().YieldFromSections(paSections, pcCode)

		#< @FunctionFluentForm

		def YieldFromSectionsQ(paSections, pcCode)
			return new stzList( This.YieldFromSections(paSections, pcCode) )

		def YieldSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsQ(paSections, pcCode)
				return This.HarvestFromSections(paSections, pcCode, :stzList)

			def HarvestFromSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSections(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
	
		def HarvestSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsQ(paSections, pcCode)
				return This.HarvestSections(paSections, pcCode, :stzList)

			def HarvestSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSections(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
		#>

	def YieldFromSectionsOneByOne(paSections, pcCode)

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		anSectionsExpanded = []
		for aSection in paSections
			anSectionsExpanded + Q(aSection).ExpandedIfPairOfNumbers()
		next

		for anPositions in anSectionsExpanded
			aResult + This.YieldFromPositions(anPositions, pcCode)
		next

		return aResult

		#< @FunctionFluentForm

		def YieldFromSectionsOneByOneQ(paSections, pcCode)
			return This.YieldFromSectionsOneByOneQR(paSections, pcCode, :stzList)

		def YieldFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestFromSectionsOneByOne(paSections, pcCode, :stzList)

			def HarvestFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
				
		def HarvestSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestSectionsOneByOne(paSections, pcCode, :stzList)

			def HarvestSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off

		def YieldSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def YieldSectionsOneByOneQ(paSections, pcCode)
				return This.YieldSectionsOneByOne(paSections, pcCode, :stzList)

			def YieldSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off

		#>

	  #----------------------------------------------------------------#
	 #   YIELDING INFORMATION ON ITEMS VERIFYiNG A GIVEN CONDITION    #
	#----------------------------------------------------------------#

	def YieldW(pcCode, pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCode = new stzString(pcCode)
		if oCode.ContainsCS("@substring", :CS = FALSE)
			aTempList = This.SubStrings()

		else
			aTempList = This.Chars()
		ok

		pcCode = Q(pcCode).ReplaceCSQ("@char", "This[@i]", :CS=FALSE).Content()
		pcCondition = Q(pcCondition).ReplaceCSQ("@char", "This[@i]", :CS=FALSE).Content()

		acResult = Q(aTempList).YieldW(pcCode, pcCondition)
		return acResult

		#< @FunctionFluentForm

		def YieldWQ(pcCode, pcCondition)
				return This.YieldWQR(paPositions, pcCode, :stzList)
		
			def YieldWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldW(pcCode, pcCondition) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldW(pcCode, pcCondition) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldW(pcCode, pcCondition) )
	
				on :stzHashList
					return new stzHashList( This.YieldW(pcCode, pcCondition) )
			
			other
					stzRaise("Unsupported return type!")
			off

		#>

		#> @FunctionAlternativeForm

		def HarvestW(pcCode, pcCondition)
			return This.YieldW(pcCode, pcCondition)

			def HervestWQ(pcCode, pcCondition)
				return This.HarvestWQR(pcCode, pcCondition, :stzList)

			def HervestWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				if NOT isString(pcReturnType)
					stzRaise("IncorrectType! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestW(pcCode, pcCondition) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestW(pcCode, pcCondition) )

				other
					stzRaise("Unsupported return type!")
				off

		#>

	  #=======================================#
	 #   PERFORMING AN ACTION ON EACH CHAR   #
	#=======================================#

	def Perform(pcCode)
		# Must begin with '@char ='

		This.UpdateWith(
			This.CharsQ().
			PerformQ(pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformQ(pcCode)
			This.Perform(pcCode)
			return This

	  #----------------------------------------------------#
	 #   PERFORMING ACTIONS ON CHARS IN GIVEN POSITIONS   #
	#----------------------------------------------------#

	def PerformOn(panPositions, pcCode)

		This.UpdateWith(
			This.CharsQ().
			PerformOnQ(panPositions, pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformOnQ(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)
			return This

		def PerformOnPositions(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)

			def PerformOnPositionsQ(panPositions, pcCode)
				This.PerformOnPositions(panPositions, pcCode)
				return This

		def PerformOnThesePositions(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)

			def PerformOnThesePositionsQ(panPositions, pcCode)
				This.PerformOnThesePositions(panPositions, pcCode)
				return This

	  #------------------------------------------------------#
	 #   PERFORMING AN ACTION ON CHARS IN GIVEN SECTIONS    #
	#------------------------------------------------------#

	def PerformOnSections(paSections, pcCode)

		This.UpdateWith(
			This.CharsQ().
			PerformOnSectionsQ(paSections, pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformOnSectionsQ(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)
			return This

		def PerformOnTheseSections(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)

			def PerformOnTheseSectionsQ(paSections, pcCode)
				This.PerformOnTheseSections(paSections, pcCode)
				return This

	  #---------------------------------------------------------------#
	 #   PERFORMING AN ACTION ON CHARS VERIFYING A GIVEN CONDITION   #
	#---------------------------------------------------------------#

	def PerformW(pcAction, pcCondition)

		This.UpdateWith(
			This.CharsQ().
			PerformWQ(pcAction, pcCondition).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def DoW(pcAction, pcCondition) # TODO: Generalize in other classes
			This.PerformW(pcAction, pcCondition)

		def PerformWQ(paParams)
			This.PerformW(paParams)
			return This

			def DoWQ(paParams)
				This.PerformWQ(paParams)

	  #============================#
	 #  OPERATORS OVERLOADING     #
	#============================#

	# TODO: Operators should carry same semantics in all classes...

	def operator(pOp,pValue)

		// string access : str[n]
		// string search : str[substr]

		if pOp = "[]"
			
			if isString(pValue)
				if pValue = :First or pValue = :FirsChar
					pValue = 1

				but pValue = :Last or pValue = :LastChar
					pValue = This.NumberOfChars()
				ok
			ok

			if isNumber(pValue)

				return This.NthChar(pValue)
							
			but isString(pValue)
				if StzStringQ(pValue).TrimQ().IsBoundedBy(["{","}"])
					pcCondition = StzStringQ(pValue).TrimQ().BoundsRemoved(["{","}"])
					anResult = []

					@char = ""
					nLen = This.NumberOfChars()

					for @i = 1 to nLen
						@char = This.Char(@i)
						cCode = 'bOk = ( ' + pcCondition + ' )'

						eval(cCode)
						if bOk
							anResult + @i
						ok
					next

					return anResult
				else
					return This.FindAll(pValue)
				ok	
			ok
				// Add an item at the beginning of the list
		but pOp = "<<"
			This.Prepend(1)

		// Add an item at the end of the list
		but pOp = ">>"
			This.Append(value)

		// compare equality : oString = str

		but pOp = "="
			return This.IsEqualTo(pValue)

		// oString < str

		but pOp = "<"
			return This.IsSmallerThan(pValue)
		
		// compare : oString > str

		but pOp = ">"
			return This.IsLargerThan(pValue)
	
		// add : string + string | string + ListOfStrings

		but pOp = "+"
			if ring_type(pValue) = "STRING"
				This.Append(pValue)
				return This
		
			but StzListQ(pValue).IsListOfStrings()
				This.InsertListOfSubstrings(pValue)
				return This	
			ok

		// Multiply: string * n | string * string | string * list
	
		but pOp = "*"
			This.MultiplyBy(pValue)
			return This

		// Split: String / n  | String / str	| String / list

		but pOp = "/"

			if isString(pValue)
				if Q(pValue).IsBoundedBy([ "{", "}" ])

					acSplitted = This.SplitW(pValue)

				else
					acSplitted = This.Split(pValue)
				ok

				return acSplitted

			but isNumber(pValue)
				return This.SplitToNParts(pValue)

			but isList(pValue) and Q(pValue).IsListOfNumbers()
				acSplitted = This.SplitAtPositions(pValue)
				return acSplitted

			but isList(pValue) and Q(pValue).IsPairOfStrings() and
			    pValue[1] = :where and Q(pValue[2]).IsBoundedBy([ "{" , "}" ])

				acSplitted = This.SplitW(pValue[2])
				return acSplitted
			
			but isList(pValue) and Q(pValue).IsListOfSrtrings() # NOTE this is misspelled!
				/* EXAMPLE
				? @@( Q("RingRubyJava") / [ "Qute", "Nice", "Good" ] )
				#--> [ [ "Qute", "Ring" ], [ "Nice", "Ruby" ], [ "Good", "Java" ] ]	
				*/

				nLen = len(pValue)
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue, acSplitted ])
				return aResult

			but isList(pValue) and Q(pValue).IsHashList()

				oHashList = new stzHashList(pValue)

				# All the values except the last one must be numbers

				aValuesExceptLast = oHashList.ValuesQ().LastItemRemoved()

				if NOT Q(aValuesExceptLast).IsListOfNumbers()
					stzRaise("Incorrect values! All the values except the last, must be numbers.")
				ok

				# The last value can be a number or a string equal to :Remaining or :RemainingChars

				if NOT 	( isNumber(oHashList.LastValue()) or

					  ( isString(oHashList.LastValue()) and
					    Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ])
					  )
					)

					stzRaise("Incorrect value! The last value mus tbe a number or a string (:Remaining or :RemainingChars).")
				ok

				# If the last value is :Remaining or :RemainingChars, the the its replace by the n remaining chars

				if isString(oHashList.LastValue()) and
				   Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ])

					
					n = 0
					for i = 1 to len(aValuesExceptLast)
						n += aValuesExceptLast[i]
					next

					nRemainingChars = This.NumberOfChars() - n

					pValue[ len(pValue) ][2] = nRemainingChars
				ok

				# The sum of shares must be equal to the number of chars
				
				if NOT StzHashListQ(pValue).ValuesQR(:stzListOfNumbers).Sum() = This.NumberOfChars()
					stzRaise("Incorrect values! The sum of numbers must be equal to the number of chars!")
				ok

				# Making the share of the string based on the values provided

				aResult = []
				n = 1
				for aPair in pValue
					
					cShare = This.Range(n, aPair[2])
					n += aPair[2]

					aResult + [ aPair[1], cShare  ]
				next

			ok

			return aResult
					
		// String % n : returns the rest of letters after dividing String / n

		but pOp = "%"
			cResult = NULL

			if ring_type(pValue) = "NUMBER"	
				aParts = []
		
				nParts = ceil( This.NumberOfChars() / pValue )
				for i=1 to This.NumberOfChars() step nParts
					cTemp = @oQString.mid(i-1, nParts)
					aParts + cTemp	
				next
		
				if len(aParts) < pValue
					for i = len(aParts) to pValue-1
						aParts + "_"
					next
				ok
		
				if aParts[ len(aParts) ] != "_"
					return aParts[ len(aParts) ]
				ok
			ok

			return cResult
		
		// string - string | string - .25 | string - 3
		but pOp = "-"
			cResult = NULL
						
			if isString(pValue)
				This.RemoveAllQ(pValue)
				return This
			ok
		
			if isNumber(pValue)
				if pValue < This.NumberOfChars()
					if pValue > 0 and pValue < 1 // str - 0.5
						// Eats a portion of the string (half: 0.5, quarter0.25,...)
						n = floor( This.NumberOfChars() * pValue)
						cResult = This.Section( 1, This.NumberOfChars() - n ) // @oQString.mid(0,nLenStr-n)
					else
						cResult = This.Section(1, This.NumberOfChars() - pValue )
					ok		
				ok

				This.Update( cResult )
				return This
				# TODO/NOTE: In stzList, the "-" operator returns This.Content()
				#--> Hormonize the behaviour of all the operators in all classes!
			ok

			if StzListQ(pValue).IsListOfStrings()
				for item in pValue
					This.RemoveAll(item)
				next
				return This
			ok

			if StzListQ(pValue).IsListOfLists() and len(pValue) = 1
				/*
				Example:

				o1 = new stzString("XRingorialand")
				o1 - [[ :FirstCharIf, :EqualTo, :X ]]

				Gives -> "Ringorialand"

				NB: We use the two brackets here to differenciate
				the syntax with:

					 o1 - [ "X", "oria", "land" ] --> "Ring"

				which means : remove this ist of substrings from
				the main string
				*/

				aListOfConditions = [
					:EqualTo, :LesserThan, :GreaterThan,
					:LesserThanOrEqual, :GreaterThanOrEqual,
					:DifferentThan ]

				cFirstOrLast = pValue[1][1]
		 		cCondition = pValue[1][2]
				value = pValue[1][3]

				oCondition = new stzString(cCondition)

				if NOT ( len(pValue[1]) = 3 AND
				   (cFirstOrLast = :FirstCharIf or cFirstOrLast = :LastCharIf) AND
				   oCondition.ExistsInList(aListOfConditions) AND
				   isString(value) )

					stzRaise(stzStringError(:UnsupportedExpressionInOverloadedMinusOperator))
				ok
					
				if cFirstOrLast = :FirstCharIf

					if cCondition = :EqualTo
						if Q(pValue).IsNumberOrString()
							if This.FirstChar() = pValue
								This.RemoveFirstChar()
								return This
							ok
						ok

						if StzListQ(pValue).IsListOfStrings()
							oList = pValue
							if oList.IsEqualTo(cFirstOrLast)
								This.RemoveMany(pValue)
								return This
							ok
						ok

					but cCondition = :LesserThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :LesserOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					
					but cCondition = :DifferentThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					ok

				but cFirstOrLast = :LastCharIf

					if cCondition = :EqualTo
						if StringIsChar(pValue) and This.LastChar() = pValue
							This.RemoveNthChar(This.NumberOfChars())
							return This
						ok

						if ListIsListOfChars(pValue)
							oList = pValue
							if value.IsEqualTo(cFirstOrLast)
								This.RemoveMany(pValue)
								return This
							ok
							
						ok

					but cCondition = :LesserThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :LesserOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					
					but cCondition = :DifferentThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					ok

				ok

			ok
		ok // --- End of operator overloading section


	  #=====================================================#
	 #  METHODS USED FOR CAMPATIBILITY WITH EXTERNAL CODE  #
	#=====================================================#

	def join(pacItems) # Python
		/* EXAMPLE

		In Python: ' + '.join([ "a", "b", "c" ])
		#--> a + b + c

		# In Ring, with Softanza:

		? Q(' + ').join([ "a", "b", "c" ])
		#--> a + b + c

		*/

		if NOT ( isList(pacItems) and Q(pacItems).IsListOfStrings() )
			StzRaise("Incorrect param type! pacItems must be a list of strings.")
		ok

		cResult = QR(pacItems, :stzListOfStrings).ConcatenatedUsing(This.String())
		return cResult

	  #==========================================#
	 #   METHODS USED FOR NEAR-NATURAL-CODING   #
	#==========================================#

	def IsAlmostAFunctionCall()
		# Why almost? Because it doesn't analyse the correctness of the params
		# which we should do in the future, but this is sufficient for our
		# actual needs in stzChainOfTruth and other classes of natural-coding

		# PS: if you you don't like sutch a precison, use the alternative name
		# IsFunctionCall() instead.

		if This.NumberOfOccurrence("(") = 1 and
		   This.NumberOfOccurrence(")") = 1 and
		   This.FindFirst("(") > 1 and
		   This.FindFirst("(") < This.FindFirst(")") and
		   This.LastChar() = ")" // and # TODO: complete this and remove "Almost" from the function name!
		   //This.SectionQ(1,  This.FindFirst("(") - 1).ContainsOnly(:CompterCodeChars)
		
			return TRUE
		else
			return FALSE
		ok

		#< FunctionAlternativeForms >

		def IsFunctionCall()
			return This.IsAlmostAFunctionCall()
		#>

	def IsAMethodOfThisObject(pObject)
		return This.String().ExistsIn( classes(pObject) )

		def IsMethodOfObject(pObject)
			return IsAMethodOfThisObject(pObject)

	def IsAnAttributeOfThisObject(pObject)
		return This.String().ExistsIn( attributes(pObject) )

		def IsAttributeOfObject(pObject)
			return IsAnAttributeOfThisObject(pObject)		 

	#-----------------

	def IsStzString()
		return TRUE

	def StzType()
		return :stzString

	def IsANumber()
		return FALSE

		def IsNotANumber()
			return TRUE

	def IsAString()
		return TRUE

		def IsNotAString()
			return FALSE

	def IsAList()
		return FALSE

		def IsNotAList()
			return TRUE

	def IsAnObject()
		return TRUE

		def IsNotAnObject()
			return FALSE

	  #=====================================================#
	 #  CHECKING IF THE STRING STARTS WITH A GIVEN NUMBER  #
	#=====================================================#

	def StartsWithNumber(n)
		
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).RemoveSpacesQ().
					 RemoveQ("_").
					 ThisFirstCharRemoved("+")
			ok
		ok

		oStrCopyWS = This.Copy().RemoveSpacesQ()
		cLeadingNumber = Q(oStrCopyWS.LeadingNumber()).ThisFirstCharRemoved("+")

		if  cLeadingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithLeadingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsStartingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsLeadingNumber(n)
			return This.StartsWithNumber(n)

		def HasLeadingNumber(n)
			return This.StartsWithNumber(n)

		def HasStartingNumber(n)
			return This.StartsWithNumber(n)

		#>
		
	  #-----------------------------------------------#
	 #  CHECKING IF THE STRING STARTS WITH A NUMBER  #
	#-----------------------------------------------#

	def StartsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.StartsWithANumber()
		#--> TRUE
		*/

		oStrCopyWS = This.Copy().RemoveSpacesQ()

		if  oStrCopyWS.FirstCharQ().IsANumberInString() or

		    ( oStrCopyWS.NumberOfChars() > 1 and
		      oStrCopyWS.FirstCharQ().IsEither("+", :Or = "-") and
		      oStrCopyWS.SecondCharQ().IsANumberInString() )

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingNumber()
			return This.StartsWithANumber()

		def ContainsAStartingNumber()
			return This.StartsWithANumber()

		def ContainsALeadingNumber()
			return This.StartsWithANumber()

		def HasALeadingNumber()
			return This.StartsWithANumber()

		def HasAStartingNumber()
			return This.StartsWithANumber()

		#>

	  #-----------------------------------------------------#
	 #  GETTING THE LEADING NUMBER (IF ANY) IN THE STRING  #
	#-----------------------------------------------------#

	def StartingNumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		o1.StartingNumber()
		#--> 23
		*/

		if NOT This.HasALeadingNumber()
			return ""
		ok

		cResult = ""
		bContinue = TRUE
		i = 0
		nLen = This.NumberOfChars()

		while bContinue
			i++
			if i > nLen
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "_", "." ]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).
			  RemoveSpacesQ().
			  RemoveThisFirstCharQ("+").
			  ThisLastCharRemoved(".")

		return cResult

		#< @FunctionAlternativeForm

		def LeadingNumber()
			return This.StartingNumber()

		#>
	
  	  #===================================================#
	 #  CHECKING IF THE STRING ENDS WITH A GIVEN NUMBER  #
	#===================================================#

	def EndsWithNumber(n)
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).ThisFirstCharRemoved("+")
			ok
		ok

		cTrailingNumber = Q(This.TrailingNumber()).ThisFirstCharRemoved("+")

		if  cTrailingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithTrailingNumber(n)
			return This.EndsWithNumber(n)

		def EndsWithFinalNumber(n)
			return This.EndsWithNumber(n)

		def ContainsTrailingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsFinalNumber(n)
			return This.StartsWithNumber(n)

		def ContainsEndingNumber(n)
			return This.StartsWithNumber(n)

		#>
		
	  #---------------------------------------------#
	 #  CHECKING IF THE STRING ENDS WITH A NUMBER  #
	#---------------------------------------------#

	def EndsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.EndsWithNumber()
		#--> TRUE
		*/

		nResult = This.LastCharQ().IsANumberInString()
		return nResult

		#< @FunctionAlternativeForms

		def EndsWithATrailingNumber()
			return This.EndsWithNumber()

		def EndsWithAFinalNumber()
			return This.EndsWithNumber()

		def ContainsATrailingNumber()
			return This.EndsWithNumber()

		def ContainsAFinalNumber()
			return This.EndsWithNumber()

		def ContainsAnEndingNumber()
			return This.EndsWithNumber()

		#>

	  #----------------------------------------------------------#
	 #  GETTING THE TRAILING NUMBER (IF ANY) IN THE THE STRING  #
	#----------------------------------------------------------#

	def TrailingNumber()
		/* EXAMPLE
		o1 = new stzString("Age: 48")
		o1.TrailingNumber()
		#--> 48
		*/

		cResult = ""
		bContinue = TRUE
		i = This.NumberOfChars() + 1

		while bContinue
			i--
			if i = 0
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "."]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).ReverseCharsQ().ThisLastCharRemoved(".")
		return cResult

		#< @FunctionAlternativeForm

		def FinalNumber()
			return This.StartingNumber()

		def EndingNumber()
			return This.StartingNumber()

		#>

	  #==============================================================#
	 #  GETTING ALL THE (DECIMAL) NUMBERS THAT EXIST IN THE STRING  #
	#==============================================================#
 
	def Numbers()
		/* EXAMPLE

		o1 = new stzString("book: 12.34, watch: -56.30, glasses: 77.")
		? o1.Numbers()
		#--> [ "13.34", "-56.30",  "77" ]

		*/

		cTempStr = This.Content() + " "
		nLen = This.NumberOfChars() + 1

		cNumber = ""
		acResult = []
		bThereWasASign = FALSE

		for i = 1 to nLen
			c = Q(cTempStr).CharAt(i)

			if c = " " and bThereWasASign
				loop
			ok

			if StzCharQ(c).IsANumber() or
			   (c = "+" or c = "-" and cNumber = "") or
			   ((c = "." or c = "_") and cNumber != "" and StzCharQ(Q(cNumber).LastChar()).IsANumber())
		
				cNumber += c

			but (NOT StzCharQ(c).IsANumber()) or i = nLen
		
				if cNumber != ""
		
					cNumber = Q(cNumber).
						  RemoveThisLastCharQ(".").
						  RemoveThisLastCharQ("_").
						  Content()
		
					cSign = ""
					if len(acResult) > 0
						if acResult[len(acResult)] = "+"
							cSign = "+"

						but acResult[len(acResult)] = "-"
							cSign = "-"
						ok
					ok

					if cSign != ""
						del(acResult, len(acResult))
						cNumber = cSign + cNumber
					ok

					if cNumber != "+" and cNumber != "-"
						acResult + cNumber
						cNumber = ""
					ok
				ok
			ok
		
		next
		
		return acResult

		def NumbersQ()
			return This.NumbersQR(:stzList)

		def NumbersQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfStrings
				return new stzList( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

	  #--------------------------------------#
	 #  EXTRACTING NUMBERS FROM THE STRING  #
	#--------------------------------------#

	def ExtractNumbers()
		acNumbers = This.Numbers()
		This.RemoveMany(acNumbers)
		return acNumbers

	  #------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF (DECIMAL) NUMBERS INCLUDED IN THE STRING  #
	#------------------------------------------------------------------#

	def NumberOfNumbers()
		return len( This.Numbers() )

		#< @FunctionAlternativeForms

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumbers()
			return This.NumberOfNumbers()

		def HowManyNumber()
			return This.NumberOfNumbers()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------#

	def NumbersAndTheirPositions() # TODO: Check performance!
		aResult = Q(This.UniqueNumbers()).AssociatedWith( This.FindNumbers() )
		return aResult

		def NumbersZ()
			return This.NumbersAndTheirPositions()

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR SECTIONS  #
	#------------------------------------------------------------------------#

	def NumbersAndTheirSections() # TODO: chek performance!
		aResult = []
		acNumbersU = This.UniqueNumbers()
		nLen = len(acNumbersU)

		for i = 1 to nLen
			aResult + [ acNumbersU[i], This.FindAsSections(acNumbersU[i]) ]
		next

		return aResult


		def NumbersZZ()
			return This.NumbersAndTheirSections()

	  #----------------------------------------------------#
	 #  GETTING THE LIST OF UNIQUE NUMBERS IN THE STRING  #
	#----------------------------------------------------#

	def UniqueNumbers()
		return This.NumbersQ().DuplicatesRemoved()

		#< @FunctionAlternativeForms

		def NumbersU()
			return This.UniqueNumbers()

		def NumbersWithoutDuplication()
			return This.UniqueNumbers()

		#>

	  #-------------------------------------------------------#
	 #  GETTTING THE NUMBER OF UNIQUE NUMBERS IN THE STRING  #
	#-------------------------------------------------------#

	def NumberOfUniqueNumbers()
		return len( This.UniqueNumbers() )

		#< @FunctionAlternativeForms

		def CountUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def NumberOfNumbersU()
			return This.NumberOfUniqueNumbers()

		def CountNumbersU()
			return This.NumberOfUniqueNumbers()

		#--

		def HowManyUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersU()
			return This.NumberOfUniqueNumbers()

		def HowManyUniqueNumber()
			return This.NumberOfUniqueNumbers()

		def HowManyNumberU()
			return This.NumberOfUniqueNumbers()

		#--

		def NumberOfNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (POSITIONS RETURNED)  #
	#----------------------------------------------------------------#

	def FindNumbers()
		anResult = This.FindManyQ( This.UniqueNumbers() ).FlattenQ().Sorted()
		return anResult

	  #---------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (SECTIONS RETURNED)  #
	#---------------------------------------------------------------#

	def FindNumbersAsSections()
		return This.FindManyAsSections( This.UniqueNumbers() )

		def FindNumbersSections()
			return This.FindNumbersAsSection()

		def FindAsSectionsOfNumbers()
			return This.FindNumbersAsSection()

	  #--------------------------------------------------------------#
	 #  GETTING THE NTH (DECIMAL) NUMBER THAT EXISTS IN THE DTRING  #
	#--------------------------------------------------------------#

	def NthNumber(n)
		if isString(n)
			if n = :First or n = :FirstNumber
				n = 1

			but n = :Last or n = :LastNumber
				n = len( This.Numbers() )
			ok
		ok

		return This.Numbers()[n]

	  #------------------------------------------------------#
	 #  GETTING THE FIRST NUMBER THAT EXISTS IN THE DTRING  #
	#------------------------------------------------------#

	def FirstNumber(n)
		return This.NthNumber(1)

	  #-----------------------------------------------------#
	 #  GETTING THE LAST NUMBER THAT EXISTS IN THE DTRING  #
	#-----------------------------------------------------#

	def LastNumber(n)
		return This.NthNumber(:Last)

	  #==========================================#
	 #  NUMBERS COMING AFTER A GIVEN SUBSTRING  #
	#==========================================#

	def NumbersComingAfterCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("This[@i-1] = This[@i+3]")
		? o1.NumbersComingAfter("@i")
		#--> [ "-1", "3" ]

		? o1.NumberComingAfter("@i+")
		#--> 3
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		acSubStrings = This.SplitQ("@i").FirstItemRemoved()
		# Splitting takes as little as 0.01s

		nLen = len(acSubStrings)
	
		acResult = []
		for i = 1 to nLen
			acNumbers = Q(acSubStrings[i]).Numbers()
			nLen2 = len(acNumbers)

			for j = 1 to nLen2
				acResult + acNumbers[j]
			next j
		next i

		return acResult


		#< @FunctionFluentForm

		def NumbersComingAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, :stzList)

		def NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				stzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NumbersComingAfterXTCS(pcSubStr, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NumbersComingAfterXTCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NumbersComingAfterXTCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NumbersAfterCS(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCS(pcSubStr, pCaseSensivitive)

		def NumbersAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbesrAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def NumbersAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumbersComingAfter(pcSubStr)
		return This.NumbersComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumbersComingAfterQ(pcSubStr)
			return This.NumbersComingAfterQR(pcSubStr, :stzList)

		def NumbersComingAfterQR(pcSubStr, pcReturnType)
			return This.NumbersComingAfterCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NumbersAfter(pcSubStr)
			return This.NumbersComingAfter(pcSubStr)

		def NumbersAfterQ(pcSubStr)
			return This.NumbesrAfterQR(pcSubStr, pcReturnType)

		def NumbersAfterQR(pcSubStr, pcReturnType)
			return NumbersComingAfterQR(pcSubStr, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  NTH NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#---------------------------------------------#

	def NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)
		# TODO: Re-implement it for better performance
		# No need to parse all the numbers and then get the nth

		return This.NumbersComingAfterCS(pcSubStr, pCaseSensitive)[n]

		#< @FunctionAlternativeForm

		def NthNumberAfterCS(n, pcSubStr, pCaseSensitive)
			return This.NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthNumberComingAfter(n, pcSubStr)
		return This.NthNumberComingAfterCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def NthNumberAfter(n, pcSubStr)
			return This.NthNumberComingAfter(n, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #  FIRST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(1, pcSubStr, pCaseSensitive)

		def NumbeComingAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FirstNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FirstNumberComingAfter(pcSubStr)
		return This.FirstNumberComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		def NumberComingAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#< @FunctionAlternativeForm

		def FirstNumberAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#>

	  #----------------------------------------------#
	 #  LAST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def LastNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(:Last, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.LastNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def LastNumberComingAfter(pcSubStr)
		return This.LastNumberComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def LastNumberAfter(pcSubStr)
			return This.LastNumberComingAfter(pcSubStr)

		#>

	  #====================================#
	 #  BISECTING THE STRING INTO HALVES  #
	#====================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()
		
	def FirstHalfXT()

		nPos = ceil(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult
		
	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
				return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

	  #==========================================#
	 #   STRINGIFY(), TOSTRING(), AND TOCODE()  #
	#==========================================#

	def Stringify()
		# Do nothing, the object is naturally stringified
		# becauses it is already a string

		def StringifiyQ()
			return new stzString( This.String() )

	def Stringified()
		return This.String()

	def ToString()
		return This.String()

		def ToStringQ()
			return new stzString( This.ToString() )
	
	def ToCode()
		cResult = ""

		cQuote = "'"
		cDoubleQuote = '"'

		if This.IsBoundedBy(cDoubleQuote)
			cResult = cQuote + This.String() + cQuote

		but This.IsBoundedBy(cQuote)
			cResult = cDoubleQuote + This.String() + cDoubleQuote

		else
			cResult = This.String()
		ok

		return cResult

		def ToCodeQ()
			return new stzString( This.ToCode() )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE COMMON SUBSTRINGS BETWEEN THIS STRING AND AN OTHER STRING  #
	#-------------------------------------------------------------------------#

	def CommonSubStringsCS(pcOtherStr, pCaseSensitive)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		aTempList = [
			This.SubStringsCS(pCaseSensitive),
			Q(pcOtherStr).SubStringsCS(pCaseSensitive)
		]

		acResult = StzListOfListsQ(aTempList).CommonItemsCS(pCaseSensitive)
		
		return acResult

		def IntersectionCS(pcOtherStr, pCaseSensitive)
			return This.CommonSubStringsCS(pcOtherStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CommonSubStrings(pcOtherStr)
		return This.CommonSubStringsCS(pcOtherStr, :CaseSensitive = TRUE)

		def Intersection(pcOtherStr)
			return This.CommonSubStrings(pcOtherStr)

	  #======================#
	 #  SHOWING THE STRING  #
	#======================#

	def Show()
		? @@( This.Content() )

	def ShowShort()
		? @@( This.Shortened() )

		def ShowShortCopy()
			This.ShowShort()

	def ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		? @@( This.ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart) )

		def ShowShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

	def ShowShortN(n)
		? @@( This.ShortenedN(n) )

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

	  #-------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING  #
	#===========================================#

	def ToShort()
		return This.ToShortXT(10, 3, " (...) ")

	  #-----------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING WITH N ITEMS FROM EACH SIDE  #
	#-----------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, " (...) ")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USiNG A GIVEN MIDDLE PART  #
	#---------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #--------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#--------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #------------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE STRING -- EXTENDED  #
	#------------------------------------------------------#

	def ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		# nMinStrSize : the minimum size to start shprtening
		# --> if the size of the string is less than this value,
		#     the string will not be shortened (returned as is)

		# pNumberOfCharsToShow: the number of chars to show from
		# both the beginning and end of the string
		# --> the other part of the string (coming in the middle)
		#     will be hide and replaced by pcMiddlePart

		/* EXAMPLES

		? Q("1234567890987654321").Shortened()
		#--> 123 ... 321
		
		? Q("1234567890987654321").ShortenedN(5)
		#--> 12345 ... 54321
		
		? Q("1234567890987654321").ShortenedXT(0, 3, " ... ")
		#--> 123 ... 321

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinStrSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfCharsToShow)
			n1 = pNumberOfCharsToShow
			n2 = pNumberOfCharsToShow

		but isList(p) and Q(pNumberOfCharsToShow).IsPairOfNumbers()
			n1 = pNumberOfCharsToShow[1]
			n2 = pNumberOfCharsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfCharsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of chars to show must be different of zero.")
		ok

		# Doing the job

		cPart1 = This.Section(1, n1)
		cPart2 = This.Section(nLen - n2 + 1, nLen)

		cResult = cPart1 + pcMiddlePart + cPart2

		return cResult

	  #-------------------------#
	 #  SHORTENING THE STRING  #
	#=========================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #---------------------------------------------------#
	 #  SHORTENING THE STRING TO N CHARS FROM EACH SIDE  #
	#---------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNChars(n)
			This.ShortenN(n)

			def ShortenToNICharsQ(n)
				This.ShortenToNChars(n)
				return This

		def ShortenToNCharsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsInEachSideQ(n)
				This.ShortenToNCharsInEachSide(n)
				return This

		def ShortenToNCharsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsFromEachSideQ(n)
				This.ShortenToNCharsFromEachSide(n)
				return This

		def ShortenToNCharsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsAtEachSideQ(n)
				This.ShortenToNCharsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNChars(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNICharsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #-----------------------------------------------------------------#
	 #  SHORTENING THE STRING USING THE GIVEN STRING AS A MIDDLE PART  #
	#-----------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE STRING -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart).Content()
		return cResult

	  #===========#
	 #   MISC.   #
	#===========#
		
	def HasSameTypeAs(p)
		return isString(p)

	def IsAnagramOfCS(pcOtherStr, pCaseSensitive)

		oTheseChars = This.CharsQR(:stzListOfStrings).RemoveduplicatesQ().SortInAscendingQ()

		cOtherChars = StzStringQ( pcOtherStr ).
				CharsQ().RemoveDuplicatesQ().
				SortInAscendingQ().Content()
	
		bResult = oTheseChars.IsEqualToCS( cOtherChars, pCaseSensitive )

		return bResult

	def IsAnagramOf(pcOtherStr)
		return This.IsAnagramOfCS(pcOtherStr, :CS = TRUE)

	def UpTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() < CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar)
				acResult + StzCharQ(n).Content()
			next
			return acResult
		ok

	def DownTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() > CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar) step -1 
				acResult + StzCharQ(n).Content()
			next

			return acResult
		ok

	def FirstAndLastChars()
		aResult = [ This.FirstChar(), This.LastChar() ]
		return aResult

	def LastAndFirstChars()
		aResult = [ This.LastChar(), FirstChar() ]
		return aResult
		
	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzstring"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	def IsLatinScript()
		return This.ToStzText().IsLatinScript()

		def IsLatin()
			return This.IsLatinScript()

	def IsArabicScript()
		return This.ToStzText().IsArabicScript()

		def IsArabic()
			return This.IsArabicScript()

	def IsText()
		return TRUE

	def ToStzCCode()
		return new stzCCode(This.String())

		def ToStzCCodeObject()
			return This.ToStzCCode()

		def ToStzCCodeQ()
			return This.ToStzCCode()
  
                                                              
                 ///////////////////////////////////////////////
                //                              ///////////////
      ///////////      ALTERNATIVE FORMS       /////////////
 ///////////////                              //
///////////////////////////////////////////////

	  #--------------------------#
	 #  ALTERNATIVES OF Find()  #
	#--------------------------#

	def FindAllOccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllOccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
						
		def FFindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
	
	def FindAllCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindAllCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindSubstringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindSubstringCSQ(pcSubStr, pCaseSensitive)
			return This.FindSubstringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindSubstringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def OccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def OccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.OccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def OccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsOfSubStringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsOfSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindPositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindPositionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindPositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindPositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindAll(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindAllQ(pcSubStr)
			return This.FindAllQR(pcSubStr, :stzList)
				
		def FindAllQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindSubStringQ(pcSubStr)
			return This.FindSubStringQR(pcSubStr, :stzList)
				
		def FindSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Occurrences(pcSubStr)
		return This.Find(pcSubStr)
	
		def OccurrencesQ(pcSubStr)
			return This.OccurrencesQR(pcSubStr, :stzList)
				
		def OccurrencesQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Positions(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsQ(pcSubStr)
			return This.PositionsQR(pcSubStr, :stzList)
				
		def PositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)
	
	def PositionsOfSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsOfSubStringQ(pcSubStr)
			return This.PositionsOfSubStringQR(pcSubStr, :stzList)
				
		def PositionsOfSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindPositions(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindPositionsQ(pcSubStr)
			return This.FindPositionsQR(pcSubStr, :stzList)
				
		def FindPositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindOccurrences(pcSubStr)
		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok
	
		return This.Find(pcSubStr)
	
		def FindOccurrencesQ(pcSubStr)
			return This.FindOccurrencesQR(pcSubStr, :stzList)
				
		def FindOccurrencesQR(pcSubStr, pcReturnType)
			return This.FindAllQR(pcSubStr, pcReturnType)
	
	def FindAllOccurrences(pcSubStr)
		return This.FindOccurrences(pcSubStr)

	  #--------------------------------#
	 #  ALTERNATIVES OF SubStrings()  #
	#--------------------------------#

	def AllSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def AllPossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllPossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllPossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def PossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def PossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def PossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	#-- WITHOUT CASESENSITIVE

	def AllSubStrings()
		return This.SubStrings()

		def AllSubStringsQ()
			return This.SubStringsQ()

		def AllSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def AllPossibleSubStrings()
		return This.SubStrings()

		def AllPossibleSubStringsQ()
			return This.SubStringsQ()

		def AllPossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def PossibleSubStrings()
		return This.SubStrings()

		def PossibleSubStringsQ()
			return This.SubStringsQ()

		def PossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	  #----------------------------#
	 #  ALTERNATIVES OF Append()  #
	#----------------------------#

	def Add(pcOtherStr)
		This.Append(pcOtherStr)

		def AddQ(pcOtherStr)
			This.Add(pcOtherStr)
			return This

	def AddToEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddToEndQ(pcOtherStr)
			This.AddToEnd(pcOtherStr)
			return This

	def AddEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddEndQ(pcOtherStr)
			This.AddEnd(pcOtherStr)
			return This

	#--

	def AppendEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendEndQ(pcOtherStr)
			This.AppendEnd(pcOtherStr)
			return This

	def AppendFromEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendFromEndQ(pcOtherStr)
			This.AppendFromEnd(pcOtherStr)
			return This

	def AppendAtEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendAtEndQ(pcOtherStr)
			This.AppendAtEnd(pcOtherStr)
			return This

	  #-------------------------------#
	 #   ALTERNATIVES OF Appended()  #
	#-------------------------------#

	def Added(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AddedToEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedFromEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedAtEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Prepend()  #
	#----------------------------#

	def AddStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddStartQ(pcOtherStr)
			This.AddStart(pcOtherStr)
			return This

	def AddToStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddToStartQ(pcOtherStr)
			This.AddToStart(pcOtherStr)
			return This

	def AddAtStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddAtStartQ(pcOtherStr)
			This.AddAtStart(pcOtherStr)
			return This

	def AddFromStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddFromStartQ(pcOtherStr)
			This.AddFromStart(pcOtherStr)
			return This

	  #--------------------------------#
	 #   ALTERNATIVES OF Prepended()  #
	#--------------------------------#

	def AddedToStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedFromStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedAtStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	  #------------------------------#
	 #  ALTERNATIVES OF FindMany()  #
	#------------------------------#

	def FindManySubStringsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQ(pacSubStr, pCaseSensitive)
		
		def FindManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	def FindTheseSubStringsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQ(pacSubStr, pCaseSensitive)
		
		def FindTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindManySubStrings(pacSubStr)
		return This.FindMany(pacSubStr)

		def FindManySubStringsQ(pacSubStr)
			return This.FindManyQ(pacSubStr)
		
		def FindManySubStringsQR(pacSubStr, pcReturnType)
			return This.FindManyQR(pacSubStr, pcReturnType)

	def FindTheseSubStrings(pacSubStr)
		return This.FindMany(pacSubStr)

		def FindTheseSubStringsQ(pacSubStr)
			return This.FindManyQ(pacSubStr)
		
		def FindTheseSubStringsQR(pacSubStr, pcReturnType)
			return This.FindManyQR(pacSubStr, pcReturnType)

	  #----------------------------------------#
	 #  ALTERNATIVES OF FindManyAsSections()  #
	#----------------------------------------#

	def FindSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

	def FindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsAsSections(pacSubStr)
		return This.FindManyAsSections(pacSubStr)

	def FindTheseSubStringsAsSections(pacSubStr)
		return This.FindManyAsSections(pacSubStr)

	  #---------------------------------------#
	 #  ALTERNATIVES OF FindAnySplittedBy()  #
	#---------------------------------------#

	def FindAnySeparatedByCS(pcSeparator, pCaseSensitive)
		return This.FindAnySplittedByCS(pcSeparator, pCaseSensitive)

		#< @FunctionFluentForms

		def FindAnySeparatedByCSQ(pcSeparator, pCaseSensitive)
			return This.FindAnySplittedByCSQR(pcSeparator, pCaseSensitive, :stzList)

		def FindAnySeparatedByCSQR(pcSeparator, pCaseSensitive, pcReturnType)
			return This.FindanySplittedByCSQR(pcSeparator, :CaseSensitive = TRUE, pcReturnType)				
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySeparatedBy(pcSeparator)
		return This.FindAnySplittedBy(pcSeparator)			

		#< @FunctionFluentForms

		def FindAnySeparatedByQ(pcSeparator)
			return This.FindAnySeparatedByQR(pcSeparator, :stzList)

		def FindAnySeparatedByQR(pcSeparator, pcReturnType)
			return This.FindAnySplittedByCSQR(pcSeparator, :CaseSensitive = TRUE, pcReturnType)				

		#>

	  #-------------------------------#
	 #  ALTERNATIVES OF FindManyZ()  #
	#-------------------------------#

	def TheseSubStringsAndTheirPositionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyZCS(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirPositionsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyZCSQ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirPositionsCSQR(pacSubStr, pcReturnType)
			return This.FindManyZCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsAndTheirPositions(pacSubStr)
		return This.FindManyZ(pacSubStr)

		def TheseSubStringsAndTheirPositionsQ(pacSubStr)
			return This.FindManyZZQ(pacSubStr)

		def TheseSubStringsAndTheirPositionsQR(pacSubStr, pcReturnType)
			return This.FindManyZQR(pacSubStr, pcReturnType)

	  #--------------------------------#
	 #  ALTERNATIVES OF FindManyZZ()  #
	#--------------------------------#

	def TheseSubStringsAndTheirSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyZZCS(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirSectionsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyZZCSQ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirSectionsCSQR(pacSubStr, pcReturnType)
			return This.FindManyZZCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsAndTheirSections(pacSubStr)
		return This.FindManyZZ(pacSubStr)

		def TheseSubStringsAndTheirSectionsQ(pacSubStr)
			return This.FindManyZZQ(pacSubStr)

		def TheseSubStringsAndTheirSectionsQR(pacSubStr, pcReturnType)
			return This.FindManyZZQR(pacSubStr, pcReturnType)

	  #------------------------------------#
	 #  ALTERNATIVES OF FindAsSections()  #
	#------------------------------------#

	def FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSubStringAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

		def FindSubStringAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSections(pcSubStr)
		return This.FindAsSections(pcSubStr)

		def FindSubStringAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQ(pcSubStr)

		def FindSubStringAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsSectionsQR(pcSubStr, pcReturnType)

	  #------------------------------#
	 #  ALTERNATIVES OF FindNext()  #
	#------------------------------#

	def FindNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

	def FindNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstNextCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstNextCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

	def FirstNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FindNextS(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextFirstOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FirstNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	  #----------------------------------#
	 #  ALTERNATIVES OF FindPrevious()  #
	#----------------------------------#

	def FindPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FindPreviousSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FirstPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FindPreviousS(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousFirstOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FirstPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	  #-----------------------------#
	 #  ALTERNATIVES OF FindNth()  #
	#-----------------------------#

	def FindNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def PositionOfNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrencePositionCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def SubStringPositionByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def FindSubStringByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def PositionOfNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrencePosition(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def SubStringPositionByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def FindSubStringByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def Nth(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrence(n, pcSubStr)
		return This.FindNthC(n, pcSubstr)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindNthNext()  #
	#---------------------------------#

	def FindNthNextOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pcSubStr, nStart )
		return This.FindNthNext( n, pcSubStr, nStart )

	def FindNthNextOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def FindNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def FindNthNextS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def PositionOfNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNthNext(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def NthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def NextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	  #------------------------------------------#
	 #  ALTERNATIVES OF FindNthNextAsSection()  #
	#------------------------------------------#

	def FindNthNextOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthNextAsSection( n, pcSubStr, nStart )

	def FindNthNextOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNthNextAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def PositionOfNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def NthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def NextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindNthPrevious()  #
	#-------------------------------------#

	def FindNthPreviousOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindPreviousNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence( n, pcSubStr, nStart )
		return This.FindNthPrevious( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindNthPreviousS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PositionOfPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def NthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindNthPreviousAsSection()  #
	#----------------------------------------------#

	def FindNthPreviousOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindPreviousNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthPreviousAsSection( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindNthPreviousAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PositionOfPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def NthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindAllNext()  #
	#---------------------------------#

	def FindAllNextSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def NextPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindNextOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllNextS(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def FindNextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def NextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def FindNextOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindAllPrevious()  #
	#-------------------------------------#

	def FindAllPreviousSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def PreviousPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindPreviousOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllPreviousS(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def PreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def FindPreviousOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindBetween()  #
	#---------------------------------#

	def FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisSubStringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)

	def FindSubstringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindSubstringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

		def FindSubstringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindThisBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

		def FindThisBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQRQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	#--

	def FindThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def FindThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def FindSubstringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubstringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindSubstringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds, pCaseSensitive)

		def FindThisBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindThisBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindThisBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	#-- WITHOUT CASESENSITIVITY

	def FindThisSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenQ(pcSubStr, pcBound1, pcBound2)

		def FindThisSubStringBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)

	def FindSubstringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindSubstringBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubstringBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

		def FindSubstringBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindThisBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindThisBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

		def FindThisBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenCSQRQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	#--

	def FindThisSubStringBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def FindThisSubStringBoundedByQ(pcSubStr, pacBounds)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindThisSubStringBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindSubStringBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def FindSubstringBoundedByQ(pcSubStr, pacBounds)
			return This.FindSubstringBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindSubstringBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr,  pacBounds[1], pacBounds[2])

		def FindThisBoundedByQ(pcSubStr, pacBounds)
			return This.FindThisBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindThisBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	  #-------------------------------------------#
	 #  ALTERNATIVES OF FindBetweenAsSections()  #
	#-------------------------------------------#

	
	def FindThisBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindSubstringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindSubstringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

	def FindThisSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindSubstringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisSubStringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindSubstringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindThisBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindSubstringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
		def FindThisBetweenAsSectionsQ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubstringBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
		
		def FindThisBetweenAsSectionsQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindSubstringBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)

	def FindThisSubStringBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindSubstringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

		def FindThisSubStringBetweenAsSectionsQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2)
	
		def FindThisSubStringBetweenAsSectionsQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2)

	  #-----------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceBetween()  #
	#-----------------------------------------------#

	def NumberOfOccurrencesBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def NumberOfSectionsBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def CountBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def HaowManyBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def NumberOfSectionsBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def CountBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def HowManyBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceXT()  #
	#------------------------------------------#

	def NumberOfOccurrencesXTCS(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrenceOfSubstringXTCS(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrencesOfSubstringXTCS(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

	def CountXTCS(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

	def HowManyXTCS(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceXTCS(pcSubStr, pacBetween, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrenceOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrencesOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def CountXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def HowManyXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	  #-----------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceW()  #
	#-----------------------------------------#

	def CountW(pcCondition, pCaseSensitive)
		return This.NumberOfOccurrenceW(pcCondition, pCaseSensitive)

	def HowManyW(pcCondition, pCaseSensitive)
		return This.NumberOfOccurrenceW(pcCondition, pCaseSensitive)

	  #------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetween()  #
	#------------------------------------#

	def FindSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetween(pcBound1, pcBound2)
		return This.FindAnyBetween(pcBound1, pcBound2)

	def FindSubStringsBoundedBy(pcBound1, pcBound2)
		return This.FindBoundedByAsSections(pcBound1, pcBound2)

	  #--------------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetweenSections()  #
	#--------------------------------------------#

	def FindSubStringsBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenAsSections(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

	def FindSubStringsBoundedByAsSections(pcBound1, pcBound2)
		return This.FindAnyBoundedByAsSections(pcBound1, pcBound2)

	  #-------------------------------------------------------#
	 #  ALTERNATIVES OF FindNthSubStringBetweenAsSections()  #
	#-------------------------------------------------------#

	def FindNthBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindNthSubStringBoundedByAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindNthBoundedByAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)
		
	def FindNthSubStringBoundedByAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)

	def FindNthBoundedByAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)

	  #---------------------------------------------------------#
	 #  ALTERNATIVES OF FindFirstSubStringBetweenAsSections()  #
	#---------------------------------------------------------#

	def FindFirstBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindFirstSubStringBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindFirstBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
	def FindFirstSubStringBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	def FindFirstBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	  #--------------------------------------------------------#
	 #  ALTERNATIVES OF FindLastSubStringBetweenAsSections()  #
	#--------------------------------------------------------#

	def FindLastBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindLastSubStringBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindLastBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
	def FindLastSubStringBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	def FindLastBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	  #---------------------------------------------#
	 #  ALTERNATIVES OF FindBetweenAsSectionsIB()  #
	#---------------------------------------------#

	def FindNthSubStringBetweenAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindNthSubStringBoundedByAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindNthBoundedByAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsIBCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		
	def FindNthSubStringBoundedByAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)

	def FindNthBoundedByAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)

	  #--------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetweenIB()  #
	#--------------------------------------#

	def FindSubStringsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenIB(pcBound1, pcBound2)
		return This.FindAnyBetweenIB(pcBound1, pcBound2)

	def FindSubStringsBoundedByIB(pcBound1, pcBound2)
		return This.FindAnyBoundedByIB(pcBound1, pcBound2)

	  #--------------------------------------------------#
	 #  ALTERNATIVES OF FindAnyBoundedByAsSectionsIB()  #
	#--------------------------------------------------#

	def FindSubStringsBetweenAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindanyBetweenAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByAsSectionsIBCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsIB(pcBound1, pcBound2)

	def FindSubStringsBoundedByAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBoundedByAsSectionsIB(pcBound1, pcBound2)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF RemoveSubStringBetweenIB()  #
	#----------------------------------------------#

	def RemoveThisBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSubStringBetweenIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisBetweenIBCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSubStringBetweenIBCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisSubStringBetweenIBCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenIBCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSubStringBetweenIBCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveThisSubStringBoundedByIBCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveThisSubStringBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveSubStringBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSubStringBetweenIBCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveSubStringBoundedByIBCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveSubStringBoundedByIBCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenIB(pcSubStr,pcBound1, pcBound2)

		def RemoveThisBetweenIBQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenIB(pcSubStr,pcBound1, pcBound2)

		def RemoveThisSubStringBetweenIBQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBoundedByIB(pcSubStr, pacBounds)
		This.RemoveSubStringBetweenIB(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveThisSubStringBoundedByIBQ(pcSubStr, pacBounds)
			This.RemoveThisSubStringBoundedByIB(pcSubStr, pacBounds)
			return This

	#--

	def RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
		This.RemoveSubStringBetweenIB(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveSubStringBoundedByIBQ(pcSubStr, pacBounds)
			This.RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
			return This

	  #-----------------------------------#
	 #  ALTERNATIVES OF NthBetweenIBZ()  #
	#-----------------------------------#

	def NthSubStringBetweenIBZCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenIBZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIBZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZ(n, pcBound1, pcBound2)

	  #------------------------------------#
	 #  ALTERNATIVES OF NthBetweenIBZZ()  #
	#------------------------------------#

	def NthSubStringBetweenIBZZCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenIBZZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIBZZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZZ(n, pcBound1, pcBound2)

	  #----------------------------------#
	 #  ALTERNATIVES OF NthBetweenIB()  #
	#----------------------------------#
	
	def NthSubStringBetweenIBCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenIBCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIB(n, pcBound1, pcBound2)
		return This.NthBetweenIB(n, pcBound1, pcBound2)

	  #----------------------------------#
	 #  ALTERNATIVES OF NthBetweenZZ()  #
	#----------------------------------#

	def NthSubStringBetweenZZCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenZZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenZZ(n, pcBound1, pcBound2)
		return This.NthBetweenZZ(n, pcBound1, pcBound2)


	  #---------------------------------#
	 #  ALTERNATIVES OF NthBetweenZ()  #
	#---------------------------------#

	def NthSubStringBetweenZCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenZCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenZ(n, pcBound1, pcBound2)
		return This.NthBetweenZ(n, pcBound1, pcBound2)

	  #--------------------------------#
	 #  ALTERNATIVES OF NthBetween()  #
	#--------------------------------#

	def NthSubStringBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetween(n, pcBound1, pcBound2)
		return This.NthBetween(n, pcBound1, pcBound1)


	  #-------------------------------------------------#
	 #  ALTERNATIVES OF NumberOfSubStringsBoundedBy()  #
	#-------------------------------------------------#

	def CountSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def HowManySubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def HowManySubStringBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		return This.NumberOfSubStringsBoundedByCS(pacBounds[1], pacBounds[2], pCaseSensitive)

	def CountSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def HowManySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def HowManySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CountSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	def HowManySubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	def HowManySubStringBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	#--

	def NumberOfSubStringsBetween(pcBound1, pcBound2)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		return This.NumberOfSubStringsBoundedBy(pacBounds[1], pacBounds[2])

	def CountSubStringsBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetween(pcBound1, pcBound2)

	def HowManySubStringsBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2)

	def HowManySubStringBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2)

	  #----------------------------------------#
	 #  ALTERNATIVES OF SubstringsBetweenU()  #
	#----------------------------------------#

	def UniqueSubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def UniqueSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def UniqueSubStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSubstringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SubStringsBoundedByWithoutDuplicationCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def SubStringsBoundedByWithoutDuplicationCSQ(pacBounds, pCaseSensitive)
			return This.UniqueSubStringsBoundedByCSQ(pacBounds, pCaseSensitive)

		def SubStringsBoundedByWithoutDuplicationCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.UniqueSubstringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def UniqueSectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def UniqueSectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def UniqueSectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SectionsWithoutDuplicationBetwenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsWithoutDuplicationBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)


		def SectionsWithoutDuplicationBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.UniqueSectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	#==

	def SubStringsBoundedByUCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def SubStringsBoundedByUCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SubstringsBoundedByUCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#--

	def SectionsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)

		def USectionsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SectionsBoundedByUCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SectionsBoundedByUCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SectionsBoundedByUCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStringsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

	#--

	def UniqueSubStringsBoundedBy(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2], :stzList)

		def UniqueSubStringsBoundedByQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def UniqueSubstringsBoundedByQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#--

	def UniqueSectionsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def UniqueSectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def UniqueSectionsBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsWithoutDuplicationBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsWithoutDuplicationBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def SectionsWithoutDuplicationBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def UniqueSectionsBoundedBy(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2])

		def UniqueSectionsBoundedByQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def UniqueSectionsBoundedByQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsWithoutDuplicationBoundedBy(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsWithoutDuplicationBoundedByQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def SectionsWithoutDuplicationBoundedByQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#==

	def SubStringsBoundedByU(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2], :stzList)

		def SubStringsBoundedByUQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def SubstringsBoundedByUQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#--

	def SectionsBetweenU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def USectionsBetweenUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsBoundedByU(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2])

		def SectionsBoundedByUQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def SectionsBoundedByUQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	  #-------------------------------#
	 #  ALTERNATIVES OF BetweenIB()  #
	#-------------------------------#

	def AnyBetweenIBCS(p1, p2, pCaseSensitive)
		return This.BetweenIBCS(p1, p2, pCaseSensitive)

		def AnyBetweenIBCSQ(p1, p2, pCaseSensitive)
			return This.BetweenIBCSQ(p1, p2, pCaseSensitive)

		def AnyBetweenIBCSQR(p1, p2, pCaseSensitive, pcReturnType)
			return This.BetweenIBCSQR(p1, p2, pCaseSensitive, pcReturnType)

	def BoundedByIBCS(pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.BetweenIBCS(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			return This.BetweenIBCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
		ok

		def BoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.BoundedByIBCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def BoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.BetweenIBCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)
	
	def AnyBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.BetweenIBCS(pacBounds[1], pacBounds[2], pCaseSensitive)
	
		def AnyBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.AnyBoundedByIBCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def AnyBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.BetweenIBCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetweenIB(p1, p2)
		return This.BetweenIB(p1, p2)

		def AnyBetweenIBQ(p1, p2)
			return This.BetweenIBQ(p1, p2)

		def AnyBetweenIBQR(p1, p2, pcReturnType)
			return This.BetweenIBQR(p1, p2, pcReturnType)

	def BoundedByIB(pacBounds)
		return This.BoundedByIBCS(pacBounds, :CaseSensitive = TRUE)
	
		def BoundedByIBQ(pacBounds)
			return This.BoundedByIBQR(pacBounds, :stzList)
	
		def BoundedByIBQR(pacBounds, pcReturnType)
			return This.BetweenIBQR(pacBounds[1], pacBounds[2], pcReturnType)
	
	def AnyBoundedByIB(pacBounds, pCaseSensitive)
		return This.BoundedByIB(pacBounds)
	
		def AnyBoundedByIBQ(pacBounds)
			return This.AnyBoundedByIBQR(pacBounds, :stzList)
	
		def AnyBoundedByIBQR(pacBounds, pcReturnType)
			return This.BetweenIBCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	  #------------------------------------------#
	 #  ALTERNATIVES OF SubStrtingsBetweenIB()  #
	#------------------------------------------#

	def AnySubStringBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	#--

	def AnySubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	def SectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def SectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def AnySectionBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionBoundedByCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def SubStringsBoundedByIBCS(pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.SubStringsBetweenIBCS(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			return This.SubStringsBetweenIBCS(pacBounds[1], pacBounds[2], pCaseSensitive)
		ok

		def SubStringsBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBCSQR(pacBounds, pCaseSensitive, :stzList)

		def SubStringsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenIBCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#--

	def AnySubStringBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByIBCS(pacBounds, pCaseSensitive)

		def AnySubStringBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBCSQ(pacBounds, pCaseSensitive)

		def AnySubStringBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySubStringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringsBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByIBCS(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByIBCSQ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	def SectionsBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.SubstringsBoundedByIBCS(pacBounds, pCaseSensitive)

		def SectionsBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def AnySectionBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySectionBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByIBCSQ(pacBounds, pCaseSensitive)

		def AnySectionBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySectionsBetweenIBCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenIBCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenIBCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionsBoundedByIBCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByIBCS(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByIBCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByIBCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnySubStringBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def SubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByIBCS(pacBounds, :CaseSensitive = TRUE)
		
		def SubStringsBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQR(pacBounds, :stzList)

		def SubStringsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByIBCSQR(pacBounds, :CaseSensitive = TRUE, pcReturnType)

	def AnySubStringBoundedByIB(pacBounds)
		return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQ(pacBounds)

		def AnySubStringBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByIBQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringsBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQ(pacBounds)

		def AnySubStringsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByIBQR(pacBounds,  pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenIB(pcSubStr1, pcSubStr2)

		def SectionsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

	def SectionsBoundedByIB(pacBounds)
		return This.SubstringsBoundedByIB(pacBounds)

		def SectionsBoundedByIBQ(pacBounds)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

	#--

	def AnySectionBetweenIB(pcSubStr1, pcSubStr2)
		return This.SectionsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySectionBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySectionBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionBoundedByIB(pacBounds)
		return This.SectionsBoundedByIB(pacBounds)

		def AnySectionBoundedByIBQ(pacBounds)
			return This.SectionsBoundedByIBQ(pacBounds)

		def AnySectionBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByIBQR(pacBounds,  pcReturnType)

	#--

	def AnySectionsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SectionsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionsBoundedByIB(pacBounds)
		return This.SectionsBoundedByIB(pacBounds)

		def AnySectionsBoundedByIBQ(pacBounds)
			return This.SectionsBoundedByIBQ(pacBounds)

		def AnySectionsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringBoundedBy(pacBounds)
		return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQ(pacBounds)

		def AnySubStringBoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringsBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringsBoundedBy(pacBounds)
		return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringsBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQ(pacBounds)

		def AnySubStringsBoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByQR(pacBounds,  pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetween(pcSubStr1, pcSubStr2)

		def SectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

	def SectionsBoundedBy(pacBounds)
		return This.SubstringsBoundedBy(pacBounds)

		def SectionsBoundedByQ(pacBounds)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

	#--

	def AnySectionBetween(pcSubStr1, pcSubStr2)
		return This.SectionsBetween(pcSubStr1, pcSubStr2)

		def AnySectionBetweenQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySectionBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionBoundedBy(pacBounds)
		return This.SectionsBoundedBy(pacBounds)

		def AnySectionBoundedByQ(pacBounds)
			return This.SectionsBoundedByQ(pacBounds)

		def AnySectionBoundedByQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySectionsBetween(pcSubStr1, pcSubStr2)
		return This.SectionsBetween(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionsBoundedBy(pacBounds)
		return This.SectionsBoundedBy(pacBounds)

		def AnySectionsBoundedByQ(pacBounds)
			return This.SectionsBoundedByQ(pacBounds)

		def AnySectionsBoundedByQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	  #---------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetween()  #
	#---------------------------------------#

	def AnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnyBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnyBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
				return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def BoundedByCS(pacBounds, pCaseSensitive)
		acResult = []

		if isString(pacBounds)
			acResult = This.SubStringsBetweenCS(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			acResult = This.SubStringsBetweenCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
		ok

		return acResult

		def BoundedByCSQ(pacBounds, pCaseSensitive)
			return This.BoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def BoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def AnyBoundedByCS(pacBounds, pCaseSensitive)
		return This.BoundedByCS(pacBounds, pCaseSensitive)

		def AnyBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.AnyBoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def AnyBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.BoundedByCS(pacBounds, pCaseSensitive)

		def subStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnyBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnyBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenCQR(pcSubStr1, pcSubStr2, pcReturnType)

	def BoundedBy(pacBounds)
		return This.SubStringsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		def BoundedByQ(pacBounds)
			return This.BoundedByQR(pacBounds, :stzList)

		def BoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2],  pcReturnType)

	def AnyBoundedBy(pacBounds)
		return This.BoundedBy(pacBounds)

		def AnyBoundedByQ(pacBounds)
			return This.AnyBoundedByQR(pacBounds, :stzList)
	
		def AnyBoundedByQR(pacBounds, pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SubStringsBoundedBy(pacBounds)
		return This.BoundedBy(pacBounds)

		def subStringsBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQR(pacBounds, :stzList)
	
		def SubStringsBoundedByQR(pacBounds, pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2], pcReturnType)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindSplittedByAsSections()  #
	#----------------------------------------------#

	def FindSeparatedByAsSectionsCS(pcSubStr, pCaseSensitive)
		return This.FindSplittedByAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSeparatedByAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindSeparatedByAsSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindSeparatedByAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindSplittedByAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)				

	#-- WITHOUT CASESENSITIVITY

	def FindSeparatedByAsSections(pcSubStr)
		return This.FindSplittedByAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSeparatedByAsSectionsQ(pcSubStr)
			return This.FindSeparatedByAsSectionsQR(pcSubStr, :stzList)

		def FindSeparatedByAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindSplittedByAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)				

	  #------------------------------------#
	 #  ALTERNATIVES OF AnyDeepBetween()  #
	#------------------------------------#
	# TODO: Add BoundedBy alternatives!

	def DeepSubStringsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSubStringBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSubStringsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionssBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSectionBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectiongBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSectionsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

	def AnyDeepSubStringBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSubStringsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

	def AnyDeepSectionBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSectiongBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSectionBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSectionsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	  #-------------------------------------#
	 # ALTERNATIVES OF AnyDeepBetweenIB()  #
	#-------------------------------------#

	def DeepSubStringsBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSubStringBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSubStringsBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSectionBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectiongBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSectionsBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenIBCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenIBCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenIBCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

	def AnyDeepSubStringBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSubStringsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

	def AnyDeepSectionBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSectiongBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSectionBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSectionsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	  #---------------------------------------#
	 #  ALTERNATIVES OF RemoveSubStringAt()  #
	#---------------------------------------#

	def RemoveAtCS(n, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		def RemoveAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveAtCS(n, pcSubStr, pCaseSensitive)
			return This

	def RemoveAtPositionCS(n, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		def RemoveAtPositionCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAt(n, pcSubStr)
		This.RemoveSubStringAtPosition(n, pcSubStr)

		def RemoveAtQ(n, pcSubStr)
			This.RemoveAt(n, pcSubStr)
			return This

	def RemoveAtPosition(n, pcSubStr)
		This.RemoveSubStringAtPosition(n, pcSubStr)

		def RemoveAtPositionQ(n, pcSubStr)
			This.RemoveAtPosition(n, pcSubStr)
			return This

	  #----------------------------------#
	 #  ALTERNATIVES OF ContainsSome()  #
	#----------------------------------#

	def ContainsOneOrMoreOccurrencesCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsOneOrMoreOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsSomeOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	 def ContainsOneOrMoreOfTheseSubStringsCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsSomeOfTheseSubStringsCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	def ContainsOneOrMoreSubStringOfCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsOneOrMoreSubStringOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	def ContainsManyOccurrencesCS(pcSubstr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)
				
	def ContainsSomeOccurrencesCS(pcSubstr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)
				
	def ContainsMoreThenOneCS(pcSubStr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMoreOccurrences(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsOneOrMoreOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsSomeOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	 def ContainsOneOrMoreOfTheseSubStrings(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsSomeOfTheseSubStrings(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	def ContainsOneOrMoreSubStringOf(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsOneOrMporeSubStringOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	def ContainsManyOccurrences(pcSubstr)
		return This.ContainsSome(pcSubstr)
		
	def ContainsSomeOccurrences(pcSubstr)
		return This.ContainsSome(pcSubstr)
				
	def ContainsMoreThenOne(pcSubStr)
		return This.ContainsSome(pcSubstr)
	
	  #--------------------------------------#
	 #  ALTERNATIVES OF RemoveAnyBetween()  #
	#--------------------------------------#

	def RemoveSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveAnyBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnyBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSectionsBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveBetweenByCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveSectionsBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveSectionsBoundedByCS(paBounds, pCaseSensitive)
			return This

	def RemoveAnySectionBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveAnyBetweenCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveAnySectionBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveAnySectionBoundedByCS(paBounds, pCaseSensitive)
			return This

	def RemoveAnySectionsBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveBetweenByCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveAnySectionsBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveAnySectionsBoundedByCS(paBounds, pCaseSensitive)
			return This
	
	#-- WTHOUT CASESENSITIVITY

	def RemoveSubStringsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveSubStringsBetweenQ(pcBound1, pcBound2)
			This.RemoveSubStringsBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySubStringBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySubStringsBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBetween(pcBound1, pcBound2)
			return This

	#--

	def RemoveAnyBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnyBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnyBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveSubStringsBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveSubStringsBoundedByQ(pcBound1, pcBound2)
			This.RemoveSubStringsBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnySubStringBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnySubStringsBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBoundedBy(pcBound1, pcBound2)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveSectionsBetweenQ(pcBound1, pcBound2)
			This.RemoveSectionsBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySectionBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySectionBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySectionsBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBetween(pcBound1, pcBound2)
			return This

	#--

	def RemoveSectionsBoundedBy(paBounds)
		This.RemoveBetweenBy(paBounds[1], paBounds[2])

		def RemoveSectionsBoundedByQ(paBounds)
			This.RemoveSectionsBoundedBy(paBounds)
			return This

	def RemoveAnySectionBoundedBy(paBounds)
		This.RemoveAnyBetween(paBounds[1], paBounds[2])

		def RemoveAnySectionBoundedByQ(paBounds)
			This.RemoveAnySectionBoundedBy(paBounds)
			return This

	def RemoveAnySectionsBoundedBy(paBounds)
		This.RemoveBetweenBy(paBounds[1], paBounds[2])

		def RemoveAnySectionsBoundedByQ(paBounds)
			This.RemoveAnySectionsBoundedBy(paBounds)
			return This

	  #---------------------------------------#
	 #  ALTERNATIVES OF AnyBetweenRemoved()  #
	#---------------------------------------#

	def SubStringsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def AnyBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def SubStringsBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def AnySubStringBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def AnySubStringsBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def SectionsBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySubStringBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySubStringsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	#--

	def AnyBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def SubStringsBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def AnySubStringBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def AnySubStringsBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	#--

	def SectionsBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionsBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	  #-----------------------------------#
	 #  ALTERNATIVES OF RemoveBetween()  #
	#-----------------------------------#

	def RemoveThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveThisBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetween(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveThisSubStringBoundedByQ(pcSubStr, pacBounds)
			This.RemoveThisSubStringBoundedBy(pcSubStr, pacBounds)
			return This

	#--

	def RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveSubStringBoundedByQ(pcSubStr, pacBounds)
			This.RemoveSubStringBoundedBy(pcSubStr, pacBounds)
			return This

	#--

	def RemoveThisSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This

	  #--------------------------------------#
	 #  ALTERNATIVES OF RemoveAnyBetween()  #
	#--------------------------------------#

	def RemoveSubStringsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSubStringsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBetweenIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSectionsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenIBCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBoundedByIBCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBoundedByIBCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSubStringsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveSubStringsBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBetweenIB(pcBound1, pcBound2)
			return This

	#--

	def RemoveSubStringsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSubStringsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveSubStringsBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBoundedByIB(pcBound1, pcBound2)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSectionsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveSectionsBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBetweenIB(pcBound1, pcBound2)
			return This

	#--

	def RemoveSectionsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSectionsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveSectionsBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBoundedByIB(pcBound1, pcBound2)
			return This

	  #-----------------------------------------#
	 #  ALTERNATIVES OF AnyBetweenRemovedIB()  #
	#-----------------------------------------#

	def SubStringsBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def AnyBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def SubStringsBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def SectionsBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBoundedByRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedIBCS(pcBound1, pcBound2, pCaseSensitive)

	  #-----------------------------#
	 #  ALTERNATIVES OF Replace()  #
	#-----------------------------#

	def ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllOccurrencesCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAllOccurrencesOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This		

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceAll(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllQ(pcSubStr, pcNewSubStr)
			This.ReplaceAll(pcSubStr, pcNewSubStr)
			return This

	def ReplaceSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceSubstring(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrencesOfSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesOfSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr)
			return This		

	  #------------------------------------#
	 #  ALTERNATIVES OF ReplaceBetween()  #
	#------------------------------------#

	def ReplaceThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def ReplaceThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

	def ReplaceThisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def ReplaceThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplacethisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

	#--

	def ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		return This.ReplaceThisSubStringBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr, pCaseSensitive)

		def ReplaceThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This

	def ReplaceThisBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
		This.ReplaceThisSubStringBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr, pCaseSensitive)

		def ReplaceThisBoundedByCSQ(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def ReplaceThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceThisSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

	def ReplaceThisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def ReplaceThisBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplacethisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

	#--

	def ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
		return This.ReplaceThisSubStringBetween(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr)

		def ReplaceThisSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubstr)
			This.ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
			return This

	def ReplaceThisBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
		This.ReplaceThisSubStringBetween(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr)

		def ReplaceThisBoundedByQ(pcSubStr, pacBounds, pcNewSubstr)
			This.ReplaceThisBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
			return This

	  #---------------------------------------#
	 #  ALTERNATIVES OF ReplaceAnyBetween()  #
	#---------------------------------------#

	def ReplaceSubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		if isString(pacBounds)
			This.ReplaceAnyBetweenCS(pacBounds, pacBounds, pcNewSubStr, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsListOfPairs()
			This.ReplaceAnyBetweenCS(pacBounds[1], pacBounds[2], pcNewSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
		ok

		def ReplaceAnyBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceSectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(ppacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)
		return This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

	def ReplaceSubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceSectionsBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceSectionsBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceSectionsBoundedBy(pacBounds, pcNewSubStr)
			return This

	def ReplaceAnySectionBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceAnySectionBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySectionBoundedBy(pacBounds, pcNewSubStr)
			return This

	def ReplaceAnySectionsBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceAnySectionsBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySectionsBoundedBy(pacBounds, pcNewSubStr)
			return This

	  #-----------------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetweenReplaced()  #
	#-----------------------------------------------#

	def AnyBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def AnyBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SectionsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SubStringsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnyBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SectionsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Remove()  #
	#----------------------------#

	def RemoveAllCS(pSubStr, pCaseSensitive)
		This.RemoveCS(pSubStr, pCaseSensitive)

		def RemoveAllCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllCS(pSubStr, pCaseSensitive)
			return This

	def RemoveSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveSubstringCS(pSubStr, pCaseSensitive)
			return This

	def RemoveAllOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveAllOccurrencesOfSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllOccurrencesOfSubstringCS(pSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAll(pSubStr)
		This.Remove(pSubStr)

		def RemoveAllQ(pSubStr)
			This.RemoveAll(pSubStr)
			return This

	def RemoveSubstring(pcSubStr, pCaseSensitive)
		This.Remove(pcSubStr)

		def RemoveSubstringQ(pSubStr)
			This.RemoveSubstring(pSubStr)
			return This

	def RemoveAllOccurrencesOfSubstring(pcSubStr)
		This.Remove(pcSubStr)

		def RemoveAllOccurrencesOfSubstringQ(pSubStr)
			This.RemoveAllOccurrencesOfSubstring(pSubStr)
			return This

	  #-------------------------------------------#
	 #  ALTERNATIVES OF ReplaceAnyBetweenIBCS()  #
	#-------------------------------------------#

	def ReplaceSubStringsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		if isString(pacBounds)
			This.ReplaceAnyBetweenIBCS(pacBounds, pacBounds, pcNewSubStr, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			This.ReplaceAnyBetweenIBCS(pacBounds[1], pacBounds[2], pcNewSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or apair of strings.")
		ok

	def ReplaceSubStringsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBetweenIBCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBetweenIBCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceSectionsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBoundedByIBCS(ppacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBoundedByIBCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBoundedByIBCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceAnyBoundedByIB(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedByIBCS(pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

	def ReplaceSubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceSectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceanyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	  #-------------------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetweenReplacedXT()  #
	#-------------------------------------------------#

	def AnySubStringBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SubStringsBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SectionsBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBoundedByReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedXTCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AnySubStringBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SubStringsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SectionsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

